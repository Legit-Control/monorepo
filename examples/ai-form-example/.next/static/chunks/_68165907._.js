(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/packages/sdk/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// legit-sdk library bundle
// Generated by esbuild
__turbopack_context__.s([
    "CompositeFs",
    ()=>Ho,
    "EphemeralSubFs",
    ()=>Vo,
    "GitSubFs",
    ()=>hf,
    "HiddenFileSubFs",
    ()=>Wo,
    "PassThroughSubFs",
    ()=>_l,
    "createGitSyncService",
    ()=>g3,
    "getLegitFsAccess",
    ()=>_3,
    "gitBranchOperationsVirtualFile",
    ()=>rm,
    "initLegitFs",
    ()=>$H,
    "openLegitFs",
    ()=>K$
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var gx = Object.create;
var Bi = Object.defineProperty;
var bx = Object.getOwnPropertyDescriptor;
var vx = Object.getOwnPropertyNames;
var _x = Object.getPrototypeOf, Fx = Object.prototype.hasOwnProperty;
var Ex = (t, e, r)=>e in t ? Bi(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r;
_c = Ex;
var a = (t, e)=>Bi(t, "name", {
        value: e,
        configurable: !0
    }), Sx = ((t)=>("TURBOPACK compile-time value", "function") < "u" ? /*TURBOPACK member replacement*/ __turbopack_context__.z : typeof Proxy < "u" ? new Proxy(t, {
        get: (e, r)=>(("TURBOPACK compile-time value", "function") < "u" ? /*TURBOPACK member replacement*/ __turbopack_context__.z : e)[r]
    }) : t)(function(t) {
    if (("TURBOPACK compile-time value", "function") < "u") return /*TURBOPACK member replacement*/ __turbopack_context__.z.apply(this, arguments);
    throw Error('Dynamic require of "' + t + '" is not supported');
});
var xx = (t, e)=>()=>(t && (e = t(t = 0)), e);
var T = (t, e)=>()=>(e || t((e = {
            exports: {}
        }).exports, e), e.exports), Tx = (t, e)=>{
    for(var r in e)Bi(t, r, {
        get: e[r],
        enumerable: !0
    });
}, ym = (t, e, r, i)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let n of vx(e))!Fx.call(t, n) && n !== r && Bi(t, n, {
        get: ()=>e[n],
        enumerable: !(i = bx(e, n)) || i.enumerable
    });
    return t;
};
var ae = (t, e, r)=>(r = t != null ? gx(_x(t)) : {}, ym(e || !t || !t.__esModule ? Bi(r, "default", {
        value: t,
        enumerable: !0
    }) : r, t)), wm = (t)=>ym(Bi({}, "__esModule", {
        value: !0
    }), t);
var q = (t, e, r)=>Ex(t, typeof e != "symbol" ? e + "" : e, r);
var Er = T(_c1 = (OM, bm)=>{
    "use strict";
    function Mt(t) {
        if (typeof t != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(t));
    }
    a(Mt, "assertPath");
    function gm(t, e) {
        for(var r = "", i = 0, n = -1, o = 0, s, l = 0; l <= t.length; ++l){
            if (l < t.length) s = t.charCodeAt(l);
            else {
                if (s === 47) break;
                s = 47;
            }
            if (s === 47) {
                if (!(n === l - 1 || o === 1)) if (n !== l - 1 && o === 2) {
                    if (r.length < 2 || i !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
                        if (r.length > 2) {
                            var f = r.lastIndexOf("/");
                            if (f !== r.length - 1) {
                                f === -1 ? (r = "", i = 0) : (r = r.slice(0, f), i = r.length - 1 - r.lastIndexOf("/")), n = l, o = 0;
                                continue;
                            }
                        } else if (r.length === 2 || r.length === 1) {
                            r = "", i = 0, n = l, o = 0;
                            continue;
                        }
                    }
                    e && (r.length > 0 ? r += "/.." : r = "..", i = 2);
                } else r.length > 0 ? r += "/" + t.slice(n + 1, l) : r = t.slice(n + 1, l), i = l - n - 1;
                n = l, o = 0;
            } else s === 46 && o !== -1 ? ++o : o = -1;
        }
        return r;
    }
    a(gm, "normalizeStringPosix");
    function Ox(t, e) {
        var r = e.dir || e.root, i = e.base || (e.name || "") + (e.ext || "");
        return r ? r === e.root ? r + i : r + t + i : i;
    }
    a(Ox, "_format");
    var Li = {
        resolve: a(function() {
            for(var e = "", r = !1, i, n = arguments.length - 1; n >= -1 && !r; n--){
                var o;
                n >= 0 ? o = arguments[n] : (i === void 0 && (i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cwd()), o = i), Mt(o), o.length !== 0 && (e = o + "/" + e, r = o.charCodeAt(0) === 47);
            }
            return e = gm(e, !r), r ? e.length > 0 ? "/" + e : "/" : e.length > 0 ? e : ".";
        }, "resolve"),
        normalize: a(function(e) {
            if (Mt(e), e.length === 0) return ".";
            var r = e.charCodeAt(0) === 47, i = e.charCodeAt(e.length - 1) === 47;
            return e = gm(e, !r), e.length === 0 && !r && (e = "."), e.length > 0 && i && (e += "/"), r ? "/" + e : e;
        }, "normalize"),
        isAbsolute: a(function(e) {
            return Mt(e), e.length > 0 && e.charCodeAt(0) === 47;
        }, "isAbsolute"),
        join: a(function() {
            if (arguments.length === 0) return ".";
            for(var e, r = 0; r < arguments.length; ++r){
                var i = arguments[r];
                Mt(i), i.length > 0 && (e === void 0 ? e = i : e += "/" + i);
            }
            return e === void 0 ? "." : Li.normalize(e);
        }, "join"),
        relative: a(function(e, r) {
            if (Mt(e), Mt(r), e === r || (e = Li.resolve(e), r = Li.resolve(r), e === r)) return "";
            for(var i = 1; i < e.length && e.charCodeAt(i) === 47; ++i);
            for(var n = e.length, o = n - i, s = 1; s < r.length && r.charCodeAt(s) === 47; ++s);
            for(var l = r.length, f = l - s, c = o < f ? o : f, u = -1, h = 0; h <= c; ++h){
                if (h === c) {
                    if (f > c) {
                        if (r.charCodeAt(s + h) === 47) return r.slice(s + h + 1);
                        if (h === 0) return r.slice(s + h);
                    } else o > c && (e.charCodeAt(i + h) === 47 ? u = h : h === 0 && (u = 0));
                    break;
                }
                var d = e.charCodeAt(i + h), p = r.charCodeAt(s + h);
                if (d !== p) break;
                d === 47 && (u = h);
            }
            var m = "";
            for(h = i + u + 1; h <= n; ++h)(h === n || e.charCodeAt(h) === 47) && (m.length === 0 ? m += ".." : m += "/..");
            return m.length > 0 ? m + r.slice(s + u) : (s += u, r.charCodeAt(s) === 47 && ++s, r.slice(s));
        }, "relative"),
        _makeLong: a(function(e) {
            return e;
        }, "_makeLong"),
        dirname: a(function(e) {
            if (Mt(e), e.length === 0) return ".";
            for(var r = e.charCodeAt(0), i = r === 47, n = -1, o = !0, s = e.length - 1; s >= 1; --s)if (r = e.charCodeAt(s), r === 47) {
                if (!o) {
                    n = s;
                    break;
                }
            } else o = !1;
            return n === -1 ? i ? "/" : "." : i && n === 1 ? "//" : e.slice(0, n);
        }, "dirname"),
        basename: a(function(e, r) {
            if (r !== void 0 && typeof r != "string") throw new TypeError('"ext" argument must be a string');
            Mt(e);
            var i = 0, n = -1, o = !0, s;
            if (r !== void 0 && r.length > 0 && r.length <= e.length) {
                if (r.length === e.length && r === e) return "";
                var l = r.length - 1, f = -1;
                for(s = e.length - 1; s >= 0; --s){
                    var c = e.charCodeAt(s);
                    if (c === 47) {
                        if (!o) {
                            i = s + 1;
                            break;
                        }
                    } else f === -1 && (o = !1, f = s + 1), l >= 0 && (c === r.charCodeAt(l) ? --l === -1 && (n = s) : (l = -1, n = f));
                }
                return i === n ? n = f : n === -1 && (n = e.length), e.slice(i, n);
            } else {
                for(s = e.length - 1; s >= 0; --s)if (e.charCodeAt(s) === 47) {
                    if (!o) {
                        i = s + 1;
                        break;
                    }
                } else n === -1 && (o = !1, n = s + 1);
                return n === -1 ? "" : e.slice(i, n);
            }
        }, "basename"),
        extname: a(function(e) {
            Mt(e);
            for(var r = -1, i = 0, n = -1, o = !0, s = 0, l = e.length - 1; l >= 0; --l){
                var f = e.charCodeAt(l);
                if (f === 47) {
                    if (!o) {
                        i = l + 1;
                        break;
                    }
                    continue;
                }
                n === -1 && (o = !1, n = l + 1), f === 46 ? r === -1 ? r = l : s !== 1 && (s = 1) : r !== -1 && (s = -1);
            }
            return r === -1 || n === -1 || s === 0 || s === 1 && r === n - 1 && r === i + 1 ? "" : e.slice(r, n);
        }, "extname"),
        format: a(function(e) {
            if (e === null || typeof e != "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
            return Ox("/", e);
        }, "format"),
        parse: a(function(e) {
            Mt(e);
            var r = {
                root: "",
                dir: "",
                base: "",
                ext: "",
                name: ""
            };
            if (e.length === 0) return r;
            var i = e.charCodeAt(0), n = i === 47, o;
            n ? (r.root = "/", o = 1) : o = 0;
            for(var s = -1, l = 0, f = -1, c = !0, u = e.length - 1, h = 0; u >= o; --u){
                if (i = e.charCodeAt(u), i === 47) {
                    if (!c) {
                        l = u + 1;
                        break;
                    }
                    continue;
                }
                f === -1 && (c = !1, f = u + 1), i === 46 ? s === -1 ? s = u : h !== 1 && (h = 1) : s !== -1 && (h = -1);
            }
            return s === -1 || f === -1 || h === 0 || h === 1 && s === f - 1 && s === l + 1 ? f !== -1 && (l === 0 && n ? r.base = r.name = e.slice(1, f) : r.base = r.name = e.slice(l, f)) : (l === 0 && n ? (r.name = e.slice(1, s), r.base = e.slice(1, f)) : (r.name = e.slice(l, s), r.base = e.slice(l, f)), r.ext = e.slice(s, f)), l > 0 ? r.dir = e.slice(0, l - 1) : n && (r.dir = "/"), r;
        }, "parse"),
        sep: "/",
        delimiter: ":",
        win32: null,
        posix: null
    };
    Li.posix = Li;
    bm.exports = Li;
});
_c2 = Er;
var kt = T((Mi)=>{
    "use strict";
    Object.defineProperty(Mi, "__esModule", {
        value: !0
    });
    Mi.constants = Mi.SEP = void 0;
    Mi.SEP = "/";
    Mi.constants = {
        O_RDONLY: 0,
        O_WRONLY: 1,
        O_RDWR: 2,
        S_IFMT: 61440,
        S_IFREG: 32768,
        S_IFDIR: 16384,
        S_IFCHR: 8192,
        S_IFBLK: 24576,
        S_IFIFO: 4096,
        S_IFLNK: 40960,
        S_IFSOCK: 49152,
        O_CREAT: 64,
        O_EXCL: 128,
        O_NOCTTY: 256,
        O_TRUNC: 512,
        O_APPEND: 1024,
        O_DIRECTORY: 65536,
        O_NOATIME: 262144,
        O_NOFOLLOW: 131072,
        O_SYNC: 1052672,
        O_SYMLINK: 2097152,
        O_DIRECT: 16384,
        O_NONBLOCK: 2048,
        S_IRWXU: 448,
        S_IRUSR: 256,
        S_IWUSR: 128,
        S_IXUSR: 64,
        S_IRWXG: 56,
        S_IRGRP: 32,
        S_IWGRP: 16,
        S_IXGRP: 8,
        S_IRWXO: 7,
        S_IROTH: 4,
        S_IWOTH: 2,
        S_IXOTH: 1,
        F_OK: 0,
        R_OK: 4,
        W_OK: 2,
        X_OK: 1,
        UV_FS_SYMLINK_DIR: 1,
        UV_FS_SYMLINK_JUNCTION: 2,
        UV_FS_COPYFILE_EXCL: 1,
        UV_FS_COPYFILE_FICLONE: 2,
        UV_FS_COPYFILE_FICLONE_FORCE: 4,
        COPYFILE_EXCL: 1,
        COPYFILE_FICLONE: 2,
        COPYFILE_FICLONE_FORCE: 4
    };
});
var Sf = T(_c3 = (so)=>{
    "use strict";
    Object.defineProperty(so, "__esModule", {
        value: !0
    });
    so.Stats = void 0;
    var Rx = kt(), { S_IFMT: kx, S_IFDIR: Px, S_IFREG: Ax, S_IFBLK: Ix, S_IFCHR: Dx, S_IFLNK: Cx, S_IFIFO: Nx, S_IFSOCK: Bx } = Rx.constants, Us = class Us {
        static build(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            let i = new Us, { uid: n, gid: o, atime: s, mtime: l, ctime: f } = e, c = r ? (h)=>BigInt(h) : (h)=>h;
            i.uid = c(n), i.gid = c(o), i.rdev = c(e.rdev), i.blksize = c(4096), i.ino = c(e.ino), i.size = c(e.getSize()), i.blocks = c(1), i.atime = s, i.mtime = l, i.ctime = f, i.birthtime = f, i.atimeMs = c(s.getTime()), i.mtimeMs = c(l.getTime());
            let u = c(f.getTime());
            if (i.ctimeMs = u, i.birthtimeMs = u, r) {
                i.atimeNs = BigInt(s.getTime()) * BigInt(1e6), i.mtimeNs = BigInt(l.getTime()) * BigInt(1e6);
                let h = BigInt(f.getTime()) * BigInt(1e6);
                i.ctimeNs = h, i.birthtimeNs = h;
            }
            return i.dev = c(0), i.mode = c(e.mode), i.nlink = c(e.nlink), i;
        }
        _checkModeProperty(e) {
            return (Number(this.mode) & kx) === e;
        }
        isDirectory() {
            return this._checkModeProperty(Px);
        }
        isFile() {
            return this._checkModeProperty(Ax);
        }
        isBlockDevice() {
            return this._checkModeProperty(Ix);
        }
        isCharacterDevice() {
            return this._checkModeProperty(Dx);
        }
        isSymbolicLink() {
            return this._checkModeProperty(Cx);
        }
        isFIFO() {
            return this._checkModeProperty(Nx);
        }
        isSocket() {
            return this._checkModeProperty(Bx);
        }
    };
    a(Us, "Stats");
    var js = Us;
    so.Stats = js;
    so.default = js;
});
_c4 = Sf;
var Fm = T(_c5 = (qs)=>{
    "use strict";
    qs.byteLength = $x;
    qs.toByteArray = jx;
    qs.fromByteArray = Hx;
    var jt = [], ut = [], Lx = typeof Uint8Array < "u" ? Uint8Array : Array, xf = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for(ei = 0, vm = xf.length; ei < vm; ++ei)jt[ei] = xf[ei], ut[xf.charCodeAt(ei)] = ei;
    var ei, vm;
    ut[45] = 62;
    ut[95] = 63;
    function _m(t) {
        var e = t.length;
        if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var r = t.indexOf("=");
        r === -1 && (r = e);
        var i = r === e ? 0 : 4 - r % 4;
        return [
            r,
            i
        ];
    }
    a(_m, "getLens");
    function $x(t) {
        var e = _m(t), r = e[0], i = e[1];
        return (r + i) * 3 / 4 - i;
    }
    a($x, "byteLength");
    function Mx(t, e, r) {
        return (e + r) * 3 / 4 - r;
    }
    a(Mx, "_byteLength");
    function jx(t) {
        var e, r = _m(t), i = r[0], n = r[1], o = new Lx(Mx(t, i, n)), s = 0, l = n > 0 ? i - 4 : i, f;
        for(f = 0; f < l; f += 4)e = ut[t.charCodeAt(f)] << 18 | ut[t.charCodeAt(f + 1)] << 12 | ut[t.charCodeAt(f + 2)] << 6 | ut[t.charCodeAt(f + 3)], o[s++] = e >> 16 & 255, o[s++] = e >> 8 & 255, o[s++] = e & 255;
        return n === 2 && (e = ut[t.charCodeAt(f)] << 2 | ut[t.charCodeAt(f + 1)] >> 4, o[s++] = e & 255), n === 1 && (e = ut[t.charCodeAt(f)] << 10 | ut[t.charCodeAt(f + 1)] << 4 | ut[t.charCodeAt(f + 2)] >> 2, o[s++] = e >> 8 & 255, o[s++] = e & 255), o;
    }
    a(jx, "toByteArray");
    function Ux(t) {
        return jt[t >> 18 & 63] + jt[t >> 12 & 63] + jt[t >> 6 & 63] + jt[t & 63];
    }
    a(Ux, "tripletToBase64");
    function qx(t, e, r) {
        for(var i, n = [], o = e; o < r; o += 3)i = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (t[o + 2] & 255), n.push(Ux(i));
        return n.join("");
    }
    a(qx, "encodeChunk");
    function Hx(t) {
        for(var e, r = t.length, i = r % 3, n = [], o = 16383, s = 0, l = r - i; s < l; s += o)n.push(qx(t, s, s + o > l ? l : s + o));
        return i === 1 ? (e = t[r - 1], n.push(jt[e >> 2] + jt[e << 4 & 63] + "==")) : i === 2 && (e = (t[r - 2] << 8) + t[r - 1], n.push(jt[e >> 10] + jt[e >> 4 & 63] + jt[e << 2 & 63] + "=")), n.join("");
    }
    a(Hx, "fromByteArray");
});
_c6 = Fm;
var Em = T(_c7 = (Tf)=>{
    Tf.read = function(t, e, r, i, n) {
        var o, s, l = n * 8 - i - 1, f = (1 << l) - 1, c = f >> 1, u = -7, h = r ? n - 1 : 0, d = r ? -1 : 1, p = t[e + h];
        for(h += d, o = p & (1 << -u) - 1, p >>= -u, u += l; u > 0; o = o * 256 + t[e + h], h += d, u -= 8);
        for(s = o & (1 << -u) - 1, o >>= -u, u += i; u > 0; s = s * 256 + t[e + h], h += d, u -= 8);
        if (o === 0) o = 1 - c;
        else {
            if (o === f) return s ? NaN : (p ? -1 : 1) * (1 / 0);
            s = s + Math.pow(2, i), o = o - c;
        }
        return (p ? -1 : 1) * s * Math.pow(2, o - i);
    };
    Tf.write = function(t, e, r, i, n, o) {
        var s, l, f, c = o * 8 - n - 1, u = (1 << c) - 1, h = u >> 1, d = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = i ? 0 : o - 1, m = i ? 1 : -1, y = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
        for(e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (l = isNaN(e) ? 1 : 0, s = u) : (s = Math.floor(Math.log(e) / Math.LN2), e * (f = Math.pow(2, -s)) < 1 && (s--, f *= 2), s + h >= 1 ? e += d / f : e += d * Math.pow(2, 1 - h), e * f >= 2 && (s++, f /= 2), s + h >= u ? (l = 0, s = u) : s + h >= 1 ? (l = (e * f - 1) * Math.pow(2, n), s = s + h) : (l = e * Math.pow(2, h - 1) * Math.pow(2, n), s = 0)); n >= 8; t[r + p] = l & 255, p += m, l /= 256, n -= 8);
        for(s = s << n | l, c += n; c > 0; t[r + p] = s & 255, p += m, s /= 256, c -= 8);
        t[r + p - m] |= y * 128;
    };
});
_c8 = Em;
var ri = T((Hi)=>{
    "use strict";
    var Of = Fm(), Ui = Em(), Sm = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    Hi.Buffer = A;
    Hi.SlowBuffer = Zx;
    Hi.INSPECT_MAX_BYTES = 50;
    var Hs = 2147483647;
    Hi.kMaxLength = Hs;
    A.TYPED_ARRAY_SUPPORT = zx();
    !A.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function zx() {
        try {
            let t = new Uint8Array(1), e = {
                foo: a(function() {
                    return 42;
                }, "foo")
            };
            return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), t.foo() === 42;
        } catch (e) {
            return !1;
        }
    }
    a(zx, "typedArraySupport");
    Object.defineProperty(A.prototype, "parent", {
        enumerable: !0,
        get: a(function() {
            if (A.isBuffer(this)) return this.buffer;
        }, "get")
    });
    Object.defineProperty(A.prototype, "offset", {
        enumerable: !0,
        get: a(function() {
            if (A.isBuffer(this)) return this.byteOffset;
        }, "get")
    });
    function nr(t) {
        if (t > Hs) throw new RangeError('The value "' + t + '" is invalid for option "size"');
        let e = new Uint8Array(t);
        return Object.setPrototypeOf(e, A.prototype), e;
    }
    a(nr, "createBuffer");
    function A(t, e, r) {
        if (typeof t == "number") {
            if (typeof e == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return Af(t);
        }
        return Rm(t, e, r);
    }
    a(A, "Buffer");
    A.poolSize = 8192;
    function Rm(t, e, r) {
        if (typeof t == "string") return Vx(t, e);
        if (ArrayBuffer.isView(t)) return Gx(t);
        if (t == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
        if (Ut(t, ArrayBuffer) || t && Ut(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Ut(t, SharedArrayBuffer) || t && Ut(t.buffer, SharedArrayBuffer))) return kf(t, e, r);
        if (typeof t == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        let i = t.valueOf && t.valueOf();
        if (i != null && i !== t) return A.from(i, e, r);
        let n = Kx(t);
        if (n) return n;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function") return A.from(t[Symbol.toPrimitive]("string"), e, r);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    }
    a(Rm, "from");
    A.from = function(t, e, r) {
        return Rm(t, e, r);
    };
    Object.setPrototypeOf(A.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(A, Uint8Array);
    function km(t) {
        if (typeof t != "number") throw new TypeError('"size" argument must be of type number');
        if (t < 0) throw new RangeError('The value "' + t + '" is invalid for option "size"');
    }
    a(km, "assertSize");
    function Wx(t, e, r) {
        return km(t), t <= 0 ? nr(t) : e !== void 0 ? typeof r == "string" ? nr(t).fill(e, r) : nr(t).fill(e) : nr(t);
    }
    a(Wx, "alloc");
    A.alloc = function(t, e, r) {
        return Wx(t, e, r);
    };
    function Af(t) {
        return km(t), nr(t < 0 ? 0 : If(t) | 0);
    }
    a(Af, "allocUnsafe");
    A.allocUnsafe = function(t) {
        return Af(t);
    };
    A.allocUnsafeSlow = function(t) {
        return Af(t);
    };
    function Vx(t, e) {
        if ((typeof e != "string" || e === "") && (e = "utf8"), !A.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
        let r = Pm(t, e) | 0, i = nr(r), n = i.write(t, e);
        return n !== r && (i = i.slice(0, n)), i;
    }
    a(Vx, "fromString");
    function Rf(t) {
        let e = t.length < 0 ? 0 : If(t.length) | 0, r = nr(e);
        for(let i = 0; i < e; i += 1)r[i] = t[i] & 255;
        return r;
    }
    a(Rf, "fromArrayLike");
    function Gx(t) {
        if (Ut(t, Uint8Array)) {
            let e = new Uint8Array(t);
            return kf(e.buffer, e.byteOffset, e.byteLength);
        }
        return Rf(t);
    }
    a(Gx, "fromArrayView");
    function kf(t, e, r) {
        if (e < 0 || t.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
        if (t.byteLength < e + (r || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let i;
        return e === void 0 && r === void 0 ? i = new Uint8Array(t) : r === void 0 ? i = new Uint8Array(t, e) : i = new Uint8Array(t, e, r), Object.setPrototypeOf(i, A.prototype), i;
    }
    a(kf, "fromArrayBuffer");
    function Kx(t) {
        if (A.isBuffer(t)) {
            let e = If(t.length) | 0, r = nr(e);
            return r.length === 0 || t.copy(r, 0, 0, e), r;
        }
        if (t.length !== void 0) return typeof t.length != "number" || Cf(t.length) ? nr(0) : Rf(t);
        if (t.type === "Buffer" && Array.isArray(t.data)) return Rf(t.data);
    }
    a(Kx, "fromObject");
    function If(t) {
        if (t >= Hs) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Hs.toString(16) + " bytes");
        return t | 0;
    }
    a(If, "checked");
    function Zx(t) {
        return +t != t && (t = 0), A.alloc(+t);
    }
    a(Zx, "SlowBuffer");
    A.isBuffer = a(function(e) {
        return e != null && e._isBuffer === !0 && e !== A.prototype;
    }, "isBuffer");
    A.compare = a(function(e, r) {
        if (Ut(e, Uint8Array) && (e = A.from(e, e.offset, e.byteLength)), Ut(r, Uint8Array) && (r = A.from(r, r.offset, r.byteLength)), !A.isBuffer(e) || !A.isBuffer(r)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (e === r) return 0;
        let i = e.length, n = r.length;
        for(let o = 0, s = Math.min(i, n); o < s; ++o)if (e[o] !== r[o]) {
            i = e[o], n = r[o];
            break;
        }
        return i < n ? -1 : n < i ? 1 : 0;
    }, "compare");
    A.isEncoding = a(function(e) {
        switch(String(e).toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1;
        }
    }, "isEncoding");
    A.concat = a(function(e, r) {
        if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (e.length === 0) return A.alloc(0);
        let i;
        if (r === void 0) for(r = 0, i = 0; i < e.length; ++i)r += e[i].length;
        let n = A.allocUnsafe(r), o = 0;
        for(i = 0; i < e.length; ++i){
            let s = e[i];
            if (Ut(s, Uint8Array)) o + s.length > n.length ? (A.isBuffer(s) || (s = A.from(s)), s.copy(n, o)) : Uint8Array.prototype.set.call(n, s, o);
            else if (A.isBuffer(s)) s.copy(n, o);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            o += s.length;
        }
        return n;
    }, "concat");
    function Pm(t, e) {
        if (A.isBuffer(t)) return t.length;
        if (ArrayBuffer.isView(t) || Ut(t, ArrayBuffer)) return t.byteLength;
        if (typeof t != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
        let r = t.length, i = arguments.length > 2 && arguments[2] === !0;
        if (!i && r === 0) return 0;
        let n = !1;
        for(;;)switch(e){
            case "ascii":
            case "latin1":
            case "binary":
                return r;
            case "utf8":
            case "utf-8":
                return Pf(t).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return r * 2;
            case "hex":
                return r >>> 1;
            case "base64":
                return Mm(t).length;
            default:
                if (n) return i ? -1 : Pf(t).length;
                e = ("" + e).toLowerCase(), n = !0;
        }
    }
    a(Pm, "byteLength");
    A.byteLength = Pm;
    function Xx(t, e, r) {
        let i = !1;
        if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((r === void 0 || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e >>>= 0, r <= e)) return "";
        for(t || (t = "utf8");;)switch(t){
            case "hex":
                return sT(this, e, r);
            case "utf8":
            case "utf-8":
                return Im(this, e, r);
            case "ascii":
                return nT(this, e, r);
            case "latin1":
            case "binary":
                return oT(this, e, r);
            case "base64":
                return rT(this, e, r);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return aT(this, e, r);
            default:
                if (i) throw new TypeError("Unknown encoding: " + t);
                t = (t + "").toLowerCase(), i = !0;
        }
    }
    a(Xx, "slowToString");
    A.prototype._isBuffer = !0;
    function ti(t, e, r) {
        let i = t[e];
        t[e] = t[r], t[r] = i;
    }
    a(ti, "swap");
    A.prototype.swap16 = a(function() {
        let e = this.length;
        if (e % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for(let r = 0; r < e; r += 2)ti(this, r, r + 1);
        return this;
    }, "swap16");
    A.prototype.swap32 = a(function() {
        let e = this.length;
        if (e % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for(let r = 0; r < e; r += 4)ti(this, r, r + 3), ti(this, r + 1, r + 2);
        return this;
    }, "swap32");
    A.prototype.swap64 = a(function() {
        let e = this.length;
        if (e % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for(let r = 0; r < e; r += 8)ti(this, r, r + 7), ti(this, r + 1, r + 6), ti(this, r + 2, r + 5), ti(this, r + 3, r + 4);
        return this;
    }, "swap64");
    A.prototype.toString = a(function() {
        let e = this.length;
        return e === 0 ? "" : arguments.length === 0 ? Im(this, 0, e) : Xx.apply(this, arguments);
    }, "toString");
    A.prototype.toLocaleString = A.prototype.toString;
    A.prototype.equals = a(function(e) {
        if (!A.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
        return this === e ? !0 : A.compare(this, e) === 0;
    }, "equals");
    A.prototype.inspect = a(function() {
        let e = "", r = Hi.INSPECT_MAX_BYTES;
        return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (e += " ... "), "<Buffer " + e + ">";
    }, "inspect");
    Sm && (A.prototype[Sm] = A.prototype.inspect);
    A.prototype.compare = a(function(e, r, i, n, o) {
        if (Ut(e, Uint8Array) && (e = A.from(e, e.offset, e.byteLength)), !A.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
        if (r === void 0 && (r = 0), i === void 0 && (i = e ? e.length : 0), n === void 0 && (n = 0), o === void 0 && (o = this.length), r < 0 || i > e.length || n < 0 || o > this.length) throw new RangeError("out of range index");
        if (n >= o && r >= i) return 0;
        if (n >= o) return -1;
        if (r >= i) return 1;
        if (r >>>= 0, i >>>= 0, n >>>= 0, o >>>= 0, this === e) return 0;
        let s = o - n, l = i - r, f = Math.min(s, l), c = this.slice(n, o), u = e.slice(r, i);
        for(let h = 0; h < f; ++h)if (c[h] !== u[h]) {
            s = c[h], l = u[h];
            break;
        }
        return s < l ? -1 : l < s ? 1 : 0;
    }, "compare");
    function Am(t, e, r, i, n) {
        if (t.length === 0) return -1;
        if (typeof r == "string" ? (i = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, Cf(r) && (r = n ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
            if (n) return -1;
            r = t.length - 1;
        } else if (r < 0) if (n) r = 0;
        else return -1;
        if (typeof e == "string" && (e = A.from(e, i)), A.isBuffer(e)) return e.length === 0 ? -1 : xm(t, e, r, i, n);
        if (typeof e == "number") return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : xm(t, [
            e
        ], r, i, n);
        throw new TypeError("val must be string, number or Buffer");
    }
    a(Am, "bidirectionalIndexOf");
    function xm(t, e, r, i, n) {
        let o = 1, s = t.length, l = e.length;
        if (i !== void 0 && (i = String(i).toLowerCase(), i === "ucs2" || i === "ucs-2" || i === "utf16le" || i === "utf-16le")) {
            if (t.length < 2 || e.length < 2) return -1;
            o = 2, s /= 2, l /= 2, r /= 2;
        }
        function f(u, h) {
            return o === 1 ? u[h] : u.readUInt16BE(h * o);
        }
        a(f, "read");
        let c;
        if (n) {
            let u = -1;
            for(c = r; c < s; c++)if (f(t, c) === f(e, u === -1 ? 0 : c - u)) {
                if (u === -1 && (u = c), c - u + 1 === l) return u * o;
            } else u !== -1 && (c -= c - u), u = -1;
        } else for(r + l > s && (r = s - l), c = r; c >= 0; c--){
            let u = !0;
            for(let h = 0; h < l; h++)if (f(t, c + h) !== f(e, h)) {
                u = !1;
                break;
            }
            if (u) return c;
        }
        return -1;
    }
    a(xm, "arrayIndexOf");
    A.prototype.includes = a(function(e, r, i) {
        return this.indexOf(e, r, i) !== -1;
    }, "includes");
    A.prototype.indexOf = a(function(e, r, i) {
        return Am(this, e, r, i, !0);
    }, "indexOf");
    A.prototype.lastIndexOf = a(function(e, r, i) {
        return Am(this, e, r, i, !1);
    }, "lastIndexOf");
    function Yx(t, e, r, i) {
        r = Number(r) || 0;
        let n = t.length - r;
        i ? (i = Number(i), i > n && (i = n)) : i = n;
        let o = e.length;
        i > o / 2 && (i = o / 2);
        let s;
        for(s = 0; s < i; ++s){
            let l = parseInt(e.substr(s * 2, 2), 16);
            if (Cf(l)) return s;
            t[r + s] = l;
        }
        return s;
    }
    a(Yx, "hexWrite");
    function Jx(t, e, r, i) {
        return zs(Pf(e, t.length - r), t, r, i);
    }
    a(Jx, "utf8Write");
    function Qx(t, e, r, i) {
        return zs(uT(e), t, r, i);
    }
    a(Qx, "asciiWrite");
    function eT(t, e, r, i) {
        return zs(Mm(e), t, r, i);
    }
    a(eT, "base64Write");
    function tT(t, e, r, i) {
        return zs(hT(e, t.length - r), t, r, i);
    }
    a(tT, "ucs2Write");
    A.prototype.write = a(function(e, r, i, n) {
        if (r === void 0) n = "utf8", i = this.length, r = 0;
        else if (i === void 0 && typeof r == "string") n = r, i = this.length, r = 0;
        else if (isFinite(r)) r = r >>> 0, isFinite(i) ? (i = i >>> 0, n === void 0 && (n = "utf8")) : (n = i, i = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        let o = this.length - r;
        if ((i === void 0 || i > o) && (i = o), e.length > 0 && (i < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        n || (n = "utf8");
        let s = !1;
        for(;;)switch(n){
            case "hex":
                return Yx(this, e, r, i);
            case "utf8":
            case "utf-8":
                return Jx(this, e, r, i);
            case "ascii":
            case "latin1":
            case "binary":
                return Qx(this, e, r, i);
            case "base64":
                return eT(this, e, r, i);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return tT(this, e, r, i);
            default:
                if (s) throw new TypeError("Unknown encoding: " + n);
                n = ("" + n).toLowerCase(), s = !0;
        }
    }, "write");
    A.prototype.toJSON = a(function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    }, "toJSON");
    function rT(t, e, r) {
        return e === 0 && r === t.length ? Of.fromByteArray(t) : Of.fromByteArray(t.slice(e, r));
    }
    a(rT, "base64Slice");
    function Im(t, e, r) {
        r = Math.min(t.length, r);
        let i = [], n = e;
        for(; n < r;){
            let o = t[n], s = null, l = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
            if (n + l <= r) {
                let f, c, u, h;
                switch(l){
                    case 1:
                        o < 128 && (s = o);
                        break;
                    case 2:
                        f = t[n + 1], (f & 192) === 128 && (h = (o & 31) << 6 | f & 63, h > 127 && (s = h));
                        break;
                    case 3:
                        f = t[n + 1], c = t[n + 2], (f & 192) === 128 && (c & 192) === 128 && (h = (o & 15) << 12 | (f & 63) << 6 | c & 63, h > 2047 && (h < 55296 || h > 57343) && (s = h));
                        break;
                    case 4:
                        f = t[n + 1], c = t[n + 2], u = t[n + 3], (f & 192) === 128 && (c & 192) === 128 && (u & 192) === 128 && (h = (o & 15) << 18 | (f & 63) << 12 | (c & 63) << 6 | u & 63, h > 65535 && h < 1114112 && (s = h));
                }
            }
            s === null ? (s = 65533, l = 1) : s > 65535 && (s -= 65536, i.push(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), i.push(s), n += l;
        }
        return iT(i);
    }
    a(Im, "utf8Slice");
    var Tm = 4096;
    function iT(t) {
        let e = t.length;
        if (e <= Tm) return String.fromCharCode.apply(String, t);
        let r = "", i = 0;
        for(; i < e;)r += String.fromCharCode.apply(String, t.slice(i, i += Tm));
        return r;
    }
    a(iT, "decodeCodePointsArray");
    function nT(t, e, r) {
        let i = "";
        r = Math.min(t.length, r);
        for(let n = e; n < r; ++n)i += String.fromCharCode(t[n] & 127);
        return i;
    }
    a(nT, "asciiSlice");
    function oT(t, e, r) {
        let i = "";
        r = Math.min(t.length, r);
        for(let n = e; n < r; ++n)i += String.fromCharCode(t[n]);
        return i;
    }
    a(oT, "latin1Slice");
    function sT(t, e, r) {
        let i = t.length;
        (!e || e < 0) && (e = 0), (!r || r < 0 || r > i) && (r = i);
        let n = "";
        for(let o = e; o < r; ++o)n += dT[t[o]];
        return n;
    }
    a(sT, "hexSlice");
    function aT(t, e, r) {
        let i = t.slice(e, r), n = "";
        for(let o = 0; o < i.length - 1; o += 2)n += String.fromCharCode(i[o] + i[o + 1] * 256);
        return n;
    }
    a(aT, "utf16leSlice");
    A.prototype.slice = a(function(e, r) {
        let i = this.length;
        e = ~~e, r = r === void 0 ? i : ~~r, e < 0 ? (e += i, e < 0 && (e = 0)) : e > i && (e = i), r < 0 ? (r += i, r < 0 && (r = 0)) : r > i && (r = i), r < e && (r = e);
        let n = this.subarray(e, r);
        return Object.setPrototypeOf(n, A.prototype), n;
    }, "slice");
    function Ie(t, e, r) {
        if (t % 1 !== 0 || t < 0) throw new RangeError("offset is not uint");
        if (t + e > r) throw new RangeError("Trying to access beyond buffer length");
    }
    a(Ie, "checkOffset");
    A.prototype.readUintLE = A.prototype.readUIntLE = a(function(e, r, i) {
        e = e >>> 0, r = r >>> 0, i || Ie(e, r, this.length);
        let n = this[e], o = 1, s = 0;
        for(; ++s < r && (o *= 256);)n += this[e + s] * o;
        return n;
    }, "readUIntLE");
    A.prototype.readUintBE = A.prototype.readUIntBE = a(function(e, r, i) {
        e = e >>> 0, r = r >>> 0, i || Ie(e, r, this.length);
        let n = this[e + --r], o = 1;
        for(; r > 0 && (o *= 256);)n += this[e + --r] * o;
        return n;
    }, "readUIntBE");
    A.prototype.readUint8 = A.prototype.readUInt8 = a(function(e, r) {
        return e = e >>> 0, r || Ie(e, 1, this.length), this[e];
    }, "readUInt8");
    A.prototype.readUint16LE = A.prototype.readUInt16LE = a(function(e, r) {
        return e = e >>> 0, r || Ie(e, 2, this.length), this[e] | this[e + 1] << 8;
    }, "readUInt16LE");
    A.prototype.readUint16BE = A.prototype.readUInt16BE = a(function(e, r) {
        return e = e >>> 0, r || Ie(e, 2, this.length), this[e] << 8 | this[e + 1];
    }, "readUInt16BE");
    A.prototype.readUint32LE = A.prototype.readUInt32LE = a(function(e, r) {
        return e = e >>> 0, r || Ie(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
    }, "readUInt32LE");
    A.prototype.readUint32BE = A.prototype.readUInt32BE = a(function(e, r) {
        return e = e >>> 0, r || Ie(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
    }, "readUInt32BE");
    A.prototype.readBigUInt64LE = Sr(a(function(e) {
        e = e >>> 0, qi(e, "offset");
        let r = this[e], i = this[e + 7];
        (r === void 0 || i === void 0) && ao(e, this.length - 8);
        let n = r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, o = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + i * 2 ** 24;
        return BigInt(n) + (BigInt(o) << BigInt(32));
    }, "readBigUInt64LE"));
    A.prototype.readBigUInt64BE = Sr(a(function(e) {
        e = e >>> 0, qi(e, "offset");
        let r = this[e], i = this[e + 7];
        (r === void 0 || i === void 0) && ao(e, this.length - 8);
        let n = r * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], o = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + i;
        return (BigInt(n) << BigInt(32)) + BigInt(o);
    }, "readBigUInt64BE"));
    A.prototype.readIntLE = a(function(e, r, i) {
        e = e >>> 0, r = r >>> 0, i || Ie(e, r, this.length);
        let n = this[e], o = 1, s = 0;
        for(; ++s < r && (o *= 256);)n += this[e + s] * o;
        return o *= 128, n >= o && (n -= Math.pow(2, 8 * r)), n;
    }, "readIntLE");
    A.prototype.readIntBE = a(function(e, r, i) {
        e = e >>> 0, r = r >>> 0, i || Ie(e, r, this.length);
        let n = r, o = 1, s = this[e + --n];
        for(; n > 0 && (o *= 256);)s += this[e + --n] * o;
        return o *= 128, s >= o && (s -= Math.pow(2, 8 * r)), s;
    }, "readIntBE");
    A.prototype.readInt8 = a(function(e, r) {
        return e = e >>> 0, r || Ie(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
    }, "readInt8");
    A.prototype.readInt16LE = a(function(e, r) {
        e = e >>> 0, r || Ie(e, 2, this.length);
        let i = this[e] | this[e + 1] << 8;
        return i & 32768 ? i | 4294901760 : i;
    }, "readInt16LE");
    A.prototype.readInt16BE = a(function(e, r) {
        e = e >>> 0, r || Ie(e, 2, this.length);
        let i = this[e + 1] | this[e] << 8;
        return i & 32768 ? i | 4294901760 : i;
    }, "readInt16BE");
    A.prototype.readInt32LE = a(function(e, r) {
        return e = e >>> 0, r || Ie(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
    }, "readInt32LE");
    A.prototype.readInt32BE = a(function(e, r) {
        return e = e >>> 0, r || Ie(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
    }, "readInt32BE");
    A.prototype.readBigInt64LE = Sr(a(function(e) {
        e = e >>> 0, qi(e, "offset");
        let r = this[e], i = this[e + 7];
        (r === void 0 || i === void 0) && ao(e, this.length - 8);
        let n = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (i << 24);
        return (BigInt(n) << BigInt(32)) + BigInt(r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
    }, "readBigInt64LE"));
    A.prototype.readBigInt64BE = Sr(a(function(e) {
        e = e >>> 0, qi(e, "offset");
        let r = this[e], i = this[e + 7];
        (r === void 0 || i === void 0) && ao(e, this.length - 8);
        let n = (r << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
        return (BigInt(n) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + i);
    }, "readBigInt64BE"));
    A.prototype.readFloatLE = a(function(e, r) {
        return e = e >>> 0, r || Ie(e, 4, this.length), Ui.read(this, e, !0, 23, 4);
    }, "readFloatLE");
    A.prototype.readFloatBE = a(function(e, r) {
        return e = e >>> 0, r || Ie(e, 4, this.length), Ui.read(this, e, !1, 23, 4);
    }, "readFloatBE");
    A.prototype.readDoubleLE = a(function(e, r) {
        return e = e >>> 0, r || Ie(e, 8, this.length), Ui.read(this, e, !0, 52, 8);
    }, "readDoubleLE");
    A.prototype.readDoubleBE = a(function(e, r) {
        return e = e >>> 0, r || Ie(e, 8, this.length), Ui.read(this, e, !1, 52, 8);
    }, "readDoubleBE");
    function Xe(t, e, r, i, n, o) {
        if (!A.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (e > n || e < o) throw new RangeError('"value" argument is out of bounds');
        if (r + i > t.length) throw new RangeError("Index out of range");
    }
    a(Xe, "checkInt");
    A.prototype.writeUintLE = A.prototype.writeUIntLE = a(function(e, r, i, n) {
        if (e = +e, r = r >>> 0, i = i >>> 0, !n) {
            let l = Math.pow(2, 8 * i) - 1;
            Xe(this, e, r, i, l, 0);
        }
        let o = 1, s = 0;
        for(this[r] = e & 255; ++s < i && (o *= 256);)this[r + s] = e / o & 255;
        return r + i;
    }, "writeUIntLE");
    A.prototype.writeUintBE = A.prototype.writeUIntBE = a(function(e, r, i, n) {
        if (e = +e, r = r >>> 0, i = i >>> 0, !n) {
            let l = Math.pow(2, 8 * i) - 1;
            Xe(this, e, r, i, l, 0);
        }
        let o = i - 1, s = 1;
        for(this[r + o] = e & 255; --o >= 0 && (s *= 256);)this[r + o] = e / s & 255;
        return r + i;
    }, "writeUIntBE");
    A.prototype.writeUint8 = A.prototype.writeUInt8 = a(function(e, r, i) {
        return e = +e, r = r >>> 0, i || Xe(this, e, r, 1, 255, 0), this[r] = e & 255, r + 1;
    }, "writeUInt8");
    A.prototype.writeUint16LE = A.prototype.writeUInt16LE = a(function(e, r, i) {
        return e = +e, r = r >>> 0, i || Xe(this, e, r, 2, 65535, 0), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    }, "writeUInt16LE");
    A.prototype.writeUint16BE = A.prototype.writeUInt16BE = a(function(e, r, i) {
        return e = +e, r = r >>> 0, i || Xe(this, e, r, 2, 65535, 0), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    }, "writeUInt16BE");
    A.prototype.writeUint32LE = A.prototype.writeUInt32LE = a(function(e, r, i) {
        return e = +e, r = r >>> 0, i || Xe(this, e, r, 4, 4294967295, 0), this[r + 3] = e >>> 24, this[r + 2] = e >>> 16, this[r + 1] = e >>> 8, this[r] = e & 255, r + 4;
    }, "writeUInt32LE");
    A.prototype.writeUint32BE = A.prototype.writeUInt32BE = a(function(e, r, i) {
        return e = +e, r = r >>> 0, i || Xe(this, e, r, 4, 4294967295, 0), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    }, "writeUInt32BE");
    function Dm(t, e, r, i, n) {
        $m(e, i, n, t, r, 7);
        let o = Number(e & BigInt(4294967295));
        t[r++] = o, o = o >> 8, t[r++] = o, o = o >> 8, t[r++] = o, o = o >> 8, t[r++] = o;
        let s = Number(e >> BigInt(32) & BigInt(4294967295));
        return t[r++] = s, s = s >> 8, t[r++] = s, s = s >> 8, t[r++] = s, s = s >> 8, t[r++] = s, r;
    }
    a(Dm, "wrtBigUInt64LE");
    function Cm(t, e, r, i, n) {
        $m(e, i, n, t, r, 7);
        let o = Number(e & BigInt(4294967295));
        t[r + 7] = o, o = o >> 8, t[r + 6] = o, o = o >> 8, t[r + 5] = o, o = o >> 8, t[r + 4] = o;
        let s = Number(e >> BigInt(32) & BigInt(4294967295));
        return t[r + 3] = s, s = s >> 8, t[r + 2] = s, s = s >> 8, t[r + 1] = s, s = s >> 8, t[r] = s, r + 8;
    }
    a(Cm, "wrtBigUInt64BE");
    A.prototype.writeBigUInt64LE = Sr(a(function(e) {
        let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return Dm(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "writeBigUInt64LE"));
    A.prototype.writeBigUInt64BE = Sr(a(function(e) {
        let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return Cm(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "writeBigUInt64BE"));
    A.prototype.writeIntLE = a(function(e, r, i, n) {
        if (e = +e, r = r >>> 0, !n) {
            let f = Math.pow(2, 8 * i - 1);
            Xe(this, e, r, i, f - 1, -f);
        }
        let o = 0, s = 1, l = 0;
        for(this[r] = e & 255; ++o < i && (s *= 256);)e < 0 && l === 0 && this[r + o - 1] !== 0 && (l = 1), this[r + o] = (e / s >> 0) - l & 255;
        return r + i;
    }, "writeIntLE");
    A.prototype.writeIntBE = a(function(e, r, i, n) {
        if (e = +e, r = r >>> 0, !n) {
            let f = Math.pow(2, 8 * i - 1);
            Xe(this, e, r, i, f - 1, -f);
        }
        let o = i - 1, s = 1, l = 0;
        for(this[r + o] = e & 255; --o >= 0 && (s *= 256);)e < 0 && l === 0 && this[r + o + 1] !== 0 && (l = 1), this[r + o] = (e / s >> 0) - l & 255;
        return r + i;
    }, "writeIntBE");
    A.prototype.writeInt8 = a(function(e, r, i) {
        return e = +e, r = r >>> 0, i || Xe(this, e, r, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[r] = e & 255, r + 1;
    }, "writeInt8");
    A.prototype.writeInt16LE = a(function(e, r, i) {
        return e = +e, r = r >>> 0, i || Xe(this, e, r, 2, 32767, -32768), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    }, "writeInt16LE");
    A.prototype.writeInt16BE = a(function(e, r, i) {
        return e = +e, r = r >>> 0, i || Xe(this, e, r, 2, 32767, -32768), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    }, "writeInt16BE");
    A.prototype.writeInt32LE = a(function(e, r, i) {
        return e = +e, r = r >>> 0, i || Xe(this, e, r, 4, 2147483647, -2147483648), this[r] = e & 255, this[r + 1] = e >>> 8, this[r + 2] = e >>> 16, this[r + 3] = e >>> 24, r + 4;
    }, "writeInt32LE");
    A.prototype.writeInt32BE = a(function(e, r, i) {
        return e = +e, r = r >>> 0, i || Xe(this, e, r, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    }, "writeInt32BE");
    A.prototype.writeBigInt64LE = Sr(a(function(e) {
        let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return Dm(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64LE"));
    A.prototype.writeBigInt64BE = Sr(a(function(e) {
        let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return Cm(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64BE"));
    function Nm(t, e, r, i, n, o) {
        if (r + i > t.length) throw new RangeError("Index out of range");
        if (r < 0) throw new RangeError("Index out of range");
    }
    a(Nm, "checkIEEE754");
    function Bm(t, e, r, i, n) {
        return e = +e, r = r >>> 0, n || Nm(t, e, r, 4, 34028234663852886e22, -34028234663852886e22), Ui.write(t, e, r, i, 23, 4), r + 4;
    }
    a(Bm, "writeFloat");
    A.prototype.writeFloatLE = a(function(e, r, i) {
        return Bm(this, e, r, !0, i);
    }, "writeFloatLE");
    A.prototype.writeFloatBE = a(function(e, r, i) {
        return Bm(this, e, r, !1, i);
    }, "writeFloatBE");
    function Lm(t, e, r, i, n) {
        return e = +e, r = r >>> 0, n || Nm(t, e, r, 8, 17976931348623157e292, -17976931348623157e292), Ui.write(t, e, r, i, 52, 8), r + 8;
    }
    a(Lm, "writeDouble");
    A.prototype.writeDoubleLE = a(function(e, r, i) {
        return Lm(this, e, r, !0, i);
    }, "writeDoubleLE");
    A.prototype.writeDoubleBE = a(function(e, r, i) {
        return Lm(this, e, r, !1, i);
    }, "writeDoubleBE");
    A.prototype.copy = a(function(e, r, i, n) {
        if (!A.isBuffer(e)) throw new TypeError("argument should be a Buffer");
        if (i || (i = 0), !n && n !== 0 && (n = this.length), r >= e.length && (r = e.length), r || (r = 0), n > 0 && n < i && (n = i), n === i || e.length === 0 || this.length === 0) return 0;
        if (r < 0) throw new RangeError("targetStart out of bounds");
        if (i < 0 || i >= this.length) throw new RangeError("Index out of range");
        if (n < 0) throw new RangeError("sourceEnd out of bounds");
        n > this.length && (n = this.length), e.length - r < n - i && (n = e.length - r + i);
        let o = n - i;
        return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, i, n) : Uint8Array.prototype.set.call(e, this.subarray(i, n), r), o;
    }, "copy");
    A.prototype.fill = a(function(e, r, i, n) {
        if (typeof e == "string") {
            if (typeof r == "string" ? (n = r, r = 0, i = this.length) : typeof i == "string" && (n = i, i = this.length), n !== void 0 && typeof n != "string") throw new TypeError("encoding must be a string");
            if (typeof n == "string" && !A.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
            if (e.length === 1) {
                let s = e.charCodeAt(0);
                (n === "utf8" && s < 128 || n === "latin1") && (e = s);
            }
        } else typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
        if (r < 0 || this.length < r || this.length < i) throw new RangeError("Out of range index");
        if (i <= r) return this;
        r = r >>> 0, i = i === void 0 ? this.length : i >>> 0, e || (e = 0);
        let o;
        if (typeof e == "number") for(o = r; o < i; ++o)this[o] = e;
        else {
            let s = A.isBuffer(e) ? e : A.from(e, n), l = s.length;
            if (l === 0) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
            for(o = 0; o < i - r; ++o)this[o + r] = s[o % l];
        }
        return this;
    }, "fill");
    var ji = {};
    function Df(t, e, r) {
        var i;
        ji[t] = (i = class extends r {
            get code() {
                return t;
            }
            set code(o) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: o,
                    writable: !0
                });
            }
            toString() {
                return "".concat(this.name, " [").concat(t, "]: ").concat(this.message);
            }
            constructor(){
                super(), Object.defineProperty(this, "message", {
                    value: e.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = "".concat(this.name, " [").concat(t, "]"), this.stack, delete this.name;
            }
        }, a(i, "NodeError"), i);
    }
    a(Df, "E");
    Df("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
        return t ? "".concat(t, " is outside of buffer bounds") : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    Df("ERR_INVALID_ARG_TYPE", function(t, e) {
        return 'The "'.concat(t, '" argument must be of type number. Received type ').concat(typeof e);
    }, TypeError);
    Df("ERR_OUT_OF_RANGE", function(t, e, r) {
        let i = 'The value of "'.concat(t, '" is out of range.'), n = r;
        return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = Om(String(r)) : typeof r == "bigint" && (n = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (n = Om(n)), n += "n"), i += " It must be ".concat(e, ". Received ").concat(n), i;
    }, RangeError);
    function Om(t) {
        let e = "", r = t.length, i = t[0] === "-" ? 1 : 0;
        for(; r >= i + 4; r -= 3)e = "_".concat(t.slice(r - 3, r)).concat(e);
        return "".concat(t.slice(0, r)).concat(e);
    }
    a(Om, "addNumericalSeparator");
    function lT(t, e, r) {
        qi(e, "offset"), (t[e] === void 0 || t[e + r] === void 0) && ao(e, t.length - (r + 1));
    }
    a(lT, "checkBounds");
    function $m(t, e, r, i, n, o) {
        if (t > r || t < e) {
            let s = typeof e == "bigint" ? "n" : "", l;
            throw o > 3 ? e === 0 || e === BigInt(0) ? l = ">= 0".concat(s, " and < 2").concat(s, " ** ").concat((o + 1) * 8).concat(s) : l = ">= -(2".concat(s, " ** ").concat((o + 1) * 8 - 1).concat(s, ") and < 2 ** ").concat((o + 1) * 8 - 1).concat(s) : l = ">= ".concat(e).concat(s, " and <= ").concat(r).concat(s), new ji.ERR_OUT_OF_RANGE("value", l, t);
        }
        lT(i, n, o);
    }
    a($m, "checkIntBI");
    function qi(t, e) {
        if (typeof t != "number") throw new ji.ERR_INVALID_ARG_TYPE(e, "number", t);
    }
    a(qi, "validateNumber");
    function ao(t, e, r) {
        throw Math.floor(t) !== t ? (qi(t, r), new ji.ERR_OUT_OF_RANGE(r || "offset", "an integer", t)) : e < 0 ? new ji.ERR_BUFFER_OUT_OF_BOUNDS : new ji.ERR_OUT_OF_RANGE(r || "offset", ">= ".concat(r ? 1 : 0, " and <= ").concat(e), t);
    }
    a(ao, "boundsError");
    var cT = /[^+/0-9A-Za-z-_]/g;
    function fT(t) {
        if (t = t.split("=")[0], t = t.trim().replace(cT, ""), t.length < 2) return "";
        for(; t.length % 4 !== 0;)t = t + "=";
        return t;
    }
    a(fT, "base64clean");
    function Pf(t, e) {
        e = e || 1 / 0;
        let r, i = t.length, n = null, o = [];
        for(let s = 0; s < i; ++s){
            if (r = t.charCodeAt(s), r > 55295 && r < 57344) {
                if (!n) {
                    if (r > 56319) {
                        (e -= 3) > -1 && o.push(239, 191, 189);
                        continue;
                    } else if (s + 1 === i) {
                        (e -= 3) > -1 && o.push(239, 191, 189);
                        continue;
                    }
                    n = r;
                    continue;
                }
                if (r < 56320) {
                    (e -= 3) > -1 && o.push(239, 191, 189), n = r;
                    continue;
                }
                r = (n - 55296 << 10 | r - 56320) + 65536;
            } else n && (e -= 3) > -1 && o.push(239, 191, 189);
            if (n = null, r < 128) {
                if ((e -= 1) < 0) break;
                o.push(r);
            } else if (r < 2048) {
                if ((e -= 2) < 0) break;
                o.push(r >> 6 | 192, r & 63 | 128);
            } else if (r < 65536) {
                if ((e -= 3) < 0) break;
                o.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
            } else if (r < 1114112) {
                if ((e -= 4) < 0) break;
                o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
            } else throw new Error("Invalid code point");
        }
        return o;
    }
    a(Pf, "utf8ToBytes");
    function uT(t) {
        let e = [];
        for(let r = 0; r < t.length; ++r)e.push(t.charCodeAt(r) & 255);
        return e;
    }
    a(uT, "asciiToBytes");
    function hT(t, e) {
        let r, i, n, o = [];
        for(let s = 0; s < t.length && !((e -= 2) < 0); ++s)r = t.charCodeAt(s), i = r >> 8, n = r % 256, o.push(n), o.push(i);
        return o;
    }
    a(hT, "utf16leToBytes");
    function Mm(t) {
        return Of.toByteArray(fT(t));
    }
    a(Mm, "base64ToBytes");
    function zs(t, e, r, i) {
        let n;
        for(n = 0; n < i && !(n + r >= e.length || n >= t.length); ++n)e[n + r] = t[n];
        return n;
    }
    a(zs, "blitBuffer");
    function Ut(t, e) {
        return t instanceof e || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e.name;
    }
    a(Ut, "isInstance");
    function Cf(t) {
        return t !== t;
    }
    a(Cf, "numberIsNaN");
    var dT = function() {
        let t = "0123456789abcdef", e = new Array(256);
        for(let r = 0; r < 16; ++r){
            let i = r * 16;
            for(let n = 0; n < 16; ++n)e[i + n] = t[r] + t[n];
        }
        return e;
    }();
    function Sr(t) {
        return typeof BigInt > "u" ? pT : t;
    }
    a(Sr, "defineBigIntMethod");
    function pT() {
        throw new Error("BigInt not supported");
    }
    a(pT, "BufferBigIntNotDefined");
});
var jm = T((Ws)=>{
    "use strict";
    Object.defineProperty(Ws, "__esModule", {
        value: !0
    });
    Ws.Buffer = void 0;
    var mT = ri();
    Object.defineProperty(Ws, "Buffer", {
        enumerable: !0,
        get: a(function() {
            return mT.Buffer;
        }, "get")
    });
});
var Tr = T(_c9 = (xr)=>{
    "use strict";
    Object.defineProperty(xr, "__esModule", {
        value: !0
    });
    xr.bufferFrom = xr.bufferAllocUnsafe = xr.Buffer = void 0;
    var Vs = jm();
    Object.defineProperty(xr, "Buffer", {
        enumerable: !0,
        get: a(function() {
            return Vs.Buffer;
        }, "get")
    });
    function Um(t) {
        for(var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            e[_key - 1] = arguments[_key];
        }
        return new Vs.Buffer(t, ...e);
    }
    a(Um, "bufferV0P12Ponyfill");
    var yT = Vs.Buffer.allocUnsafe || Um;
    xr.bufferAllocUnsafe = yT;
    var wT = Vs.Buffer.from || Um;
    xr.bufferFrom = wT;
});
_c10 = Tr;
var Bf = T(_c11 = (zi)=>{
    "use strict";
    Object.defineProperty(zi, "__esModule", {
        value: !0
    });
    zi.inherits = gT;
    zi.promisify = bT;
    zi.inspect = Nf;
    zi.format = vT;
    function gT(t, e) {
        if (t == null) throw new TypeError("The constructor to inherit from is not defined");
        if (e == null) throw new TypeError("The super constructor to inherit from is not defined");
        t.super_ = e, t.prototype = Object.create(e.prototype, {
            constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        });
    }
    a(gT, "inherits");
    function bT(t) {
        if (typeof t != "function") throw new TypeError('The "original" argument must be of type function');
        return function() {
            for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){
                e[_key] = arguments[_key];
            }
            return new Promise((r, i)=>{
                t.call(this, ...e, (n, o)=>{
                    n ? i(n) : r(o);
                });
            });
        };
    }
    a(bT, "promisify");
    function Nf(t) {
        return t === null ? "null" : t === void 0 ? "undefined" : typeof t == "string" ? "'".concat(t, "'") : typeof t == "number" || typeof t == "boolean" ? String(t) : Array.isArray(t) ? "[ ".concat(t.map((r)=>Nf(r)).join(", "), " ]") : typeof t == "object" ? "{ ".concat(Object.entries(t).map((param)=>{
            let [r, i] = param;
            return "".concat(r, ": ").concat(Nf(i));
        }).join(", "), " }") : String(t);
    }
    a(Nf, "inspect");
    function vT(t) {
        for(var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            e[_key - 1] = arguments[_key];
        }
        if (e.length === 0) return t;
        let r = t, i = 0;
        for(r = r.replace(/%[sdj%]/g, (n)=>{
            if (i >= e.length) return n;
            let o = e[i++];
            switch(n){
                case "%s":
                    return String(o);
                case "%d":
                    return Number(o).toString();
                case "%j":
                    try {
                        return JSON.stringify(o);
                    } catch (e) {
                        return "[Circular]";
                    }
                case "%%":
                    return "%";
                default:
                    return n;
            }
        }); i < e.length;)r += " " + String(e[i++]);
        return r;
    }
    a(vT, "format");
});
_c12 = Bf;
var lo = T((je)=>{
    "use strict";
    Object.defineProperty(je, "__esModule", {
        value: !0
    });
    je.AssertionError = je.RangeError = je.TypeError = je.Error = void 0;
    je.message = zm;
    je.E = Or;
    var Lf = Bf(), qm = typeof Symbol > "u" ? "_kCode" : Symbol("code"), Hm = {};
    function Mf(t) {
        var e;
        return e = class extends t {
            constructor(i, ...n){
                super(zm(i, n)), this.code = i, this[qm] = i, this.name = "".concat(super.name, " [").concat(this[qm], "]");
            }
        }, a(e, "NodeError"), e;
    }
    a(Mf, "makeNodeError");
    var Gs = globalThis, jf = class jf extends Gs.Error {
        constructor(e){
            if (typeof e != "object" || e === null) throw new je.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
            e.message ? super(e.message) : super("".concat((0, Lf.inspect)(e.actual).slice(0, 128), " ").concat(e.operator, " ").concat((0, Lf.inspect)(e.expected).slice(0, 128))), this.generatedMessage = !e.message, this.name = "AssertionError [ERR_ASSERTION]", this.code = "ERR_ASSERTION", this.actual = e.actual, this.expected = e.expected, this.operator = e.operator, je.Error.captureStackTrace(this, e.stackStartFunction);
        }
    };
    a(jf, "AssertionError");
    var $f = jf;
    je.AssertionError = $f;
    function zm(t, e) {
        if (typeof t != "string") throw new je.Error("Error message key must be a string");
        let r = Hm[t];
        if (!r) throw new je.Error("An invalid error message key was used: ".concat(t, "."));
        let i;
        if (typeof r == "function") i = r;
        else {
            if (i = Lf.format, e === void 0 || e.length === 0) return r;
            e.unshift(r);
        }
        return String(i.apply(null, e));
    }
    a(zm, "message");
    function Or(t, e) {
        Hm[t] = typeof e == "function" ? e : String(e);
    }
    a(Or, "E");
    je.Error = Mf(Gs.Error);
    je.TypeError = Mf(Gs.TypeError);
    je.RangeError = Mf(Gs.RangeError);
    Or("ERR_DIR_CLOSED", "Directory handle was closed");
    Or("ERR_DIR_CONCURRENT_OPERATION", "Cannot do synchronous work on directory handle with concurrent asynchronous operations");
    Or("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s');
    Or("ERR_INVALID_FILE_URL_PATH", "File URL path %s");
    Or("ERR_INVALID_OPT_VALUE", (t, e)=>'The value "'.concat(String(e), '" is invalid for option "').concat(t, '"'));
    Or("ERR_INVALID_OPT_VALUE_ENCODING", (t)=>'The value "'.concat(String(t), '" is invalid for option "encoding"'));
    Or("ERR_INVALID_ARG_VALUE", "Unable to open file as blob");
});
var co = T((ii)=>{
    "use strict";
    Object.defineProperty(ii, "__esModule", {
        value: !0
    });
    ii.ENCODING_UTF8 = void 0;
    ii.assertEncoding = FT;
    ii.strToEncoding = ET;
    var Uf = Tr(), _T = lo();
    ii.ENCODING_UTF8 = "utf8";
    function FT(t) {
        if (t && !Uf.Buffer.isEncoding(t)) throw new _T.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", t);
    }
    a(FT, "assertEncoding");
    function ET(t, e) {
        return !e || e === ii.ENCODING_UTF8 ? t : e === "buffer" ? new Uf.Buffer(t) : new Uf.Buffer(t).toString(e);
    }
    a(ET, "strToEncoding");
});
var Xs = T(_c13 = (fo)=>{
    "use strict";
    Object.defineProperty(fo, "__esModule", {
        value: !0
    });
    fo.Dirent = void 0;
    var ST = kt(), xT = co(), { S_IFMT: TT, S_IFDIR: OT, S_IFREG: RT, S_IFBLK: kT, S_IFCHR: PT, S_IFLNK: AT, S_IFIFO: IT, S_IFSOCK: DT } = ST.constants, Zs = class Zs {
        static build(e, r) {
            let i = new Zs, { mode: n } = e.getNode();
            return i.name = (0, xT.strToEncoding)(e.getName(), r), i.mode = n, i.path = e.getParentPath(), i.parentPath = i.path, i;
        }
        _checkModeProperty(e) {
            return (this.mode & TT) === e;
        }
        isDirectory() {
            return this._checkModeProperty(OT);
        }
        isFile() {
            return this._checkModeProperty(RT);
        }
        isBlockDevice() {
            return this._checkModeProperty(kT);
        }
        isCharacterDevice() {
            return this._checkModeProperty(PT);
        }
        isSymbolicLink() {
            return this._checkModeProperty(AT);
        }
        isFIFO() {
            return this._checkModeProperty(IT);
        }
        isSocket() {
            return this._checkModeProperty(DT);
        }
        constructor(){
            this.name = "", this.path = "", this.parentPath = "", this.mode = 0;
        }
    };
    a(Zs, "Dirent");
    var Ks = Zs;
    fo.Dirent = Ks;
    fo.default = Ks;
});
_c14 = Xs;
var Wi = T(_c15 = (Se)=>{
    "use strict";
    Object.defineProperty(Se, "__esModule", {
        value: !0
    });
    Se.basename = Se.isAbsolute = Se.normalize = Se.dirname = Se.relative = Se.join = Se.posix = Se.sep = Se.resolve = void 0;
    var or = Er();
    Object.defineProperty(Se, "resolve", {
        enumerable: !0,
        get: a(function() {
            return or.resolve;
        }, "get")
    });
    Object.defineProperty(Se, "sep", {
        enumerable: !0,
        get: a(function() {
            return or.sep;
        }, "get")
    });
    Object.defineProperty(Se, "posix", {
        enumerable: !0,
        get: a(function() {
            return or.posix;
        }, "get")
    });
    Object.defineProperty(Se, "join", {
        enumerable: !0,
        get: a(function() {
            return or.join;
        }, "get")
    });
    Object.defineProperty(Se, "relative", {
        enumerable: !0,
        get: a(function() {
            return or.relative;
        }, "get")
    });
    Object.defineProperty(Se, "dirname", {
        enumerable: !0,
        get: a(function() {
            return or.dirname;
        }, "get")
    });
    Object.defineProperty(Se, "normalize", {
        enumerable: !0,
        get: a(function() {
            return or.normalize;
        }, "get")
    });
    Object.defineProperty(Se, "isAbsolute", {
        enumerable: !0,
        get: a(function() {
            return or.isAbsolute;
        }, "get")
    });
    Object.defineProperty(Se, "basename", {
        enumerable: !0,
        get: a(function() {
            return or.basename;
        }, "get")
    });
});
_c16 = Wi;
var Wf = {};
Tx(Wf, {
    __addDisposableResource: ()=>my,
    __assign: ()=>Ys,
    __asyncDelegator: ()=>ay,
    __asyncGenerator: ()=>sy,
    __asyncValues: ()=>ly,
    __await: ()=>Vi,
    __awaiter: ()=>ey,
    __classPrivateFieldGet: ()=>hy,
    __classPrivateFieldIn: ()=>py,
    __classPrivateFieldSet: ()=>dy,
    __createBinding: ()=>Qs,
    __decorate: ()=>Gm,
    __disposeResources: ()=>yy,
    __esDecorate: ()=>Zm,
    __exportStar: ()=>ry,
    __extends: ()=>Wm,
    __generator: ()=>ty,
    __importDefault: ()=>uy,
    __importStar: ()=>fy,
    __makeTemplateObject: ()=>cy,
    __metadata: ()=>Qm,
    __param: ()=>Km,
    __propKey: ()=>Ym,
    __read: ()=>zf,
    __rest: ()=>Vm,
    __rewriteRelativeImportExtension: ()=>wy,
    __runInitializers: ()=>Xm,
    __setFunctionName: ()=>Jm,
    __spread: ()=>iy,
    __spreadArray: ()=>oy,
    __spreadArrays: ()=>ny,
    __values: ()=>Js,
    default: ()=>BT
});
function Wm(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    qf(t, e);
    function r() {
        this.constructor = t;
    }
    a(r, "__"), t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r);
}
_c17 = Wm;
function Vm(t, e) {
    var r = {};
    for(var i in t)Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (r[i] = t[i]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function") for(var n = 0, i = Object.getOwnPropertySymbols(t); n < i.length; n++)e.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[n]) && (r[i[n]] = t[i[n]]);
    return r;
}
_c18 = Vm;
function Gm(t, e, r, i) {
    var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, r) : i, s;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(t, e, r, i);
    else for(var l = t.length - 1; l >= 0; l--)(s = t[l]) && (o = (n < 3 ? s(o) : n > 3 ? s(e, r, o) : s(e, r)) || o);
    return n > 3 && o && Object.defineProperty(e, r, o), o;
}
_c19 = Gm;
function Km(t, e) {
    return function(r, i) {
        e(r, i, t);
    };
}
_c20 = Km;
function Zm(t, e, r, i, n, o) {
    function s(v) {
        if (v !== void 0 && typeof v != "function") throw new TypeError("Function expected");
        return v;
    }
    a(s, "accept");
    for(var l = i.kind, f = l === "getter" ? "get" : l === "setter" ? "set" : "value", c = !e && t ? i.static ? t : t.prototype : null, u = e || (c ? Object.getOwnPropertyDescriptor(c, i.name) : {}), h, d = !1, p = r.length - 1; p >= 0; p--){
        var m = {};
        for(var y in i)m[y] = y === "access" ? {} : i[y];
        for(var y in i.access)m.access[y] = i.access[y];
        m.addInitializer = function(v) {
            if (d) throw new TypeError("Cannot add initializers after decoration has completed");
            o.push(s(v || null));
        };
        var w = (0, r[p])(l === "accessor" ? {
            get: u.get,
            set: u.set
        } : u[f], m);
        if (l === "accessor") {
            if (w === void 0) continue;
            if (w === null || typeof w != "object") throw new TypeError("Object expected");
            (h = s(w.get)) && (u.get = h), (h = s(w.set)) && (u.set = h), (h = s(w.init)) && n.unshift(h);
        } else (h = s(w)) && (l === "field" ? n.unshift(h) : u[f] = h);
    }
    c && Object.defineProperty(c, i.name, u), d = !0;
}
_c21 = Zm;
function Xm(t, e, r) {
    for(var i = arguments.length > 2, n = 0; n < e.length; n++)r = i ? e[n].call(t, r) : e[n].call(t);
    return i ? r : void 0;
}
_c22 = Xm;
function Ym(t) {
    return typeof t == "symbol" ? t : "".concat(t);
}
_c23 = Ym;
function Jm(t, e, r) {
    return typeof e == "symbol" && (e = e.description ? "[".concat(e.description, "]") : ""), Object.defineProperty(t, "name", {
        configurable: !0,
        value: r ? "".concat(r, " ", e) : e
    });
}
_c24 = Jm;
function Qm(t, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e);
}
_c25 = Qm;
function ey(t, e, r, i) {
    function n(o) {
        return o instanceof r ? o : new r(function(s) {
            s(o);
        });
    }
    return a(n, "adopt"), new (r || (r = Promise))(function(o, s) {
        function l(u) {
            try {
                c(i.next(u));
            } catch (h) {
                s(h);
            }
        }
        a(l, "fulfilled");
        function f(u) {
            try {
                c(i.throw(u));
            } catch (h) {
                s(h);
            }
        }
        a(f, "rejected");
        function c(u) {
            u.done ? o(u.value) : n(u.value).then(l, f);
        }
        a(c, "step"), c((i = i.apply(t, e || [])).next());
    });
}
function ty(t, e) {
    var r = {
        label: 0,
        sent: a(function() {
            if (o[0] & 1) throw o[1];
            return o[1];
        }, "sent"),
        trys: [],
        ops: []
    }, i, n, o, s = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
    return s.next = l(0), s.throw = l(1), s.return = l(2), typeof Symbol == "function" && (s[Symbol.iterator] = function() {
        return this;
    }), s;
    //TURBOPACK unreachable
    ;
    function l(c) {
        return function(u) {
            return f([
                c,
                u
            ]);
        };
    }
    function f(c) {
        if (i) throw new TypeError("Generator is already executing.");
        for(; s && (s = 0, c[0] && (r = 0)), r;)try {
            if (i = 1, n && (o = c[0] & 2 ? n.return : c[0] ? n.throw || ((o = n.return) && o.call(n), 0) : n.next) && !(o = o.call(n, c[1])).done) return o;
            switch(n = 0, o && (c = [
                c[0] & 2,
                o.value
            ]), c[0]){
                case 0:
                case 1:
                    o = c;
                    break;
                case 4:
                    return r.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    r.label++, n = c[1], c = [
                        0
                    ];
                    continue;
                case 7:
                    c = r.ops.pop(), r.trys.pop();
                    continue;
                default:
                    if (o = r.trys, !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        r = 0;
                        continue;
                    }
                    if (c[0] === 3 && (!o || c[1] > o[0] && c[1] < o[3])) {
                        r.label = c[1];
                        break;
                    }
                    if (c[0] === 6 && r.label < o[1]) {
                        r.label = o[1], o = c;
                        break;
                    }
                    if (o && r.label < o[2]) {
                        r.label = o[2], r.ops.push(c);
                        break;
                    }
                    o[2] && r.ops.pop(), r.trys.pop();
                    continue;
            }
            c = e.call(t, r);
        } catch (u) {
            c = [
                6,
                u
            ], n = 0;
        } finally{
            i = o = 0;
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        };
    }
}
function ry(t, e) {
    for(var r in t)r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && Qs(e, t, r);
}
function Js(t) {
    var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], i = 0;
    if (r) return r.call(t);
    if (t && typeof t.length == "number") return {
        next: a(function() {
            return t && i >= t.length && (t = void 0), {
                value: t && t[i++],
                done: !t
            };
        }, "next")
    };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
_c26 = Js;
function zf(t, e) {
    var r = typeof Symbol == "function" && t[Symbol.iterator];
    if (!r) return t;
    var i = r.call(t), n, o = [], s;
    try {
        for(; (e === void 0 || e-- > 0) && !(n = i.next()).done;)o.push(n.value);
    } catch (l) {
        s = {
            error: l
        };
    } finally{
        try {
            n && !n.done && (r = i.return) && r.call(i);
        } finally{
            if (s) throw s.error;
        }
    }
    return o;
}
function iy() {
    for(var t = [], e = 0; e < arguments.length; e++)t = t.concat(zf(arguments[e]));
    return t;
}
function ny() {
    for(var t = 0, e = 0, r = arguments.length; e < r; e++)t += arguments[e].length;
    for(var i = Array(t), n = 0, e = 0; e < r; e++)for(var o = arguments[e], s = 0, l = o.length; s < l; s++, n++)i[n] = o[s];
    return i;
}
function oy(t, e, r) {
    if (r || arguments.length === 2) for(var i = 0, n = e.length, o; i < n; i++)(o || !(i in e)) && (o || (o = Array.prototype.slice.call(e, 0, i)), o[i] = e[i]);
    return t.concat(o || Array.prototype.slice.call(e));
}
function Vi(t) {
    return this instanceof Vi ? (this.v = t, this) : new Vi(t);
}
_c27 = Vi;
function sy(t, e, r) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var i = r.apply(t, e || []), n, o = [];
    return n = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), l("next"), l("throw"), l("return", s), n[Symbol.asyncIterator] = function() {
        return this;
    }, n;
    //TURBOPACK unreachable
    ;
    function s(p) {
        return function(m) {
            return Promise.resolve(m).then(p, h);
        };
    }
    function l(p, m) {
        i[p] && (n[p] = function(y) {
            return new Promise(function(w, v) {
                o.push([
                    p,
                    y,
                    w,
                    v
                ]) > 1 || f(p, y);
            });
        }, m && (n[p] = m(n[p])));
    }
    function f(p, m) {
        try {
            c(i[p](m));
        } catch (y) {
            d(o[0][3], y);
        }
    }
    function c(p) {
        p.value instanceof Vi ? Promise.resolve(p.value.v).then(u, h) : d(o[0][2], p);
    }
    function u(p) {
        f("next", p);
    }
    function h(p) {
        f("throw", p);
    }
    function d(p, m) {
        p(m), o.shift(), o.length && f(o[0][0], o[0][1]);
    }
}
function ay(t) {
    var e, r;
    return e = {}, i("next"), i("throw", function(n) {
        throw n;
    }), i("return"), e[Symbol.iterator] = function() {
        return this;
    }, e;
    //TURBOPACK unreachable
    ;
    function i(n, o) {
        e[n] = t[n] ? function(s) {
            return (r = !r) ? {
                value: Vi(t[n](s)),
                done: !1
            } : o ? o(s) : s;
        } : o;
    }
}
function ly(t) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = t[Symbol.asyncIterator], r;
    return e ? e.call(t) : (t = typeof Js == "function" ? Js(t) : t[Symbol.iterator](), r = {}, i("next"), i("throw"), i("return"), r[Symbol.asyncIterator] = function() {
        return this;
    }, r);
    //TURBOPACK unreachable
    ;
    function i(o) {
        r[o] = t[o] && function(s) {
            return new Promise(function(l, f) {
                s = t[o](s), n(l, f, s.done, s.value);
            });
        };
    }
    function n(o, s, l, f) {
        Promise.resolve(f).then(function(c) {
            o({
                value: c,
                done: l
            });
        }, s);
    }
}
function cy(t, e) {
    return Object.defineProperty ? Object.defineProperty(t, "raw", {
        value: e
    }) : t.raw = e, t;
}
function fy(t) {
    if (t && t.__esModule) return t;
    var e = {};
    if (t != null) for(var r = Hf(t), i = 0; i < r.length; i++)r[i] !== "default" && Qs(e, t, r[i]);
    return CT(e, t), e;
}
function uy(t) {
    return t && t.__esModule ? t : {
        default: t
    };
}
function hy(t, e, r, i) {
    if (r === "a" && !i) throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? i : r === "a" ? i.call(t) : i ? i.value : e.get(t);
}
function dy(t, e, r, i, n) {
    if (i === "m") throw new TypeError("Private method is not writable");
    if (i === "a" && !n) throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return i === "a" ? n.call(t, r) : n ? n.value = r : e.set(t, r), r;
}
function py(t, e) {
    if (e === null || typeof e != "object" && typeof e != "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof t == "function" ? e === t : t.has(e);
}
function my(t, e, r) {
    if (e != null) {
        if (typeof e != "object" && typeof e != "function") throw new TypeError("Object expected.");
        var i, n;
        if (r) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            i = e[Symbol.asyncDispose];
        }
        if (i === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            i = e[Symbol.dispose], r && (n = i);
        }
        if (typeof i != "function") throw new TypeError("Object not disposable.");
        n && (i = a(function() {
            try {
                n.call(this);
            } catch (o) {
                return Promise.reject(o);
            }
        }, "dispose")), t.stack.push({
            value: e,
            dispose: i,
            async: r
        });
    } else r && t.stack.push({
        async: !0
    });
    return e;
}
function yy(t) {
    function e(o) {
        t.error = t.hasError ? new NT(o, t.error, "An error was suppressed during disposal.") : o, t.hasError = !0;
    }
    a(e, "fail");
    var r, i = 0;
    function n() {
        for(; r = t.stack.pop();)try {
            if (!r.async && i === 1) return i = 0, t.stack.push(r), Promise.resolve().then(n);
            if (r.dispose) {
                var o = r.dispose.call(r.value);
                if (r.async) return i |= 2, Promise.resolve(o).then(n, function(s) {
                    return e(s), n();
                });
            } else i |= 1;
        } catch (s) {
            e(s);
        }
        if (i === 1) return t.hasError ? Promise.reject(t.error) : Promise.resolve();
        if (t.hasError) throw t.error;
    }
    return a(n, "next"), n();
}
function wy(t, e) {
    return typeof t == "string" && /^\.\.?\//.test(t) ? t.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(r, i, n, o, s) {
        return i ? e ? ".jsx" : ".js" : n && (!o || !s) ? r : n + o + "." + s.toLowerCase() + "js";
    }) : t;
}
var qf, Ys, Qs, CT, Hf, NT, BT, Vf = xx(()=>{
    qf = a(function(t, e) {
        return qf = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(r, i) {
            r.__proto__ = i;
        } || function(r, i) {
            for(var n in i)Object.prototype.hasOwnProperty.call(i, n) && (r[n] = i[n]);
        }, qf(t, e);
    }, "extendStatics");
    a(Wm, "__extends");
    Ys = a(function() {
        return Ys = Object.assign || a(function(e) {
            for(var r, i = 1, n = arguments.length; i < n; i++){
                r = arguments[i];
                for(var o in r)Object.prototype.hasOwnProperty.call(r, o) && (e[o] = r[o]);
            }
            return e;
        }, "__assign"), Ys.apply(this, arguments);
    }, "__assign");
    a(Vm, "__rest");
    a(Gm, "__decorate");
    a(Km, "__param");
    a(Zm, "__esDecorate");
    a(Xm, "__runInitializers");
    a(Ym, "__propKey");
    a(Jm, "__setFunctionName");
    a(Qm, "__metadata");
    a(ey, "__awaiter");
    a(ty, "__generator");
    Qs = Object.create ? function(t, e, r, i) {
        i === void 0 && (i = r);
        var n = Object.getOwnPropertyDescriptor(e, r);
        (!n || ("get" in n ? !e.__esModule : n.writable || n.configurable)) && (n = {
            enumerable: !0,
            get: a(function() {
                return e[r];
            }, "get")
        }), Object.defineProperty(t, i, n);
    } : function(t, e, r, i) {
        i === void 0 && (i = r), t[i] = e[r];
    };
    a(ry, "__exportStar");
    a(Js, "__values");
    a(zf, "__read");
    a(iy, "__spread");
    a(ny, "__spreadArrays");
    a(oy, "__spreadArray");
    a(Vi, "__await");
    a(sy, "__asyncGenerator");
    a(ay, "__asyncDelegator");
    a(ly, "__asyncValues");
    a(cy, "__makeTemplateObject");
    CT = Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        });
    } : function(t, e) {
        t.default = e;
    }, Hf = a(function(t) {
        return Hf = Object.getOwnPropertyNames || function(e) {
            var r = [];
            for(var i in e)Object.prototype.hasOwnProperty.call(e, i) && (r[r.length] = i);
            return r;
        }, Hf(t);
    }, "ownKeys");
    a(fy, "__importStar");
    a(uy, "__importDefault");
    a(hy, "__classPrivateFieldGet");
    a(dy, "__classPrivateFieldSet");
    a(py, "__classPrivateFieldIn");
    a(my, "__addDisposableResource");
    NT = typeof SuppressedError == "function" ? SuppressedError : function(t, e, r) {
        var i = new Error(r);
        return i.name = "SuppressedError", i.error = t, i.suppressed = e, i;
    };
    a(yy, "__disposeResources");
    a(wy, "__rewriteRelativeImportExtension");
    BT = {
        __extends: Wm,
        __assign: Ys,
        __rest: Vm,
        __decorate: Gm,
        __param: Km,
        __esDecorate: Zm,
        __runInitializers: Xm,
        __propKey: Ym,
        __setFunctionName: Jm,
        __metadata: Qm,
        __awaiter: ey,
        __generator: ty,
        __createBinding: Qs,
        __exportStar: ry,
        __values: Js,
        __read: zf,
        __spread: iy,
        __spreadArrays: ny,
        __spreadArray: oy,
        __await: Vi,
        __asyncGenerator: sy,
        __asyncDelegator: ay,
        __asyncValues: ly,
        __makeTemplateObject: cy,
        __importStar: fy,
        __importDefault: uy,
        __classPrivateFieldGet: hy,
        __classPrivateFieldSet: dy,
        __classPrivateFieldIn: py,
        __addDisposableResource: my,
        __disposeResources: yy,
        __rewriteRelativeImportExtension: wy
    };
});
var by = T((gy)=>{
    "use strict";
    Object.defineProperty(gy, "__esModule", {
        value: !0
    });
});
var Kf = T(_c28 = (ea)=>{
    "use strict";
    Object.defineProperty(ea, "__esModule", {
        value: !0
    });
    ea.flattenJSON = void 0;
    var vy = Tr(), Gf = Wi(), LT = Gf.posix ? Gf.posix.join : Gf.join, $T = a((t)=>{
        let e = {};
        function r(i, n) {
            for(let o in n){
                let s = n[o], l = LT(i, o);
                typeof s == "string" || s instanceof vy.Buffer ? e[l] = s : typeof s == "object" && s !== null && !(s instanceof vy.Buffer) && Object.keys(s).length > 0 ? r(l, s) : e[l] = null;
            }
        }
        return a(r, "flatten"), r("", t), e;
    }, "flattenJSON");
    ea.flattenJSON = $T;
});
_c29 = Kf;
var Yf = T(_c30 = (ta)=>{
    "use strict";
    Object.defineProperty(ta, "__esModule", {
        value: !0
    });
    ta.FanOut = void 0;
    var Xf = class Xf {
        emit(e) {
            this.listeners.forEach((r)=>r(e));
        }
        listen(e) {
            let r = this.listeners;
            return r.add(e), ()=>r.delete(e);
        }
        constructor(){
            this.listeners = new Set;
        }
    };
    a(Xf, "FanOut");
    var Zf = Xf;
    ta.FanOut = Zf;
});
_c31 = Yf;
var ia = T((ra)=>{
    "use strict";
    Object.defineProperty(ra, "__esModule", {
        value: !0
    });
    ra.createProcess = _y;
    var MT = a(()=>{
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] < "u") return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
        try {
            return Sx("process");
        } catch (e) {
            return;
        }
    }, "maybeReturnProcess");
    function _y() {
        let t = MT() || {};
        return t.cwd || (t.cwd = ()=>"/"), t.emitWarning || (t.emitWarning = (e, r)=>{
            console.warn("".concat(r).concat(r ? ": " : "").concat(e));
        }), t.env || (t.env = {}), t;
    }
    a(_y, "createProcess");
    ra.default = _y();
});
var eu = T((sa)=>{
    "use strict";
    Object.defineProperty(sa, "__esModule", {
        value: !0
    });
    sa.Node = void 0;
    var jT = Yf(), Ey = ia(), ht = Tr(), UT = kt(), { S_IFMT: sr, S_IFDIR: qT, S_IFREG: HT, S_IFLNK: Fy, S_IFCHR: zT } = UT.constants, na = a(()=>{
        var _Ey_default_getuid, _Ey_default;
        var _Ey_default_getuid1;
        return (_Ey_default_getuid1 = (_Ey_default_getuid = (_Ey_default = Ey.default).getuid) === null || _Ey_default_getuid === void 0 ? void 0 : _Ey_default_getuid.call(_Ey_default)) !== null && _Ey_default_getuid1 !== void 0 ? _Ey_default_getuid1 : 0;
    }, "getuid"), oa = a(()=>{
        var _Ey_default_getgid, _Ey_default;
        var _Ey_default_getgid1;
        return (_Ey_default_getgid1 = (_Ey_default_getgid = (_Ey_default = Ey.default).getgid) === null || _Ey_default_getgid === void 0 ? void 0 : _Ey_default_getgid.call(_Ey_default)) !== null && _Ey_default_getgid1 !== void 0 ? _Ey_default_getgid1 : 0;
    }, "getgid"), Qf = class Qf {
        set ctime(e) {
            this._ctime = e;
        }
        get ctime() {
            return this._ctime;
        }
        set uid(e) {
            this._uid = e, this.ctime = new Date;
        }
        get uid() {
            return this._uid;
        }
        set gid(e) {
            this._gid = e, this.ctime = new Date;
        }
        get gid() {
            return this._gid;
        }
        set atime(e) {
            this._atime = e;
        }
        get atime() {
            return this._atime;
        }
        set mtime(e) {
            this._mtime = e, this.ctime = new Date;
        }
        get mtime() {
            return this._mtime;
        }
        get perm() {
            return this.mode & ~sr;
        }
        set perm(e) {
            this.mode = this.mode & sr | e & ~sr, this.ctime = new Date;
        }
        set nlink(e) {
            this._nlink = e, this.ctime = new Date;
        }
        get nlink() {
            return this._nlink;
        }
        getString() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "utf8";
            return this.atime = new Date, this.getBuffer().toString(e);
        }
        setString(e) {
            this.buf = (0, ht.bufferFrom)(e, "utf8"), this.touch();
        }
        getBuffer() {
            return this.atime = new Date, this.buf || (this.buf = (0, ht.bufferAllocUnsafe)(0)), (0, ht.bufferFrom)(this.buf);
        }
        setBuffer(e) {
            this.buf = (0, ht.bufferFrom)(e), this.touch();
        }
        getSize() {
            return this.buf ? this.buf.length : 0;
        }
        setModeProperty(e) {
            this.mode = e;
        }
        isFile() {
            return (this.mode & sr) === HT;
        }
        isDirectory() {
            return (this.mode & sr) === qT;
        }
        isSymlink() {
            return (this.mode & sr) === Fy;
        }
        isCharacterDevice() {
            return (this.mode & sr) === zT;
        }
        makeSymlink(e) {
            this.mode = Fy | 438, this.symlink = e;
        }
        write(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.length, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            if (this.buf || (this.buf = (0, ht.bufferAllocUnsafe)(0)), n + i > this.buf.length) {
                let o = (0, ht.bufferAllocUnsafe)(n + i);
                this.buf.copy(o, 0, 0, this.buf.length), this.buf = o;
            }
            return e.copy(this.buf, n, r, r + i), this.touch(), i;
        }
        read(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.byteLength, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            if (this.atime = new Date, this.buf || (this.buf = (0, ht.bufferAllocUnsafe)(0)), n >= this.buf.length) return 0;
            let o = i;
            o > e.byteLength && (o = e.byteLength), o + n > this.buf.length && (o = this.buf.length - n);
            let s = e instanceof ht.Buffer ? e : ht.Buffer.from(e.buffer, e.byteOffset, e.byteLength);
            return this.buf.copy(s, r, n, n + o), o;
        }
        truncate() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            if (!e) this.buf = (0, ht.bufferAllocUnsafe)(0);
            else if (this.buf || (this.buf = (0, ht.bufferAllocUnsafe)(0)), e <= this.buf.length) this.buf = this.buf.slice(0, e);
            else {
                let r = (0, ht.bufferAllocUnsafe)(e);
                this.buf.copy(r), r.fill(0, this.buf.length), this.buf = r;
            }
            this.touch();
        }
        chmod(e) {
            this.mode = this.mode & sr | e & ~sr, this.touch();
        }
        chown(e, r) {
            this.uid = e, this.gid = r, this.touch();
        }
        touch() {
            this.mtime = new Date, this.changes.emit([
                "modify"
            ]);
        }
        canRead() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : na(), r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : oa();
            return !!(this.perm & 4 || r === this.gid && this.perm & 32 || e === this.uid && this.perm & 256);
        }
        canWrite() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : na(), r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : oa();
            return !!(this.perm & 2 || r === this.gid && this.perm & 16 || e === this.uid && this.perm & 128);
        }
        canExecute() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : na(), r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : oa();
            return !!(this.perm & 1 || r === this.gid && this.perm & 8 || e === this.uid && this.perm & 64);
        }
        del() {
            this.changes.emit([
                "delete"
            ]);
        }
        toJSON() {
            return {
                ino: this.ino,
                uid: this.uid,
                gid: this.gid,
                atime: this.atime.getTime(),
                mtime: this.mtime.getTime(),
                ctime: this.ctime.getTime(),
                perm: this.perm,
                mode: this.mode,
                nlink: this.nlink,
                symlink: this.symlink,
                data: this.getString()
            };
        }
        constructor(e, r = 438){
            this.changes = new jT.FanOut, this._uid = na(), this._gid = oa(), this._atime = new Date, this._mtime = new Date, this._ctime = new Date, this.rdev = 0, this._nlink = 1, this.mode = r, this.ino = e;
        }
    };
    a(Qf, "Node");
    var Jf = Qf;
    sa.Node = Jf;
});
var ru = T((aa)=>{
    "use strict";
    Object.defineProperty(aa, "__esModule", {
        value: !0
    });
    aa.Link = void 0;
    var WT = kt(), VT = Yf(), { S_IFREG: GT } = WT.constants, uo = class uo {
        get steps() {
            return this._steps;
        }
        set steps(e) {
            this._steps = e;
            for (let [r, i] of this.children.entries())r === "." || r === ".." || (i === null || i === void 0 ? void 0 : i.syncSteps());
        }
        setNode(e) {
            this.node = e, this.ino = e.ino;
        }
        getNode() {
            return this.node;
        }
        createChild(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.vol.createNode(GT | 438);
            let i = new uo(this.vol, this, e);
            return i.setNode(r), r.isDirectory() && (i.children.set(".", i), i.getNode().nlink++), this.setChild(e, i), i;
        }
        setChild(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new uo(this.vol, this, e);
            return this.children.set(e, r), r.parent = this, this.length++, r.getNode().isDirectory() && (r.children.set("..", this), this.getNode().nlink++), this.getNode().mtime = new Date, this.changes.emit([
                "child:add",
                r,
                this
            ]), r;
        }
        deleteChild(e) {
            e.getNode().isDirectory() && (e.children.delete(".."), this.getNode().nlink--), this.children.delete(e.getName()), this.length--, this.getNode().mtime = new Date, this.changes.emit([
                "child:del",
                e,
                this
            ]);
        }
        getChild(e) {
            return this.getNode().atime = new Date, this.children.get(e);
        }
        getPath() {
            return this.steps.join("/");
        }
        getParentPath() {
            return this.steps.slice(0, -1).join("/");
        }
        getName() {
            return this.steps[this.steps.length - 1];
        }
        toJSON() {
            return {
                steps: this.steps,
                ino: this.ino,
                children: Array.from(this.children.keys())
            };
        }
        syncSteps() {
            this.steps = this.parent ? this.parent.steps.concat([
                this.name
            ]) : [
                this.name
            ];
        }
        constructor(e, r, i){
            this.changes = new VT.FanOut, this.children = new Map, this._steps = [], this.ino = 0, this.length = 0, this.vol = e, this.parent = r, this.name = i, this.syncSteps();
        }
    };
    a(uo, "Link");
    var tu = uo;
    aa.Link = tu;
});
var ou = T((la)=>{
    "use strict";
    Object.defineProperty(la, "__esModule", {
        value: !0
    });
    la.File = void 0;
    var KT = kt(), { O_APPEND: ZT } = KT.constants, nu = class nu {
        getString() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "utf8";
            return this.node.getString();
        }
        setString(e) {
            this.node.setString(e);
        }
        getBuffer() {
            return this.node.getBuffer();
        }
        setBuffer(e) {
            this.node.setBuffer(e);
        }
        getSize() {
            return this.node.getSize();
        }
        truncate(e) {
            this.node.truncate(e);
        }
        seekTo(e) {
            this.position = e;
        }
        write(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.length, n = arguments.length > 3 ? arguments[3] : void 0;
            typeof n != "number" && (n = this.position);
            let o = this.node.write(e, r, i, n);
            return this.position = n + o, o;
        }
        read(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.byteLength, n = arguments.length > 3 ? arguments[3] : void 0;
            typeof n != "number" && (n = this.position);
            let o = this.node.read(e, r, i, n);
            return this.position = n + o, o;
        }
        chmod(e) {
            this.node.chmod(e);
        }
        chown(e, r) {
            this.node.chown(e, r);
        }
        constructor(e, r, i, n){
            this.link = e, this.node = r, this.flags = i, this.fd = n, this.position = 0, this.flags & ZT && (this.position = this.getSize());
        }
    };
    a(nu, "File");
    var iu = nu;
    la.File = iu;
});
var Zi = T(_c32 = (Ki)=>{
    "use strict";
    Object.defineProperty(Ki, "__esModule", {
        value: !0
    });
    Ki.FLAGS = Ki.ERRSTR = void 0;
    var XT = kt();
    Ki.ERRSTR = {
        PATH_STR: "path must be a string, Buffer, or Uint8Array",
        FD: "fd must be a file descriptor",
        MODE_INT: "mode must be an int",
        CB: "callback must be a function",
        UID: "uid must be an unsigned int",
        GID: "gid must be an unsigned int",
        LEN: "len must be an integer",
        ATIME: "atime must be an integer",
        MTIME: "mtime must be an integer",
        PREFIX: "filename prefix is required",
        BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
        OFFSET: "offset must be an integer",
        LENGTH: "length must be an integer",
        POSITION: "position must be an integer"
    };
    var { O_RDONLY: Sy, O_WRONLY: ca, O_RDWR: Gi, O_CREAT: Rr, O_EXCL: fa, O_TRUNC: ua, O_APPEND: ha, O_SYNC: xy } = XT.constants, Ty;
    (function(t) {
        t[t.r = Sy] = "r", t[t["r+"] = Gi] = "r+", t[t.rs = Sy | xy] = "rs", t[t.sr = t.rs] = "sr", t[t["rs+"] = Gi | xy] = "rs+", t[t["sr+"] = t["rs+"]] = "sr+", t[t.w = ca | Rr | ua] = "w", t[t.wx = ca | Rr | ua | fa] = "wx", t[t.xw = t.wx] = "xw", t[t["w+"] = Gi | Rr | ua] = "w+", t[t["wx+"] = Gi | Rr | ua | fa] = "wx+", t[t["xw+"] = t["wx+"]] = "xw+", t[t.a = ca | ha | Rr] = "a", t[t.ax = ca | ha | Rr | fa] = "ax", t[t.xa = t.ax] = "xa", t[t["a+"] = Gi | ha | Rr] = "a+", t[t["ax+"] = Gi | ha | Rr | fa] = "ax+", t[t["xa+"] = t["ax+"]] = "xa+";
    })(Ty || (Ki.FLAGS = Ty = {}));
});
_c33 = Zi;
var au = T((su)=>{
    "use strict";
    Object.defineProperty(su, "__esModule", {
        value: !0
    });
    su.default = typeof queueMicrotask == "function" ? queueMicrotask : (t)=>Promise.resolve().then(()=>t()).catch(()=>{});
});
var ya = T((De)=>{
    "use strict";
    Object.defineProperty(De, "__esModule", {
        value: !0
    });
    De.filenameToSteps = De.resolve = De.unixify = De.isWin = void 0;
    De.isFd = Ry;
    De.validateFd = sO;
    De.dataToBuffer = aO;
    var pa = Wi(), da = Tr(), Oy = ia(), YT = co(), JT = Zi();
    De.isWin = Oy.default.platform === "win32";
    var QT = pa.resolve, eO = pa.posix ? pa.posix.sep : pa.sep, tO = a((t, e)=>{
        let r = t[e];
        return e > 0 && (r === "/" || De.isWin && r === "\\");
    }, "isSeparator"), rO = a((t)=>{
        let e = t.length - 1;
        if (e < 2) return t;
        for(; tO(t, e);)e--;
        return t.substr(0, e + 1);
    }, "removeTrailingSeparator"), iO = a((t, e)=>{
        if (typeof t != "string") throw new TypeError("expected a string");
        return t = t.replace(/[\\\/]+/g, "/"), e !== !1 && (t = rO(t)), t;
    }, "normalizePath"), nO = a(function(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
        return De.isWin ? (t = iO(t, e), t.replace(/^([a-zA-Z]+:|\.\/)/, "")) : t;
    }, "unixify");
    De.unixify = nO;
    var ma = a(function(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Oy.default.cwd();
        return QT(e, t);
    }, "resolve");
    De.resolve = ma;
    if (De.isWin) {
        let t = ma;
        De.resolve = ma = a((e, r)=>(0, De.unixify)(t(e, r)), "resolve");
    }
    var oO = a((t, e)=>{
        let i = ma(t, e).substring(1);
        return i ? i.split(eO) : [];
    }, "filenameToSteps");
    De.filenameToSteps = oO;
    function Ry(t) {
        return t >>> 0 === t;
    }
    a(Ry, "isFd");
    function sO(t) {
        if (!Ry(t)) throw TypeError(JT.ERRSTR.FD);
    }
    a(sO, "validateFd");
    function aO(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : YT.ENCODING_UTF8;
        return da.Buffer.isBuffer(t) ? t : t instanceof Uint8Array ? (0, da.bufferFrom)(t) : e === "buffer" ? (0, da.bufferFrom)(String(t), "utf8") : (0, da.bufferFrom)(String(t), e);
    }
    a(aO, "dataToBuffer");
});
var ky = T((Xi, Yi)=>{
    (function(t) {
        var e = typeof Xi == "object" && Xi && !Xi.nodeType && Xi, r = typeof Yi == "object" && Yi && !Yi.nodeType && Yi, i = typeof globalThis == "object" && globalThis;
        (i.global === i || i.window === i || i.self === i) && (t = i);
        var n, o = 2147483647, s = 36, l = 1, f = 26, c = 38, u = 700, h = 72, d = 128, p = "-", m = /^xn--/, y = /[^\x20-\x7E]/, w = /[\x2E\u3002\uFF0E\uFF61]/g, v = {
            overflow: "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input"
        }, g = s - l, F = Math.floor, O = String.fromCharCode, S;
        function R($) {
            throw new RangeError(v[$]);
        }
        a(R, "error");
        function b($, H) {
            for(var G = $.length, X = []; G--;)X[G] = H($[G]);
            return X;
        }
        a(b, "map");
        function x($, H) {
            var G = $.split("@"), X = "";
            G.length > 1 && (X = G[0] + "@", $ = G[1]), $ = $.replace(w, ".");
            var z = $.split("."), fe = b(z, H).join(".");
            return X + fe;
        }
        a(x, "mapDomain");
        function _($) {
            for(var H = [], G = 0, X = $.length, z, fe; G < X;)z = $.charCodeAt(G++), z >= 55296 && z <= 56319 && G < X ? (fe = $.charCodeAt(G++), (fe & 64512) == 56320 ? H.push(((z & 1023) << 10) + (fe & 1023) + 65536) : (H.push(z), G--)) : H.push(z);
            return H;
        }
        a(_, "ucs2decode");
        function P($) {
            return b($, function(H) {
                var G = "";
                return H > 65535 && (H -= 65536, G += O(H >>> 10 & 1023 | 55296), H = 56320 | H & 1023), G += O(H), G;
            }).join("");
        }
        a(P, "ucs2encode");
        function k($) {
            return $ - 48 < 10 ? $ - 22 : $ - 65 < 26 ? $ - 65 : $ - 97 < 26 ? $ - 97 : s;
        }
        a(k, "basicToDigit");
        function C($, H) {
            return $ + 22 + 75 * ($ < 26) - ((H != 0) << 5);
        }
        a(C, "digitToBasic");
        function N($, H, G) {
            var X = 0;
            for($ = G ? F($ / u) : $ >> 1, $ += F($ / H); $ > g * f >> 1; X += s)$ = F($ / g);
            return F(X + (g + 1) * $ / ($ + c));
        }
        a(N, "adapt");
        function U($) {
            var H = [], G = $.length, X, z = 0, fe = d, ee = h, Oe, Re, se, Ot, ve, Ve, Be, Y, he;
            for(Oe = $.lastIndexOf(p), Oe < 0 && (Oe = 0), Re = 0; Re < Oe; ++Re)$.charCodeAt(Re) >= 128 && R("not-basic"), H.push($.charCodeAt(Re));
            for(se = Oe > 0 ? Oe + 1 : 0; se < G;){
                for(Ot = z, ve = 1, Ve = s; se >= G && R("invalid-input"), Be = k($.charCodeAt(se++)), (Be >= s || Be > F((o - z) / ve)) && R("overflow"), z += Be * ve, Y = Ve <= ee ? l : Ve >= ee + f ? f : Ve - ee, !(Be < Y); Ve += s)he = s - Y, ve > F(o / he) && R("overflow"), ve *= he;
                X = H.length + 1, ee = N(z - Ot, X, Ot == 0), F(z / X) > o - fe && R("overflow"), fe += F(z / X), z %= X, H.splice(z++, 0, fe);
            }
            return P(H);
        }
        a(U, "decode");
        function Z($) {
            var H, G, X, z, fe, ee, Oe, Re, se, Ot, ve, Ve = [], Be, Y, he, Me;
            for($ = _($), Be = $.length, H = d, G = 0, fe = h, ee = 0; ee < Be; ++ee)ve = $[ee], ve < 128 && Ve.push(O(ve));
            for(X = z = Ve.length, z && Ve.push(p); X < Be;){
                for(Oe = o, ee = 0; ee < Be; ++ee)ve = $[ee], ve >= H && ve < Oe && (Oe = ve);
                for(Y = X + 1, Oe - H > F((o - G) / Y) && R("overflow"), G += (Oe - H) * Y, H = Oe, ee = 0; ee < Be; ++ee)if (ve = $[ee], ve < H && ++G > o && R("overflow"), ve == H) {
                    for(Re = G, se = s; Ot = se <= fe ? l : se >= fe + f ? f : se - fe, !(Re < Ot); se += s)Me = Re - Ot, he = s - Ot, Ve.push(O(C(Ot + Me % he, 0))), Re = F(Me / he);
                    Ve.push(O(C(Re, 0))), fe = N(G, Y, X == z), G = 0, ++X;
                }
                ++G, ++H;
            }
            return Ve.join("");
        }
        a(Z, "encode");
        function me($) {
            return x($, function(H) {
                return m.test(H) ? U(H.slice(4).toLowerCase()) : H;
            });
        }
        a(me, "toUnicode");
        function Ee($) {
            return x($, function(H) {
                return y.test(H) ? "xn--" + Z(H) : H;
            });
        }
        if (a(Ee, "toASCII"), n = {
            version: "1.4.1",
            ucs2: {
                decode: _,
                encode: P
            },
            decode: U,
            encode: Z,
            toASCII: Ee,
            toUnicode: me
        }, typeof define == "function" && typeof define.amd == "object" && define.amd) ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return n;
        }(__turbopack_context__.r, exports, module));
        else if (e && r) if (Yi.exports == e) r.exports = n;
        else for(S in n)n.hasOwnProperty(S) && (e[S] = n[S]);
        else t.punycode = n;
    })(Xi);
});
var qt = T((v8, Py)=>{
    "use strict";
    Py.exports = TypeError;
});
var Ay = T(_c34 = ()=>{});
_c35 = Ay;
var wo = T((E8, Yy)=>{
    var wu = typeof Map == "function" && Map.prototype, lu = Object.getOwnPropertyDescriptor && wu ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, ga = wu && lu && typeof lu.get == "function" ? lu.get : null, Iy = wu && Map.prototype.forEach, gu = typeof Set == "function" && Set.prototype, cu = Object.getOwnPropertyDescriptor && gu ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, ba = gu && cu && typeof cu.get == "function" ? cu.get : null, Dy = gu && Set.prototype.forEach, lO = typeof WeakMap == "function" && WeakMap.prototype, po = lO ? WeakMap.prototype.has : null, cO = typeof WeakSet == "function" && WeakSet.prototype, mo = cO ? WeakSet.prototype.has : null, fO = typeof WeakRef == "function" && WeakRef.prototype, Cy = fO ? WeakRef.prototype.deref : null, uO = Boolean.prototype.valueOf, hO = Object.prototype.toString, dO = Function.prototype.toString, pO = String.prototype.match, bu = String.prototype.slice, kr = String.prototype.replace, mO = String.prototype.toUpperCase, Ny = String.prototype.toLowerCase, zy = RegExp.prototype.test, By = Array.prototype.concat, Ht = Array.prototype.join, yO = Array.prototype.slice, Ly = Math.floor, hu = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, fu = Object.getOwnPropertySymbols, du = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, Ji = typeof Symbol == "function" && typeof Symbol.iterator == "object", yo = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === Ji || !0) ? Symbol.toStringTag : null, Wy = Object.prototype.propertyIsEnumerable, $y = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
        return t.__proto__;
    } : null);
    function My(t, e) {
        if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || zy.call(/e/, e)) return e;
        var r = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof t == "number") {
            var i = t < 0 ? -Ly(-t) : Ly(t);
            if (i !== t) {
                var n = String(i), o = bu.call(e, n.length + 1);
                return kr.call(n, r, "$&_") + "." + kr.call(kr.call(o, /([0-9]{3})/g, "$&_"), /_$/, "");
            }
        }
        return kr.call(e, r, "$&_");
    }
    a(My, "addNumericSeparator");
    var pu = Ay(), jy = pu.custom, Uy = Ky(jy) ? jy : null, Vy = {
        __proto__: null,
        double: '"',
        single: "'"
    }, wO = {
        __proto__: null,
        double: /(["\\])/g,
        single: /(['\\])/g
    };
    Yy.exports = a(function t(e, r, i, n) {
        var o = r || {};
        if (ar(o, "quoteStyle") && !ar(Vy, o.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
        if (ar(o, "maxStringLength") && (typeof o.maxStringLength == "number" ? o.maxStringLength < 0 && o.maxStringLength !== 1 / 0 : o.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        var s = ar(o, "customInspect") ? o.customInspect : !0;
        if (typeof s != "boolean" && s !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        if (ar(o, "indent") && o.indent !== null && o.indent !== "	" && !(parseInt(o.indent, 10) === o.indent && o.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        if (ar(o, "numericSeparator") && typeof o.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        var l = o.numericSeparator;
        if (typeof e > "u") return "undefined";
        if (e === null) return "null";
        if (typeof e == "boolean") return e ? "true" : "false";
        if (typeof e == "string") return Xy(e, o);
        if (typeof e == "number") {
            if (e === 0) return 1 / 0 / e > 0 ? "0" : "-0";
            var f = String(e);
            return l ? My(e, f) : f;
        }
        if (typeof e == "bigint") {
            var c = String(e) + "n";
            return l ? My(e, c) : c;
        }
        var u = typeof o.depth > "u" ? 5 : o.depth;
        if (typeof i > "u" && (i = 0), i >= u && u > 0 && typeof e == "object") return mu(e) ? "[Array]" : "[Object]";
        var h = NO(o, i);
        if (typeof n > "u") n = [];
        else if (Zy(n, e) >= 0) return "[Circular]";
        function d(N, U, Z) {
            if (U && (n = yO.call(n), n.push(U)), Z) {
                var me = {
                    depth: o.depth
                };
                return ar(o, "quoteStyle") && (me.quoteStyle = o.quoteStyle), t(N, me, i + 1, n);
            }
            return t(N, o, i + 1, n);
        }
        if (a(d, "inspect"), typeof e == "function" && !qy(e)) {
            var p = TO(e), m = wa(e, d);
            return "[Function" + (p ? ": " + p : " (anonymous)") + "]" + (m.length > 0 ? " { " + Ht.call(m, ", ") + " }" : "");
        }
        if (Ky(e)) {
            var y = Ji ? kr.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : du.call(e);
            return typeof e == "object" && !Ji ? ho(y) : y;
        }
        if (IO(e)) {
            for(var w = "<" + Ny.call(String(e.nodeName)), v = e.attributes || [], g = 0; g < v.length; g++)w += " " + v[g].name + "=" + Gy(gO(v[g].value), "double", o);
            return w += ">", e.childNodes && e.childNodes.length && (w += "..."), w += "</" + Ny.call(String(e.nodeName)) + ">", w;
        }
        if (mu(e)) {
            if (e.length === 0) return "[]";
            var F = wa(e, d);
            return h && !CO(F) ? "[" + yu(F, h) + "]" : "[ " + Ht.call(F, ", ") + " ]";
        }
        if (vO(e)) {
            var O = wa(e, d);
            return !("cause" in Error.prototype) && "cause" in e && !Wy.call(e, "cause") ? "{ [" + String(e) + "] " + Ht.call(By.call("[cause]: " + d(e.cause), O), ", ") + " }" : O.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + Ht.call(O, ", ") + " }";
        }
        if (typeof e == "object" && s) {
            if (Uy && typeof e[Uy] == "function" && pu) return pu(e, {
                depth: u - i
            });
            if (s !== "symbol" && typeof e.inspect == "function") return e.inspect();
        }
        if (OO(e)) {
            var S = [];
            return Iy && Iy.call(e, function(N, U) {
                S.push(d(U, e, !0) + " => " + d(N, e));
            }), Hy("Map", ga.call(e), S, h);
        }
        if (PO(e)) {
            var R = [];
            return Dy && Dy.call(e, function(N) {
                R.push(d(N, e));
            }), Hy("Set", ba.call(e), R, h);
        }
        if (RO(e)) return uu("WeakMap");
        if (AO(e)) return uu("WeakSet");
        if (kO(e)) return uu("WeakRef");
        if (FO(e)) return ho(d(Number(e)));
        if (SO(e)) return ho(d(hu.call(e)));
        if (EO(e)) return ho(uO.call(e));
        if (_O(e)) return ho(d(String(e)));
        if ("object" < "u" && e === window) return "{ [object Window] }";
        if (typeof globalThis < "u" && e === globalThis || typeof globalThis < "u" && e === globalThis) return "{ [object globalThis] }";
        if (!bO(e) && !qy(e)) {
            var b = wa(e, d), x = $y ? $y(e) === Object.prototype : e instanceof Object || e.constructor === Object, _ = e instanceof Object ? "" : "null prototype", P = !x && yo && Object(e) === e && yo in e ? bu.call(Pr(e), 8, -1) : _ ? "Object" : "", k = x || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "", C = k + (P || _ ? "[" + Ht.call(By.call([], P || [], _ || []), ": ") + "] " : "");
            return b.length === 0 ? C + "{}" : h ? C + "{" + yu(b, h) + "}" : C + "{ " + Ht.call(b, ", ") + " }";
        }
        return String(e);
    }, "inspect_");
    function Gy(t, e, r) {
        var i = r.quoteStyle || e, n = Vy[i];
        return n + t + n;
    }
    a(Gy, "wrapQuotes");
    function gO(t) {
        return kr.call(String(t), /"/g, "&quot;");
    }
    a(gO, "quote");
    function ni(t) {
        return !yo || !(typeof t == "object" && (yo in t || typeof t[yo] < "u"));
    }
    a(ni, "canTrustToString");
    function mu(t) {
        return Pr(t) === "[object Array]" && ni(t);
    }
    a(mu, "isArray");
    function bO(t) {
        return Pr(t) === "[object Date]" && ni(t);
    }
    a(bO, "isDate");
    function qy(t) {
        return Pr(t) === "[object RegExp]" && ni(t);
    }
    a(qy, "isRegExp");
    function vO(t) {
        return Pr(t) === "[object Error]" && ni(t);
    }
    a(vO, "isError");
    function _O(t) {
        return Pr(t) === "[object String]" && ni(t);
    }
    a(_O, "isString");
    function FO(t) {
        return Pr(t) === "[object Number]" && ni(t);
    }
    a(FO, "isNumber");
    function EO(t) {
        return Pr(t) === "[object Boolean]" && ni(t);
    }
    a(EO, "isBoolean");
    function Ky(t) {
        if (Ji) return t && typeof t == "object" && t instanceof Symbol;
        if (typeof t == "symbol") return !0;
        if (!t || typeof t != "object" || !du) return !1;
        try {
            return du.call(t), !0;
        } catch (e) {}
        return !1;
    }
    a(Ky, "isSymbol");
    function SO(t) {
        if (!t || typeof t != "object" || !hu) return !1;
        try {
            return hu.call(t), !0;
        } catch (e) {}
        return !1;
    }
    a(SO, "isBigInt");
    var xO = Object.prototype.hasOwnProperty || function(t) {
        return t in this;
    };
    function ar(t, e) {
        return xO.call(t, e);
    }
    a(ar, "has");
    function Pr(t) {
        return hO.call(t);
    }
    a(Pr, "toStr");
    function TO(t) {
        if (t.name) return t.name;
        var e = pO.call(dO.call(t), /^function\s*([\w$]+)/);
        return e ? e[1] : null;
    }
    a(TO, "nameOf");
    function Zy(t, e) {
        if (t.indexOf) return t.indexOf(e);
        for(var r = 0, i = t.length; r < i; r++)if (t[r] === e) return r;
        return -1;
    }
    a(Zy, "indexOf");
    function OO(t) {
        if (!ga || !t || typeof t != "object") return !1;
        try {
            ga.call(t);
            try {
                ba.call(t);
            } catch (e) {
                return !0;
            }
            return t instanceof Map;
        } catch (e) {}
        return !1;
    }
    a(OO, "isMap");
    function RO(t) {
        if (!po || !t || typeof t != "object") return !1;
        try {
            po.call(t, po);
            try {
                mo.call(t, mo);
            } catch (e) {
                return !0;
            }
            return t instanceof WeakMap;
        } catch (e) {}
        return !1;
    }
    a(RO, "isWeakMap");
    function kO(t) {
        if (!Cy || !t || typeof t != "object") return !1;
        try {
            return Cy.call(t), !0;
        } catch (e) {}
        return !1;
    }
    a(kO, "isWeakRef");
    function PO(t) {
        if (!ba || !t || typeof t != "object") return !1;
        try {
            ba.call(t);
            try {
                ga.call(t);
            } catch (e) {
                return !0;
            }
            return t instanceof Set;
        } catch (e) {}
        return !1;
    }
    a(PO, "isSet");
    function AO(t) {
        if (!mo || !t || typeof t != "object") return !1;
        try {
            mo.call(t, mo);
            try {
                po.call(t, po);
            } catch (e) {
                return !0;
            }
            return t instanceof WeakSet;
        } catch (e) {}
        return !1;
    }
    a(AO, "isWeakSet");
    function IO(t) {
        return !t || typeof t != "object" ? !1 : typeof HTMLElement < "u" && t instanceof HTMLElement ? !0 : typeof t.nodeName == "string" && typeof t.getAttribute == "function";
    }
    a(IO, "isElement");
    function Xy(t, e) {
        if (t.length > e.maxStringLength) {
            var r = t.length - e.maxStringLength, i = "... " + r + " more character" + (r > 1 ? "s" : "");
            return Xy(bu.call(t, 0, e.maxStringLength), e) + i;
        }
        var n = wO[e.quoteStyle || "single"];
        n.lastIndex = 0;
        var o = kr.call(kr.call(t, n, "\\$1"), /[\x00-\x1f]/g, DO);
        return Gy(o, "single", e);
    }
    a(Xy, "inspectString");
    function DO(t) {
        var e = t.charCodeAt(0), r = {
            8: "b",
            9: "t",
            10: "n",
            12: "f",
            13: "r"
        }[e];
        return r ? "\\" + r : "\\x" + (e < 16 ? "0" : "") + mO.call(e.toString(16));
    }
    a(DO, "lowbyte");
    function ho(t) {
        return "Object(" + t + ")";
    }
    a(ho, "markBoxed");
    function uu(t) {
        return t + " { ? }";
    }
    a(uu, "weakCollectionOf");
    function Hy(t, e, r, i) {
        var n = i ? yu(r, i) : Ht.call(r, ", ");
        return t + " (" + e + ") {" + n + "}";
    }
    a(Hy, "collectionOf");
    function CO(t) {
        for(var e = 0; e < t.length; e++)if (Zy(t[e], "\n") >= 0) return !1;
        return !0;
    }
    a(CO, "singleLineValues");
    function NO(t, e) {
        var r;
        if (t.indent === "	") r = "	";
        else if (typeof t.indent == "number" && t.indent > 0) r = Ht.call(Array(t.indent + 1), " ");
        else return null;
        return {
            base: r,
            prev: Ht.call(Array(e + 1), r)
        };
    }
    a(NO, "getIndent");
    function yu(t, e) {
        if (t.length === 0) return "";
        var r = "\n" + e.prev + e.base;
        return r + Ht.call(t, "," + r) + "\n" + e.prev;
    }
    a(yu, "indentedJoin");
    function wa(t, e) {
        var r = mu(t), i = [];
        if (r) {
            i.length = t.length;
            for(var n = 0; n < t.length; n++)i[n] = ar(t, n) ? e(t[n], t) : "";
        }
        var o = typeof fu == "function" ? fu(t) : [], s;
        if (Ji) {
            s = {};
            for(var l = 0; l < o.length; l++)s["$" + o[l]] = o[l];
        }
        for(var f in t)ar(t, f) && (r && String(Number(f)) === f && f < t.length || Ji && s["$" + f] instanceof Symbol || (zy.call(/[^\w$]/, f) ? i.push(e(f, t) + ": " + e(t[f], t)) : i.push(f + ": " + e(t[f], t))));
        if (typeof fu == "function") for(var c = 0; c < o.length; c++)Wy.call(t, o[c]) && i.push("[" + e(o[c]) + "]: " + e(t[o[c]], t));
        return i;
    }
    a(wa, "arrObjKeys");
});
var Qy = T(_c36 = (x8, Jy)=>{
    "use strict";
    var BO = wo(), LO = qt(), va = a(function(t, e, r) {
        for(var i = t, n; (n = i.next) != null; i = n)if (n.key === e) return i.next = n.next, r || (n.next = t.next, t.next = n), n;
    }, "listGetNode"), $O = a(function(t, e) {
        if (t) {
            var r = va(t, e);
            return r && r.value;
        }
    }, "listGet"), MO = a(function(t, e, r) {
        var i = va(t, e);
        i ? i.value = r : t.next = {
            key: e,
            next: t.next,
            value: r
        };
    }, "listSet"), jO = a(function(t, e) {
        return t ? !!va(t, e) : !1;
    }, "listHas"), UO = a(function(t, e) {
        if (t) return va(t, e, !0);
    }, "listDelete");
    Jy.exports = a(function() {
        var e, r = {
            assert: a(function(i) {
                if (!r.has(i)) throw new LO("Side channel does not contain " + BO(i));
            }, "assert"),
            delete: a(function(i) {
                var n = e && e.next, o = UO(e, i);
                return o && n && n === o && (e = void 0), !!o;
            }, "delete"),
            get: a(function(i) {
                return $O(e, i);
            }, "get"),
            has: a(function(i) {
                return jO(e, i);
            }, "has"),
            set: a(function(i, n) {
                e || (e = {
                    next: void 0
                }), MO(e, i, n);
            }, "set")
        };
        return r;
    }, "getSideChannelList");
});
_c37 = Qy;
var vu = T((O8, ew)=>{
    "use strict";
    ew.exports = Object;
});
var rw = T((R8, tw)=>{
    "use strict";
    tw.exports = Error;
});
var nw = T((k8, iw)=>{
    "use strict";
    iw.exports = EvalError;
});
var sw = T((P8, ow)=>{
    "use strict";
    ow.exports = RangeError;
});
var lw = T((A8, aw)=>{
    "use strict";
    aw.exports = ReferenceError;
});
var _u = T((I8, cw)=>{
    "use strict";
    cw.exports = SyntaxError;
});
var uw = T((D8, fw)=>{
    "use strict";
    fw.exports = URIError;
});
var dw = T((C8, hw)=>{
    "use strict";
    hw.exports = Math.abs;
});
var mw = T((N8, pw)=>{
    "use strict";
    pw.exports = Math.floor;
});
var ww = T((B8, yw)=>{
    "use strict";
    yw.exports = Math.max;
});
var bw = T((L8, gw)=>{
    "use strict";
    gw.exports = Math.min;
});
var _w = T(($8, vw)=>{
    "use strict";
    vw.exports = Math.pow;
});
var Ew = T(_c38 = (M8, Fw)=>{
    "use strict";
    Fw.exports = Math.round;
});
_c39 = Ew;
var xw = T((j8, Sw)=>{
    "use strict";
    Sw.exports = Number.isNaN || a(function(e) {
        return e !== e;
    }, "isNaN");
});
var Ow = T(_c40 = (q8, Tw)=>{
    "use strict";
    var qO = xw();
    Tw.exports = a(function(e) {
        return qO(e) || e === 0 ? e : e < 0 ? -1 : 1;
    }, "sign");
});
_c41 = Ow;
var kw = T((z8, Rw)=>{
    "use strict";
    Rw.exports = Object.getOwnPropertyDescriptor;
});
var Qi = T(_c42 = (W8, Pw)=>{
    "use strict";
    var _a = kw();
    if (_a) try {
        _a([], "length");
    } catch (e) {
        _a = null;
    }
    Pw.exports = _a;
});
_c43 = Qi;
var go = T((V8, Aw)=>{
    "use strict";
    var Fa = Object.defineProperty || !1;
    if (Fa) try {
        Fa({}, "a", {
            value: 1
        });
    } catch (e) {
        Fa = !1;
    }
    Aw.exports = Fa;
});
var Fu = T(_c44 = (G8, Iw)=>{
    "use strict";
    Iw.exports = a(function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
        if (typeof Symbol.iterator == "symbol") return !0;
        var e = {}, r = Symbol("test"), i = Object(r);
        if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]") return !1;
        var n = 42;
        e[r] = n;
        for(var o in e)return !1;
        if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return !1;
        var s = Object.getOwnPropertySymbols(e);
        if (s.length !== 1 || s[0] !== r || !Object.prototype.propertyIsEnumerable.call(e, r)) return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var l = Object.getOwnPropertyDescriptor(e, r);
            if (l.value !== n || l.enumerable !== !0) return !1;
        }
        return !0;
    }, "hasSymbols");
});
_c45 = Fu;
var Nw = T(_c46 = (Z8, Cw)=>{
    "use strict";
    var Dw = typeof Symbol < "u" && Symbol, HO = Fu();
    Cw.exports = a(function() {
        return typeof Dw != "function" || typeof Symbol != "function" || typeof Dw("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : HO();
    }, "hasNativeSymbols");
});
_c47 = Nw;
var Eu = T(_c48 = (Y8, Bw)=>{
    "use strict";
    Bw.exports = typeof Reflect < "u" && Reflect.getPrototypeOf || null;
});
_c49 = Eu;
var Su = T(_c50 = (J8, Lw)=>{
    "use strict";
    var zO = vu();
    Lw.exports = zO.getPrototypeOf || null;
});
_c51 = Su;
var jw = T((Q8, Mw)=>{
    "use strict";
    var WO = "Function.prototype.bind called on incompatible ", VO = Object.prototype.toString, GO = Math.max, KO = "[object Function]", $w = a(function(e, r) {
        for(var i = [], n = 0; n < e.length; n += 1)i[n] = e[n];
        for(var o = 0; o < r.length; o += 1)i[o + e.length] = r[o];
        return i;
    }, "concatty"), ZO = a(function(e, r) {
        for(var i = [], n = r || 0, o = 0; n < e.length; n += 1, o += 1)i[o] = e[n];
        return i;
    }, "slicy"), XO = a(function(t, e) {
        for(var r = "", i = 0; i < t.length; i += 1)r += t[i], i + 1 < t.length && (r += e);
        return r;
    }, "joiny");
    Mw.exports = a(function(e) {
        var r = this;
        if (typeof r != "function" || VO.apply(r) !== KO) throw new TypeError(WO + r);
        for(var i = ZO(arguments, 1), n, o = a(function() {
            if (this instanceof n) {
                var u = r.apply(this, $w(i, arguments));
                return Object(u) === u ? u : this;
            }
            return r.apply(e, $w(i, arguments));
        }, "binder"), s = GO(0, r.length - i.length), l = [], f = 0; f < s; f++)l[f] = "$" + f;
        if (n = Function("binder", "return function (" + XO(l, ",") + "){ return binder.apply(this,arguments); }")(o), r.prototype) {
            var c = a(function() {}, "Empty");
            c.prototype = r.prototype, n.prototype = new c, c.prototype = null;
        }
        return n;
    }, "bind");
});
var en = T((tj, Uw)=>{
    "use strict";
    var YO = jw();
    Uw.exports = Function.prototype.bind || YO;
});
var Ea = T(_c52 = (rj, qw)=>{
    "use strict";
    qw.exports = Function.prototype.call;
});
_c53 = Ea;
var Sa = T(_c54 = (ij, Hw)=>{
    "use strict";
    Hw.exports = Function.prototype.apply;
});
_c55 = Sa;
var Ww = T(_c56 = (nj, zw)=>{
    "use strict";
    zw.exports = typeof Reflect < "u" && Reflect && Reflect.apply;
});
_c57 = Ww;
var xu = T((oj, Vw)=>{
    "use strict";
    var JO = en(), QO = Sa(), eR = Ea(), tR = Ww();
    Vw.exports = tR || JO.call(eR, QO);
});
var xa = T((sj, Gw)=>{
    "use strict";
    var rR = en(), iR = qt(), nR = Ea(), oR = xu();
    Gw.exports = a(function(e) {
        if (e.length < 1 || typeof e[0] != "function") throw new iR("a function is required");
        return oR(rR, nR, e);
    }, "callBindBasic");
});
var Qw = T(_c58 = (lj, Jw)=>{
    "use strict";
    var sR = xa(), Kw = Qi(), Xw;
    try {
        Xw = [].__proto__ === Array.prototype;
    } catch (t) {
        if (!t || typeof t != "object" || !("code" in t) || t.code !== "ERR_PROTO_ACCESS") throw t;
    }
    var Tu = !!Xw && Kw && Kw(Object.prototype, "__proto__"), Yw = Object, Zw = Yw.getPrototypeOf;
    Jw.exports = Tu && typeof Tu.get == "function" ? sR([
        Tu.get
    ]) : typeof Zw == "function" ? a(function(e) {
        return Zw(e == null ? e : Yw(e));
    }, "getDunder") : !1;
});
_c59 = Qw;
var Ou = T(_c60 = (fj, i0)=>{
    "use strict";
    var e0 = Eu(), t0 = Su(), r0 = Qw();
    i0.exports = e0 ? a(function(e) {
        return e0(e);
    }, "getProto") : t0 ? a(function(e) {
        if (!e || typeof e != "object" && typeof e != "function") throw new TypeError("getProto: not an object");
        return t0(e);
    }, "getProto") : r0 ? a(function(e) {
        return r0(e);
    }, "getProto") : null;
});
_c61 = Ou;
var o0 = T((hj, n0)=>{
    "use strict";
    var aR = Function.prototype.call, lR = Object.prototype.hasOwnProperty, cR = en();
    n0.exports = cR.call(aR, lR);
});
var Fo = T(_c62 = (dj, u0)=>{
    "use strict";
    var J, fR = vu(), uR = rw(), hR = nw(), dR = sw(), pR = lw(), on = _u(), nn = qt(), mR = uw(), yR = dw(), wR = mw(), gR = ww(), bR = bw(), vR = _w(), _R = Ew(), FR = Ow(), c0 = Function, Ru = a(function(t) {
        try {
            return c0('"use strict"; return (' + t + ").constructor;")();
        } catch (e) {}
    }, "getEvalledConstructor"), bo = Qi(), ER = go(), ku = a(function() {
        throw new nn;
    }, "throwTypeError"), SR = bo ? function() {
        try {
            return arguments.callee, ku;
        } catch (e) {
            try {
                return bo(arguments, "callee").get;
            } catch (e) {
                return ku;
            }
        }
    }() : ku, tn = Nw()(), Ce = Ou(), xR = Su(), TR = Eu(), f0 = Sa(), vo = Ea(), rn = {}, OR = typeof Uint8Array > "u" || !Ce ? J : Ce(Uint8Array), oi = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError > "u" ? J : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? J : ArrayBuffer,
        "%ArrayIteratorPrototype%": tn && Ce ? Ce([][Symbol.iterator]()) : J,
        "%AsyncFromSyncIteratorPrototype%": J,
        "%AsyncFunction%": rn,
        "%AsyncGenerator%": rn,
        "%AsyncGeneratorFunction%": rn,
        "%AsyncIteratorPrototype%": rn,
        "%Atomics%": typeof Atomics > "u" ? J : Atomics,
        "%BigInt%": typeof BigInt > "u" ? J : BigInt,
        "%BigInt64Array%": typeof BigInt64Array > "u" ? J : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array > "u" ? J : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? J : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": uR,
        "%eval%": eval,
        "%EvalError%": hR,
        "%Float16Array%": typeof Float16Array > "u" ? J : Float16Array,
        "%Float32Array%": typeof Float32Array > "u" ? J : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? J : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? J : FinalizationRegistry,
        "%Function%": c0,
        "%GeneratorFunction%": rn,
        "%Int8Array%": typeof Int8Array > "u" ? J : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? J : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? J : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": tn && Ce ? Ce(Ce([][Symbol.iterator]())) : J,
        "%JSON%": typeof JSON == "object" ? JSON : J,
        "%Map%": typeof Map > "u" ? J : Map,
        "%MapIteratorPrototype%": typeof Map > "u" || !tn || !Ce ? J : Ce(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": fR,
        "%Object.getOwnPropertyDescriptor%": bo,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? J : Promise,
        "%Proxy%": typeof Proxy > "u" ? J : Proxy,
        "%RangeError%": dR,
        "%ReferenceError%": pR,
        "%Reflect%": typeof Reflect > "u" ? J : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? J : Set,
        "%SetIteratorPrototype%": typeof Set > "u" || !tn || !Ce ? J : Ce(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? J : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": tn && Ce ? Ce(""[Symbol.iterator]()) : J,
        "%Symbol%": tn ? Symbol : J,
        "%SyntaxError%": on,
        "%ThrowTypeError%": SR,
        "%TypedArray%": OR,
        "%TypeError%": nn,
        "%Uint8Array%": typeof Uint8Array > "u" ? J : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? J : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? J : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? J : Uint32Array,
        "%URIError%": mR,
        "%WeakMap%": typeof WeakMap > "u" ? J : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? J : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? J : WeakSet,
        "%Function.prototype.call%": vo,
        "%Function.prototype.apply%": f0,
        "%Object.defineProperty%": ER,
        "%Object.getPrototypeOf%": xR,
        "%Math.abs%": yR,
        "%Math.floor%": wR,
        "%Math.max%": gR,
        "%Math.min%": bR,
        "%Math.pow%": vR,
        "%Math.round%": _R,
        "%Math.sign%": FR,
        "%Reflect.getPrototypeOf%": TR
    };
    if (Ce) try {
        null.error;
    } catch (t) {
        s0 = Ce(Ce(t)), oi["%Error.prototype%"] = s0;
    }
    var s0, RR = a(function t(e) {
        var r;
        if (e === "%AsyncFunction%") r = Ru("async function () {}");
        else if (e === "%GeneratorFunction%") r = Ru("function* () {}");
        else if (e === "%AsyncGeneratorFunction%") r = Ru("async function* () {}");
        else if (e === "%AsyncGenerator%") {
            var i = t("%AsyncGeneratorFunction%");
            i && (r = i.prototype);
        } else if (e === "%AsyncIteratorPrototype%") {
            var n = t("%AsyncGenerator%");
            n && Ce && (r = Ce(n.prototype));
        }
        return oi[e] = r, r;
    }, "doEval"), a0 = {
        __proto__: null,
        "%ArrayBufferPrototype%": [
            "ArrayBuffer",
            "prototype"
        ],
        "%ArrayPrototype%": [
            "Array",
            "prototype"
        ],
        "%ArrayProto_entries%": [
            "Array",
            "prototype",
            "entries"
        ],
        "%ArrayProto_forEach%": [
            "Array",
            "prototype",
            "forEach"
        ],
        "%ArrayProto_keys%": [
            "Array",
            "prototype",
            "keys"
        ],
        "%ArrayProto_values%": [
            "Array",
            "prototype",
            "values"
        ],
        "%AsyncFunctionPrototype%": [
            "AsyncFunction",
            "prototype"
        ],
        "%AsyncGenerator%": [
            "AsyncGeneratorFunction",
            "prototype"
        ],
        "%AsyncGeneratorPrototype%": [
            "AsyncGeneratorFunction",
            "prototype",
            "prototype"
        ],
        "%BooleanPrototype%": [
            "Boolean",
            "prototype"
        ],
        "%DataViewPrototype%": [
            "DataView",
            "prototype"
        ],
        "%DatePrototype%": [
            "Date",
            "prototype"
        ],
        "%ErrorPrototype%": [
            "Error",
            "prototype"
        ],
        "%EvalErrorPrototype%": [
            "EvalError",
            "prototype"
        ],
        "%Float32ArrayPrototype%": [
            "Float32Array",
            "prototype"
        ],
        "%Float64ArrayPrototype%": [
            "Float64Array",
            "prototype"
        ],
        "%FunctionPrototype%": [
            "Function",
            "prototype"
        ],
        "%Generator%": [
            "GeneratorFunction",
            "prototype"
        ],
        "%GeneratorPrototype%": [
            "GeneratorFunction",
            "prototype",
            "prototype"
        ],
        "%Int8ArrayPrototype%": [
            "Int8Array",
            "prototype"
        ],
        "%Int16ArrayPrototype%": [
            "Int16Array",
            "prototype"
        ],
        "%Int32ArrayPrototype%": [
            "Int32Array",
            "prototype"
        ],
        "%JSONParse%": [
            "JSON",
            "parse"
        ],
        "%JSONStringify%": [
            "JSON",
            "stringify"
        ],
        "%MapPrototype%": [
            "Map",
            "prototype"
        ],
        "%NumberPrototype%": [
            "Number",
            "prototype"
        ],
        "%ObjectPrototype%": [
            "Object",
            "prototype"
        ],
        "%ObjProto_toString%": [
            "Object",
            "prototype",
            "toString"
        ],
        "%ObjProto_valueOf%": [
            "Object",
            "prototype",
            "valueOf"
        ],
        "%PromisePrototype%": [
            "Promise",
            "prototype"
        ],
        "%PromiseProto_then%": [
            "Promise",
            "prototype",
            "then"
        ],
        "%Promise_all%": [
            "Promise",
            "all"
        ],
        "%Promise_reject%": [
            "Promise",
            "reject"
        ],
        "%Promise_resolve%": [
            "Promise",
            "resolve"
        ],
        "%RangeErrorPrototype%": [
            "RangeError",
            "prototype"
        ],
        "%ReferenceErrorPrototype%": [
            "ReferenceError",
            "prototype"
        ],
        "%RegExpPrototype%": [
            "RegExp",
            "prototype"
        ],
        "%SetPrototype%": [
            "Set",
            "prototype"
        ],
        "%SharedArrayBufferPrototype%": [
            "SharedArrayBuffer",
            "prototype"
        ],
        "%StringPrototype%": [
            "String",
            "prototype"
        ],
        "%SymbolPrototype%": [
            "Symbol",
            "prototype"
        ],
        "%SyntaxErrorPrototype%": [
            "SyntaxError",
            "prototype"
        ],
        "%TypedArrayPrototype%": [
            "TypedArray",
            "prototype"
        ],
        "%TypeErrorPrototype%": [
            "TypeError",
            "prototype"
        ],
        "%Uint8ArrayPrototype%": [
            "Uint8Array",
            "prototype"
        ],
        "%Uint8ClampedArrayPrototype%": [
            "Uint8ClampedArray",
            "prototype"
        ],
        "%Uint16ArrayPrototype%": [
            "Uint16Array",
            "prototype"
        ],
        "%Uint32ArrayPrototype%": [
            "Uint32Array",
            "prototype"
        ],
        "%URIErrorPrototype%": [
            "URIError",
            "prototype"
        ],
        "%WeakMapPrototype%": [
            "WeakMap",
            "prototype"
        ],
        "%WeakSetPrototype%": [
            "WeakSet",
            "prototype"
        ]
    }, _o = en(), Ta = o0(), kR = _o.call(vo, Array.prototype.concat), PR = _o.call(f0, Array.prototype.splice), l0 = _o.call(vo, String.prototype.replace), Oa = _o.call(vo, String.prototype.slice), AR = _o.call(vo, RegExp.prototype.exec), IR = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, DR = /\\(\\)?/g, CR = a(function(e) {
        var r = Oa(e, 0, 1), i = Oa(e, -1);
        if (r === "%" && i !== "%") throw new on("invalid intrinsic syntax, expected closing `%`");
        if (i === "%" && r !== "%") throw new on("invalid intrinsic syntax, expected opening `%`");
        var n = [];
        return l0(e, IR, function(o, s, l, f) {
            n[n.length] = l ? l0(f, DR, "$1") : s || o;
        }), n;
    }, "stringToPath"), NR = a(function(e, r) {
        var i = e, n;
        if (Ta(a0, i) && (n = a0[i], i = "%" + n[0] + "%"), Ta(oi, i)) {
            var o = oi[i];
            if (o === rn && (o = RR(i)), typeof o > "u" && !r) throw new nn("intrinsic " + e + " exists, but is not available. Please file an issue!");
            return {
                alias: n,
                name: i,
                value: o
            };
        }
        throw new on("intrinsic " + e + " does not exist!");
    }, "getBaseIntrinsic");
    u0.exports = a(function(e, r) {
        if (typeof e != "string" || e.length === 0) throw new nn("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof r != "boolean") throw new nn('"allowMissing" argument must be a boolean');
        if (AR(/^%?[^%]*%?$/, e) === null) throw new on("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var i = CR(e), n = i.length > 0 ? i[0] : "", o = NR("%" + n + "%", r), s = o.name, l = o.value, f = !1, c = o.alias;
        c && (n = c[0], PR(i, kR([
            0,
            1
        ], c)));
        for(var u = 1, h = !0; u < i.length; u += 1){
            var d = i[u], p = Oa(d, 0, 1), m = Oa(d, -1);
            if ((p === '"' || p === "'" || p === "`" || m === '"' || m === "'" || m === "`") && p !== m) throw new on("property names with quotes must have matching quotes");
            if ((d === "constructor" || !h) && (f = !0), n += "." + d, s = "%" + n + "%", Ta(oi, s)) l = oi[s];
            else if (l != null) {
                if (!(d in l)) {
                    if (!r) throw new nn("base intrinsic for " + e + " exists, but the property is not available.");
                    return;
                }
                if (bo && u + 1 >= i.length) {
                    var y = bo(l, d);
                    h = !!y, h && "get" in y && !("originalValue" in y.get) ? l = y.get : l = l[d];
                } else h = Ta(l, d), l = l[d];
                h && !f && (oi[s] = l);
            }
        }
        return l;
    }, "GetIntrinsic");
});
_c63 = Fo;
var Eo = T(_c64 = (mj, p0)=>{
    "use strict";
    var h0 = Fo(), d0 = xa(), BR = d0([
        h0("%String.prototype.indexOf%")
    ]);
    p0.exports = a(function(e, r) {
        var i = h0(e, !!r);
        return typeof i == "function" && BR(e, ".prototype.") > -1 ? d0([
            i
        ]) : i;
    }, "callBoundIntrinsic");
});
_c65 = Eo;
var Pu = T(_c66 = (wj, y0)=>{
    "use strict";
    var LR = Fo(), So = Eo(), $R = wo(), MR = qt(), m0 = LR("%Map%", !0), jR = So("Map.prototype.get", !0), UR = So("Map.prototype.set", !0), qR = So("Map.prototype.has", !0), HR = So("Map.prototype.delete", !0), zR = So("Map.prototype.size", !0);
    y0.exports = !!m0 && a(function() {
        var e, r = {
            assert: a(function(i) {
                if (!r.has(i)) throw new MR("Side channel does not contain " + $R(i));
            }, "assert"),
            delete: a(function(i) {
                if (e) {
                    var n = HR(e, i);
                    return zR(e) === 0 && (e = void 0), n;
                }
                return !1;
            }, "delete"),
            get: a(function(i) {
                if (e) return jR(e, i);
            }, "get"),
            has: a(function(i) {
                return e ? qR(e, i) : !1;
            }, "has"),
            set: a(function(i, n) {
                e || (e = new m0), UR(e, i, n);
            }, "set")
        };
        return r;
    }, "getSideChannelMap");
});
_c67 = Pu;
var g0 = T((bj, w0)=>{
    "use strict";
    var WR = Fo(), ka = Eo(), VR = wo(), Ra = Pu(), GR = qt(), sn = WR("%WeakMap%", !0), KR = ka("WeakMap.prototype.get", !0), ZR = ka("WeakMap.prototype.set", !0), XR = ka("WeakMap.prototype.has", !0), YR = ka("WeakMap.prototype.delete", !0);
    w0.exports = sn ? a(function() {
        var e, r, i = {
            assert: a(function(n) {
                if (!i.has(n)) throw new GR("Side channel does not contain " + VR(n));
            }, "assert"),
            delete: a(function(n) {
                if (sn && n && (typeof n == "object" || typeof n == "function")) {
                    if (e) return YR(e, n);
                } else if (Ra && r) return r.delete(n);
                return !1;
            }, "delete"),
            get: a(function(n) {
                return sn && n && (typeof n == "object" || typeof n == "function") && e ? KR(e, n) : r && r.get(n);
            }, "get"),
            has: a(function(n) {
                return sn && n && (typeof n == "object" || typeof n == "function") && e ? XR(e, n) : !!r && r.has(n);
            }, "has"),
            set: a(function(n, o) {
                sn && n && (typeof n == "object" || typeof n == "function") ? (e || (e = new sn), ZR(e, n, o)) : Ra && (r || (r = Ra()), r.set(n, o));
            }, "set")
        };
        return i;
    }, "getSideChannelWeakMap") : Ra;
});
var v0 = T((_j, b0)=>{
    "use strict";
    var JR = qt(), QR = wo(), ek = Qy(), tk = Pu(), rk = g0(), ik = rk || tk || ek;
    b0.exports = a(function() {
        var e, r = {
            assert: a(function(i) {
                if (!r.has(i)) throw new JR("Side channel does not contain " + QR(i));
            }, "assert"),
            delete: a(function(i) {
                return !!e && e.delete(i);
            }, "delete"),
            get: a(function(i) {
                return e && e.get(i);
            }, "get"),
            has: a(function(i) {
                return !!e && e.has(i);
            }, "has"),
            set: a(function(i, n) {
                e || (e = ik()), e.set(i, n);
            }, "set")
        };
        return r;
    }, "getSideChannel");
});
var Pa = T(_c68 = (Ej, _0)=>{
    "use strict";
    var nk = String.prototype.replace, ok = /%20/g, Au = {
        RFC1738: "RFC1738",
        RFC3986: "RFC3986"
    };
    _0.exports = {
        default: Au.RFC3986,
        formatters: {
            RFC1738: a(function(t) {
                return nk.call(t, ok, "+");
            }, "RFC1738"),
            RFC3986: a(function(t) {
                return String(t);
            }, "RFC3986")
        },
        RFC1738: Au.RFC1738,
        RFC3986: Au.RFC3986
    };
});
_c69 = Pa;
var Cu = T(_c70 = (xj, E0)=>{
    "use strict";
    var sk = Pa(), Iu = Object.prototype.hasOwnProperty, si = Array.isArray, zt = function() {
        for(var t = [], e = 0; e < 256; ++e)t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
        return t;
    }(), ak = a(function(e) {
        for(; e.length > 1;){
            var r = e.pop(), i = r.obj[r.prop];
            if (si(i)) {
                for(var n = [], o = 0; o < i.length; ++o)typeof i[o] < "u" && n.push(i[o]);
                r.obj[r.prop] = n;
            }
        }
    }, "compactQueue"), F0 = a(function(e, r) {
        for(var i = r && r.plainObjects ? {
            __proto__: null
        } : {}, n = 0; n < e.length; ++n)typeof e[n] < "u" && (i[n] = e[n]);
        return i;
    }, "arrayToObject"), lk = a(function t(e, r, i) {
        if (!r) return e;
        if (typeof r != "object" && typeof r != "function") {
            if (si(e)) e.push(r);
            else if (e && typeof e == "object") (i && (i.plainObjects || i.allowPrototypes) || !Iu.call(Object.prototype, r)) && (e[r] = !0);
            else return [
                e,
                r
            ];
            return e;
        }
        if (!e || typeof e != "object") return [
            e
        ].concat(r);
        var n = e;
        return si(e) && !si(r) && (n = F0(e, i)), si(e) && si(r) ? (r.forEach(function(o, s) {
            if (Iu.call(e, s)) {
                var l = e[s];
                l && typeof l == "object" && o && typeof o == "object" ? e[s] = t(l, o, i) : e.push(o);
            } else e[s] = o;
        }), e) : Object.keys(r).reduce(function(o, s) {
            var l = r[s];
            return Iu.call(o, s) ? o[s] = t(o[s], l, i) : o[s] = l, o;
        }, n);
    }, "merge"), ck = a(function(e, r) {
        return Object.keys(r).reduce(function(i, n) {
            return i[n] = r[n], i;
        }, e);
    }, "assignSingleSource"), fk = a(function(t, e, r) {
        var i = t.replace(/\+/g, " ");
        if (r === "iso-8859-1") return i.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
            return decodeURIComponent(i);
        } catch (e) {
            return i;
        }
    }, "decode"), Du = 1024, uk = a(function(e, r, i, n, o) {
        if (e.length === 0) return e;
        var s = e;
        if (typeof e == "symbol" ? s = Symbol.prototype.toString.call(e) : typeof e != "string" && (s = String(e)), i === "iso-8859-1") return escape(s).replace(/%u[0-9a-f]{4}/gi, function(p) {
            return "%26%23" + parseInt(p.slice(2), 16) + "%3B";
        });
        for(var l = "", f = 0; f < s.length; f += Du){
            for(var c = s.length >= Du ? s.slice(f, f + Du) : s, u = [], h = 0; h < c.length; ++h){
                var d = c.charCodeAt(h);
                if (d === 45 || d === 46 || d === 95 || d === 126 || d >= 48 && d <= 57 || d >= 65 && d <= 90 || d >= 97 && d <= 122 || o === sk.RFC1738 && (d === 40 || d === 41)) {
                    u[u.length] = c.charAt(h);
                    continue;
                }
                if (d < 128) {
                    u[u.length] = zt[d];
                    continue;
                }
                if (d < 2048) {
                    u[u.length] = zt[192 | d >> 6] + zt[128 | d & 63];
                    continue;
                }
                if (d < 55296 || d >= 57344) {
                    u[u.length] = zt[224 | d >> 12] + zt[128 | d >> 6 & 63] + zt[128 | d & 63];
                    continue;
                }
                h += 1, d = 65536 + ((d & 1023) << 10 | c.charCodeAt(h) & 1023), u[u.length] = zt[240 | d >> 18] + zt[128 | d >> 12 & 63] + zt[128 | d >> 6 & 63] + zt[128 | d & 63];
            }
            l += u.join("");
        }
        return l;
    }, "encode"), hk = a(function(e) {
        for(var r = [
            {
                obj: {
                    o: e
                },
                prop: "o"
            }
        ], i = [], n = 0; n < r.length; ++n)for(var o = r[n], s = o.obj[o.prop], l = Object.keys(s), f = 0; f < l.length; ++f){
            var c = l[f], u = s[c];
            typeof u == "object" && u !== null && i.indexOf(u) === -1 && (r.push({
                obj: s,
                prop: c
            }), i.push(u));
        }
        return ak(r), e;
    }, "compact"), dk = a(function(e) {
        return Object.prototype.toString.call(e) === "[object RegExp]";
    }, "isRegExp"), pk = a(function(e) {
        return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e));
    }, "isBuffer"), mk = a(function(e, r) {
        return [].concat(e, r);
    }, "combine"), yk = a(function(e, r) {
        if (si(e)) {
            for(var i = [], n = 0; n < e.length; n += 1)i.push(r(e[n]));
            return i;
        }
        return r(e);
    }, "maybeMap");
    E0.exports = {
        arrayToObject: F0,
        assign: ck,
        combine: mk,
        compact: hk,
        decode: fk,
        encode: uk,
        isBuffer: pk,
        isRegExp: dk,
        maybeMap: yk,
        merge: lk
    };
});
_c71 = Cu;
var k0 = T((Oj, R0)=>{
    "use strict";
    var x0 = v0(), Aa = Cu(), xo = Pa(), wk = Object.prototype.hasOwnProperty, T0 = {
        brackets: a(function(e) {
            return e + "[]";
        }, "brackets"),
        comma: "comma",
        indices: a(function(e, r) {
            return e + "[" + r + "]";
        }, "indices"),
        repeat: a(function(e) {
            return e;
        }, "repeat")
    }, Wt = Array.isArray, gk = Array.prototype.push, O0 = a(function(t, e) {
        gk.apply(t, Wt(e) ? e : [
            e
        ]);
    }, "pushToArray"), bk = Date.prototype.toISOString, S0 = xo.default, ke = {
        addQueryPrefix: !1,
        allowDots: !1,
        allowEmptyArrays: !1,
        arrayFormat: "indices",
        charset: "utf-8",
        charsetSentinel: !1,
        commaRoundTrip: !1,
        delimiter: "&",
        encode: !0,
        encodeDotInKeys: !1,
        encoder: Aa.encode,
        encodeValuesOnly: !1,
        filter: void 0,
        format: S0,
        formatter: xo.formatters[S0],
        indices: !1,
        serializeDate: a(function(e) {
            return bk.call(e);
        }, "serializeDate"),
        skipNulls: !1,
        strictNullHandling: !1
    }, vk = a(function(e) {
        return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint";
    }, "isNonNullishPrimitive"), Nu = {}, _k = a(function t(e, r, i, n, o, s, l, f, c, u, h, d, p, m, y, w, v, g) {
        for(var F = e, O = g, S = 0, R = !1; (O = O.get(Nu)) !== void 0 && !R;){
            var b = O.get(e);
            if (S += 1, typeof b < "u") {
                if (b === S) throw new RangeError("Cyclic object value");
                R = !0;
            }
            typeof O.get(Nu) > "u" && (S = 0);
        }
        if (typeof u == "function" ? F = u(r, F) : F instanceof Date ? F = p(F) : i === "comma" && Wt(F) && (F = Aa.maybeMap(F, function(G) {
            return G instanceof Date ? p(G) : G;
        })), F === null) {
            if (s) return c && !w ? c(r, ke.encoder, v, "key", m) : r;
            F = "";
        }
        if (vk(F) || Aa.isBuffer(F)) {
            if (c) {
                var x = w ? r : c(r, ke.encoder, v, "key", m);
                return [
                    y(x) + "=" + y(c(F, ke.encoder, v, "value", m))
                ];
            }
            return [
                y(r) + "=" + y(String(F))
            ];
        }
        var _ = [];
        if (typeof F > "u") return _;
        var P;
        if (i === "comma" && Wt(F)) w && c && (F = Aa.maybeMap(F, c)), P = [
            {
                value: F.length > 0 ? F.join(",") || null : void 0
            }
        ];
        else if (Wt(u)) P = u;
        else {
            var k = Object.keys(F);
            P = h ? k.sort(h) : k;
        }
        var C = f ? String(r).replace(/\./g, "%2E") : String(r), N = n && Wt(F) && F.length === 1 ? C + "[]" : C;
        if (o && Wt(F) && F.length === 0) return N + "[]";
        for(var U = 0; U < P.length; ++U){
            var Z = P[U], me = typeof Z == "object" && Z && typeof Z.value < "u" ? Z.value : F[Z];
            if (!(l && me === null)) {
                var Ee = d && f ? String(Z).replace(/\./g, "%2E") : String(Z), $ = Wt(F) ? typeof i == "function" ? i(N, Ee) : N : N + (d ? "." + Ee : "[" + Ee + "]");
                g.set(e, S);
                var H = x0();
                H.set(Nu, g), O0(_, t(me, $, i, n, o, s, l, f, i === "comma" && w && Wt(F) ? null : c, u, h, d, p, m, y, w, v, H));
            }
        }
        return _;
    }, "stringify"), Fk = a(function(e) {
        if (!e) return ke;
        if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof e.encodeDotInKeys < "u" && typeof e.encodeDotInKeys != "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
        if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function") throw new TypeError("Encoder has to be a function.");
        var r = e.charset || ke.charset;
        if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var i = xo.default;
        if (typeof e.format < "u") {
            if (!wk.call(xo.formatters, e.format)) throw new TypeError("Unknown format option provided.");
            i = e.format;
        }
        var n = xo.formatters[i], o = ke.filter;
        (typeof e.filter == "function" || Wt(e.filter)) && (o = e.filter);
        var s;
        if (e.arrayFormat in T0 ? s = e.arrayFormat : "indices" in e ? s = e.indices ? "indices" : "repeat" : s = ke.arrayFormat, "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        var l = typeof e.allowDots > "u" ? e.encodeDotInKeys === !0 ? !0 : ke.allowDots : !!e.allowDots;
        return {
            addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : ke.addQueryPrefix,
            allowDots: l,
            allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : ke.allowEmptyArrays,
            arrayFormat: s,
            charset: r,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : ke.charsetSentinel,
            commaRoundTrip: !!e.commaRoundTrip,
            delimiter: typeof e.delimiter > "u" ? ke.delimiter : e.delimiter,
            encode: typeof e.encode == "boolean" ? e.encode : ke.encode,
            encodeDotInKeys: typeof e.encodeDotInKeys == "boolean" ? e.encodeDotInKeys : ke.encodeDotInKeys,
            encoder: typeof e.encoder == "function" ? e.encoder : ke.encoder,
            encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : ke.encodeValuesOnly,
            filter: o,
            format: i,
            formatter: n,
            serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : ke.serializeDate,
            skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : ke.skipNulls,
            sort: typeof e.sort == "function" ? e.sort : null,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : ke.strictNullHandling
        };
    }, "normalizeStringifyOptions");
    R0.exports = function(t, e) {
        var r = t, i = Fk(e), n, o;
        typeof i.filter == "function" ? (o = i.filter, r = o("", r)) : Wt(i.filter) && (o = i.filter, n = o);
        var s = [];
        if (typeof r != "object" || r === null) return "";
        var l = T0[i.arrayFormat], f = l === "comma" && i.commaRoundTrip;
        n || (n = Object.keys(r)), i.sort && n.sort(i.sort);
        for(var c = x0(), u = 0; u < n.length; ++u){
            var h = n[u], d = r[h];
            i.skipNulls && d === null || O0(s, _k(d, h, l, f, i.allowEmptyArrays, i.strictNullHandling, i.skipNulls, i.encodeDotInKeys, i.encode ? i.encoder : null, i.filter, i.sort, i.allowDots, i.serializeDate, i.format, i.formatter, i.encodeValuesOnly, i.charset, c));
        }
        var p = s.join(i.delimiter), m = i.addQueryPrefix === !0 ? "?" : "";
        return i.charsetSentinel && (i.charset === "iso-8859-1" ? m += "utf8=%26%2310003%3B&" : m += "utf8=%E2%9C%93&"), p.length > 0 ? m + p : "";
    };
});
var D0 = T(_c72 = (kj, I0)=>{
    "use strict";
    var ai = Cu(), Bu = Object.prototype.hasOwnProperty, P0 = Array.isArray, we = {
        allowDots: !1,
        allowEmptyArrays: !1,
        allowPrototypes: !1,
        allowSparse: !1,
        arrayLimit: 20,
        charset: "utf-8",
        charsetSentinel: !1,
        comma: !1,
        decodeDotInKeys: !1,
        decoder: ai.decode,
        delimiter: "&",
        depth: 5,
        duplicates: "combine",
        ignoreQueryPrefix: !1,
        interpretNumericEntities: !1,
        parameterLimit: 1e3,
        parseArrays: !0,
        plainObjects: !1,
        strictDepth: !1,
        strictNullHandling: !1,
        throwOnLimitExceeded: !1
    }, Ek = a(function(t) {
        return t.replace(/&#(\d+);/g, function(e, r) {
            return String.fromCharCode(parseInt(r, 10));
        });
    }, "interpretNumericEntities"), A0 = a(function(t, e, r) {
        if (t && typeof t == "string" && e.comma && t.indexOf(",") > -1) return t.split(",");
        if (e.throwOnLimitExceeded && r >= e.arrayLimit) throw new RangeError("Array limit exceeded. Only " + e.arrayLimit + " element" + (e.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
        return t;
    }, "parseArrayValue"), Sk = "utf8=%26%2310003%3B", xk = "utf8=%E2%9C%93", Tk = a(function(e, r) {
        var i = {
            __proto__: null
        }, n = r.ignoreQueryPrefix ? e.replace(/^\?/, "") : e;
        n = n.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
        var o = r.parameterLimit === 1 / 0 ? void 0 : r.parameterLimit, s = n.split(r.delimiter, r.throwOnLimitExceeded ? o + 1 : o);
        if (r.throwOnLimitExceeded && s.length > o) throw new RangeError("Parameter limit exceeded. Only " + o + " parameter" + (o === 1 ? "" : "s") + " allowed.");
        var l = -1, f, c = r.charset;
        if (r.charsetSentinel) for(f = 0; f < s.length; ++f)s[f].indexOf("utf8=") === 0 && (s[f] === xk ? c = "utf-8" : s[f] === Sk && (c = "iso-8859-1"), l = f, f = s.length);
        for(f = 0; f < s.length; ++f)if (f !== l) {
            var u = s[f], h = u.indexOf("]="), d = h === -1 ? u.indexOf("=") : h + 1, p, m;
            d === -1 ? (p = r.decoder(u, we.decoder, c, "key"), m = r.strictNullHandling ? null : "") : (p = r.decoder(u.slice(0, d), we.decoder, c, "key"), m = ai.maybeMap(A0(u.slice(d + 1), r, P0(i[p]) ? i[p].length : 0), function(w) {
                return r.decoder(w, we.decoder, c, "value");
            })), m && r.interpretNumericEntities && c === "iso-8859-1" && (m = Ek(String(m))), u.indexOf("[]=") > -1 && (m = P0(m) ? [
                m
            ] : m);
            var y = Bu.call(i, p);
            y && r.duplicates === "combine" ? i[p] = ai.combine(i[p], m) : (!y || r.duplicates === "last") && (i[p] = m);
        }
        return i;
    }, "parseQueryStringValues"), Ok = a(function(t, e, r, i) {
        var n = 0;
        if (t.length > 0 && t[t.length - 1] === "[]") {
            var o = t.slice(0, -1).join("");
            n = Array.isArray(e) && e[o] ? e[o].length : 0;
        }
        for(var s = i ? e : A0(e, r, n), l = t.length - 1; l >= 0; --l){
            var f, c = t[l];
            if (c === "[]" && r.parseArrays) f = r.allowEmptyArrays && (s === "" || r.strictNullHandling && s === null) ? [] : ai.combine([], s);
            else {
                f = r.plainObjects ? {
                    __proto__: null
                } : {};
                var u = c.charAt(0) === "[" && c.charAt(c.length - 1) === "]" ? c.slice(1, -1) : c, h = r.decodeDotInKeys ? u.replace(/%2E/g, ".") : u, d = parseInt(h, 10);
                !r.parseArrays && h === "" ? f = {
                    0: s
                } : !isNaN(d) && c !== h && String(d) === h && d >= 0 && r.parseArrays && d <= r.arrayLimit ? (f = [], f[d] = s) : h !== "__proto__" && (f[h] = s);
            }
            s = f;
        }
        return s;
    }, "parseObject"), Rk = a(function(e, r, i, n) {
        if (e) {
            var o = i.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e, s = /(\[[^[\]]*])/, l = /(\[[^[\]]*])/g, f = i.depth > 0 && s.exec(o), c = f ? o.slice(0, f.index) : o, u = [];
            if (c) {
                if (!i.plainObjects && Bu.call(Object.prototype, c) && !i.allowPrototypes) return;
                u.push(c);
            }
            for(var h = 0; i.depth > 0 && (f = l.exec(o)) !== null && h < i.depth;){
                if (h += 1, !i.plainObjects && Bu.call(Object.prototype, f[1].slice(1, -1)) && !i.allowPrototypes) return;
                u.push(f[1]);
            }
            if (f) {
                if (i.strictDepth === !0) throw new RangeError("Input depth exceeded depth option of " + i.depth + " and strictDepth is true");
                u.push("[" + o.slice(f.index) + "]");
            }
            return Ok(u, r, i, n);
        }
    }, "parseQueryStringKeys"), kk = a(function(e) {
        if (!e) return we;
        if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof e.decodeDotInKeys < "u" && typeof e.decodeDotInKeys != "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
        if (e.decoder !== null && typeof e.decoder < "u" && typeof e.decoder != "function") throw new TypeError("Decoder has to be a function.");
        if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        if (typeof e.throwOnLimitExceeded < "u" && typeof e.throwOnLimitExceeded != "boolean") throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
        var r = typeof e.charset > "u" ? we.charset : e.charset, i = typeof e.duplicates > "u" ? we.duplicates : e.duplicates;
        if (i !== "combine" && i !== "first" && i !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
        var n = typeof e.allowDots > "u" ? e.decodeDotInKeys === !0 ? !0 : we.allowDots : !!e.allowDots;
        return {
            allowDots: n,
            allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : we.allowEmptyArrays,
            allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : we.allowPrototypes,
            allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : we.allowSparse,
            arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : we.arrayLimit,
            charset: r,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : we.charsetSentinel,
            comma: typeof e.comma == "boolean" ? e.comma : we.comma,
            decodeDotInKeys: typeof e.decodeDotInKeys == "boolean" ? e.decodeDotInKeys : we.decodeDotInKeys,
            decoder: typeof e.decoder == "function" ? e.decoder : we.decoder,
            delimiter: typeof e.delimiter == "string" || ai.isRegExp(e.delimiter) ? e.delimiter : we.delimiter,
            depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : we.depth,
            duplicates: i,
            ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
            interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : we.interpretNumericEntities,
            parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : we.parameterLimit,
            parseArrays: e.parseArrays !== !1,
            plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : we.plainObjects,
            strictDepth: typeof e.strictDepth == "boolean" ? !!e.strictDepth : we.strictDepth,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : we.strictNullHandling,
            throwOnLimitExceeded: typeof e.throwOnLimitExceeded == "boolean" ? e.throwOnLimitExceeded : !1
        };
    }, "normalizeParseOptions");
    I0.exports = function(t, e) {
        var r = kk(e);
        if (t === "" || t === null || typeof t > "u") return r.plainObjects ? {
            __proto__: null
        } : {};
        for(var i = typeof t == "string" ? Tk(t, r) : t, n = r.plainObjects ? {
            __proto__: null
        } : {}, o = Object.keys(i), s = 0; s < o.length; ++s){
            var l = o[s], f = Rk(l, i[l], r, typeof t == "string");
            n = ai.merge(n, f, r);
        }
        return r.allowSparse === !0 ? n : ai.compact(n);
    };
});
_c73 = D0;
var N0 = T(_c74 = (Aj, C0)=>{
    "use strict";
    var Pk = k0(), Ak = D0(), Ik = Pa();
    C0.exports = {
        formats: Ik,
        parse: Ak,
        stringify: Pk
    };
});
_c75 = N0;
var Oo = T(_c76 = (ln)=>{
    "use strict";
    var Dk = ky();
    function dt() {
        this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
    }
    a(dt, "Url");
    var Ck = /^([a-z0-9.+-]+:)/i, Nk = /:[0-9]*$/, Bk = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, Lk = [
        "<",
        ">",
        '"',
        "`",
        " ",
        "\r",
        "\n",
        "	"
    ], $k = [
        "{",
        "}",
        "|",
        "\\",
        "^",
        "`"
    ].concat(Lk), Lu = [
        "'"
    ].concat($k), B0 = [
        "%",
        "/",
        "?",
        ";",
        "#"
    ].concat(Lu), L0 = [
        "/",
        "?",
        "#"
    ], Mk = 255, $0 = /^[+a-z0-9A-Z_-]{0,63}$/, jk = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, Uk = {
        javascript: !0,
        "javascript:": !0
    }, $u = {
        javascript: !0,
        "javascript:": !0
    }, an = {
        http: !0,
        https: !0,
        ftp: !0,
        gopher: !0,
        file: !0,
        "http:": !0,
        "https:": !0,
        "ftp:": !0,
        "gopher:": !0,
        "file:": !0
    }, Mu = N0();
    function To(t, e, r) {
        if (t && typeof t == "object" && t instanceof dt) return t;
        var i = new dt;
        return i.parse(t, e, r), i;
    }
    a(To, "urlParse");
    dt.prototype.parse = function(t, e, r) {
        if (typeof t != "string") throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
        var i = t.indexOf("?"), n = i !== -1 && i < t.indexOf("#") ? "?" : "#", o = t.split(n), s = /\\/g;
        o[0] = o[0].replace(s, "/"), t = o.join(n);
        var l = t;
        if (l = l.trim(), !r && t.split("#").length === 1) {
            var f = Bk.exec(l);
            if (f) return this.path = l, this.href = l, this.pathname = f[1], f[2] ? (this.search = f[2], e ? this.query = Mu.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : e && (this.search = "", this.query = {}), this;
        }
        var c = Ck.exec(l);
        if (c) {
            c = c[0];
            var u = c.toLowerCase();
            this.protocol = u, l = l.substr(c.length);
        }
        if (r || c || l.match(/^\/\/[^@/]+@[^@/]+/)) {
            var h = l.substr(0, 2) === "//";
            h && !(c && $u[c]) && (l = l.substr(2), this.slashes = !0);
        }
        if (!$u[c] && (h || c && !an[c])) {
            for(var d = -1, p = 0; p < L0.length; p++){
                var m = l.indexOf(L0[p]);
                m !== -1 && (d === -1 || m < d) && (d = m);
            }
            var y, w;
            d === -1 ? w = l.lastIndexOf("@") : w = l.lastIndexOf("@", d), w !== -1 && (y = l.slice(0, w), l = l.slice(w + 1), this.auth = decodeURIComponent(y)), d = -1;
            for(var p = 0; p < B0.length; p++){
                var m = l.indexOf(B0[p]);
                m !== -1 && (d === -1 || m < d) && (d = m);
            }
            d === -1 && (d = l.length), this.host = l.slice(0, d), l = l.slice(d), this.parseHost(), this.hostname = this.hostname || "";
            var v = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
            if (!v) for(var g = this.hostname.split(/\./), p = 0, F = g.length; p < F; p++){
                var O = g[p];
                if (O && !O.match($0)) {
                    for(var S = "", R = 0, b = O.length; R < b; R++)O.charCodeAt(R) > 127 ? S += "x" : S += O[R];
                    if (!S.match($0)) {
                        var x = g.slice(0, p), _ = g.slice(p + 1), P = O.match(jk);
                        P && (x.push(P[1]), _.unshift(P[2])), _.length && (l = "/" + _.join(".") + l), this.hostname = x.join(".");
                        break;
                    }
                }
            }
            this.hostname.length > Mk ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), v || (this.hostname = Dk.toASCII(this.hostname));
            var k = this.port ? ":" + this.port : "", C = this.hostname || "";
            this.host = C + k, this.href += this.host, v && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), l[0] !== "/" && (l = "/" + l));
        }
        if (!Uk[u]) for(var p = 0, F = Lu.length; p < F; p++){
            var N = Lu[p];
            if (l.indexOf(N) !== -1) {
                var U = encodeURIComponent(N);
                U === N && (U = escape(N)), l = l.split(N).join(U);
            }
        }
        var Z = l.indexOf("#");
        Z !== -1 && (this.hash = l.substr(Z), l = l.slice(0, Z));
        var me = l.indexOf("?");
        if (me !== -1 ? (this.search = l.substr(me), this.query = l.substr(me + 1), e && (this.query = Mu.parse(this.query)), l = l.slice(0, me)) : e && (this.search = "", this.query = {}), l && (this.pathname = l), an[u] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
            var k = this.pathname || "", Ee = this.search || "";
            this.path = k + Ee;
        }
        return this.href = this.format(), this;
    };
    function qk(t) {
        return typeof t == "string" && (t = To(t)), t instanceof dt ? t.format() : dt.prototype.format.call(t);
    }
    a(qk, "urlFormat");
    dt.prototype.format = function() {
        var t = this.auth || "";
        t && (t = encodeURIComponent(t), t = t.replace(/%3A/i, ":"), t += "@");
        var e = this.protocol || "", r = this.pathname || "", i = this.hash || "", n = !1, o = "";
        this.host ? n = t + this.host : this.hostname && (n = t + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (n += ":" + this.port)), this.query && typeof this.query == "object" && Object.keys(this.query).length && (o = Mu.stringify(this.query, {
            arrayFormat: "repeat",
            addQueryPrefix: !1
        }));
        var s = this.search || o && "?" + o || "";
        return e && e.substr(-1) !== ":" && (e += ":"), this.slashes || (!e || an[e]) && n !== !1 ? (n = "//" + (n || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : n || (n = ""), i && i.charAt(0) !== "#" && (i = "#" + i), s && s.charAt(0) !== "?" && (s = "?" + s), r = r.replace(/[?#]/g, function(l) {
            return encodeURIComponent(l);
        }), s = s.replace("#", "%23"), e + n + r + s + i;
    };
    function Hk(t, e) {
        return To(t, !1, !0).resolve(e);
    }
    a(Hk, "urlResolve");
    dt.prototype.resolve = function(t) {
        return this.resolveObject(To(t, !1, !0)).format();
    };
    function zk(t, e) {
        return t ? To(t, !1, !0).resolveObject(e) : e;
    }
    a(zk, "urlResolveObject");
    dt.prototype.resolveObject = function(t) {
        if (typeof t == "string") {
            var e = new dt;
            e.parse(t, !1, !0), t = e;
        }
        for(var r = new dt, i = Object.keys(this), n = 0; n < i.length; n++){
            var o = i[n];
            r[o] = this[o];
        }
        if (r.hash = t.hash, t.href === "") return r.href = r.format(), r;
        if (t.slashes && !t.protocol) {
            for(var s = Object.keys(t), l = 0; l < s.length; l++){
                var f = s[l];
                f !== "protocol" && (r[f] = t[f]);
            }
            return an[r.protocol] && r.hostname && !r.pathname && (r.pathname = "/", r.path = r.pathname), r.href = r.format(), r;
        }
        if (t.protocol && t.protocol !== r.protocol) {
            if (!an[t.protocol]) {
                for(var c = Object.keys(t), u = 0; u < c.length; u++){
                    var h = c[u];
                    r[h] = t[h];
                }
                return r.href = r.format(), r;
            }
            if (r.protocol = t.protocol, !t.host && !$u[t.protocol]) {
                for(var F = (t.pathname || "").split("/"); F.length && !(t.host = F.shift()););
                t.host || (t.host = ""), t.hostname || (t.hostname = ""), F[0] !== "" && F.unshift(""), F.length < 2 && F.unshift(""), r.pathname = F.join("/");
            } else r.pathname = t.pathname;
            if (r.search = t.search, r.query = t.query, r.host = t.host || "", r.auth = t.auth, r.hostname = t.hostname || t.host, r.port = t.port, r.pathname || r.search) {
                var d = r.pathname || "", p = r.search || "";
                r.path = d + p;
            }
            return r.slashes = r.slashes || t.slashes, r.href = r.format(), r;
        }
        var m = r.pathname && r.pathname.charAt(0) === "/", y = t.host || t.pathname && t.pathname.charAt(0) === "/", w = y || m || r.host && t.pathname, v = w, g = r.pathname && r.pathname.split("/") || [], F = t.pathname && t.pathname.split("/") || [], O = r.protocol && !an[r.protocol];
        if (O && (r.hostname = "", r.port = null, r.host && (g[0] === "" ? g[0] = r.host : g.unshift(r.host)), r.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && (F[0] === "" ? F[0] = t.host : F.unshift(t.host)), t.host = null), w = w && (F[0] === "" || g[0] === "")), y) r.host = t.host || t.host === "" ? t.host : r.host, r.hostname = t.hostname || t.hostname === "" ? t.hostname : r.hostname, r.search = t.search, r.query = t.query, g = F;
        else if (F.length) g || (g = []), g.pop(), g = g.concat(F), r.search = t.search, r.query = t.query;
        else if (t.search != null) {
            if (O) {
                r.host = g.shift(), r.hostname = r.host;
                var S = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
                S && (r.auth = S.shift(), r.hostname = S.shift(), r.host = r.hostname);
            }
            return r.search = t.search, r.query = t.query, (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
        }
        if (!g.length) return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
        for(var R = g.slice(-1)[0], b = (r.host || t.host || g.length > 1) && (R === "." || R === "..") || R === "", x = 0, _ = g.length; _ >= 0; _--)R = g[_], R === "." ? g.splice(_, 1) : R === ".." ? (g.splice(_, 1), x++) : x && (g.splice(_, 1), x--);
        if (!w && !v) for(; x--; x)g.unshift("..");
        w && g[0] !== "" && (!g[0] || g[0].charAt(0) !== "/") && g.unshift(""), b && g.join("/").substr(-1) !== "/" && g.push("");
        var P = g[0] === "" || g[0] && g[0].charAt(0) === "/";
        if (O) {
            r.hostname = P ? "" : g.length ? g.shift() : "", r.host = r.hostname;
            var S = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
            S && (r.auth = S.shift(), r.hostname = S.shift(), r.host = r.hostname);
        }
        return w = w || r.host && g.length, w && !P && g.unshift(""), g.length > 0 ? r.pathname = g.join("/") : (r.pathname = null, r.path = null), (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = t.auth || r.auth, r.slashes = r.slashes || t.slashes, r.href = r.format(), r;
    };
    dt.prototype.parseHost = function() {
        var t = this.host, e = Nk.exec(t);
        e && (e = e[0], e !== ":" && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t);
    };
    ln.parse = To;
    ln.resolve = Hk;
    ln.resolveObject = zk;
    ln.format = qk;
    ln.Url = dt;
});
_c77 = Oo;
var Ar = T(_c78 = (Pe)=>{
    "use strict";
    Object.defineProperty(Pe, "__esModule", {
        value: !0
    });
    Pe.getWriteSyncArgs = Pe.getWriteArgs = Pe.bufToUint8 = void 0;
    Pe.promisify = Vk;
    Pe.validateCallback = M0;
    Pe.modeToNumber = j0;
    Pe.nullCheck = U0;
    Pe.pathToFilename = Zk;
    Pe.createError = uP;
    Pe.genRndStr6 = hP;
    Pe.flagsToNumber = dP;
    Pe.streamToBuffer = pP;
    Pe.bufferToEncoding = gP;
    Pe.isReadableStream = bP;
    var Ro = Zi(), ju = lo(), Uu = Tr(), Wk = au(), Ia = ya();
    function Vk(t, e) {
        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (i)=>i;
        return function() {
            for(var _len = arguments.length, i = new Array(_len), _key = 0; _key < _len; _key++){
                i[_key] = arguments[_key];
            }
            return new Promise((n, o)=>{
                t[e].bind(t)(...i, (s, l)=>s ? o(s) : n(r(l)));
            });
        };
    }
    a(Vk, "promisify");
    function M0(t) {
        if (typeof t != "function") throw TypeError(Ro.ERRSTR.CB);
        return t;
    }
    a(M0, "validateCallback");
    function Gk(t, e) {
        if (typeof t == "number") return t;
        if (typeof t == "string") return parseInt(t, 8);
        if (e) return j0(e);
    }
    a(Gk, "_modeToNumber");
    function j0(t, e) {
        let r = Gk(t, e);
        if (typeof r != "number" || isNaN(r)) throw new TypeError(Ro.ERRSTR.MODE_INT);
        return r;
    }
    a(j0, "modeToNumber");
    function U0(t, e) {
        if (("" + t).indexOf("\0") !== -1) {
            let r = new Error("Path must be a string without null bytes");
            if (r.code = "ENOENT", typeof e != "function") throw r;
            return (0, Wk.default)(()=>{
                e(r);
            }), !1;
        }
        return !0;
    }
    a(U0, "nullCheck");
    function Kk(t) {
        if (t.hostname !== "") throw new ju.TypeError("ERR_INVALID_FILE_URL_HOST", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform);
        let e = t.pathname;
        for(let r = 0; r < e.length; r++)if (e[r] === "%") {
            let i = e.codePointAt(r + 2) | 32;
            if (e[r + 1] === "2" && i === 102) throw new ju.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
        }
        return decodeURIComponent(e);
    }
    a(Kk, "getPathFromURLPosix");
    function Zk(t) {
        if (t instanceof Uint8Array && (t = (0, Uu.bufferFrom)(t)), typeof t != "string" && !Uu.Buffer.isBuffer(t)) {
            try {
                if (!(t instanceof Oo().URL)) throw new TypeError(Ro.ERRSTR.PATH_STR);
            } catch (e) {
                throw new TypeError(Ro.ERRSTR.PATH_STR);
            }
            t = Kk(t);
        }
        let e = String(t);
        return U0(e), e;
    }
    a(Zk, "pathToFilename");
    var Xk = "ENOENT", Yk = "EBADF", Jk = "EINVAL", Qk = "EPERM", eP = "EPROTO", tP = "EEXIST", rP = "ENOTDIR", iP = "EMFILE", nP = "EACCES", oP = "EISDIR", sP = "ENOTEMPTY", aP = "ENOSYS", lP = "ERR_FS_EISDIR", cP = "ERR_OUT_OF_RANGE";
    function fP(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "", i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
        let n = "";
        switch(r && (n = " '".concat(r, "'")), i && (n += " -> '".concat(i, "'")), t){
            case Xk:
                return "ENOENT: no such file or directory, ".concat(e).concat(n);
            case Yk:
                return "EBADF: bad file descriptor, ".concat(e).concat(n);
            case Jk:
                return "EINVAL: invalid argument, ".concat(e).concat(n);
            case Qk:
                return "EPERM: operation not permitted, ".concat(e).concat(n);
            case eP:
                return "EPROTO: protocol error, ".concat(e).concat(n);
            case tP:
                return "EEXIST: file already exists, ".concat(e).concat(n);
            case rP:
                return "ENOTDIR: not a directory, ".concat(e).concat(n);
            case oP:
                return "EISDIR: illegal operation on a directory, ".concat(e).concat(n);
            case nP:
                return "EACCES: permission denied, ".concat(e).concat(n);
            case sP:
                return "ENOTEMPTY: directory not empty, ".concat(e).concat(n);
            case iP:
                return "EMFILE: too many open files, ".concat(e).concat(n);
            case aP:
                return "ENOSYS: function not implemented, ".concat(e).concat(n);
            case lP:
                return "[ERR_FS_EISDIR]: Path is a directory: ".concat(e, " returned EISDIR (is a directory) ").concat(r);
            case cP:
                return "[ERR_OUT_OF_RANGE]: value out of range, ".concat(e).concat(n);
            default:
                return "".concat(t, ": error occurred, ").concat(e).concat(n);
        }
    }
    a(fP, "formatError");
    function uP(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "", i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "", n = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Error;
        let o = new n(fP(t, e, r, i));
        return o.code = t, r && (o.path = r), o;
    }
    a(uP, "createError");
    function hP() {
        return Math.random().toString(36).slice(2, 8).padEnd(6, "0");
    }
    a(hP, "genRndStr6");
    function dP(t) {
        if (typeof t == "number") return t;
        if (typeof t == "string") {
            let e = Ro.FLAGS[t];
            if (typeof e < "u") return e;
        }
        throw new ju.TypeError("ERR_INVALID_OPT_VALUE", "flags", t);
    }
    a(dP, "flagsToNumber");
    function pP(t) {
        let e = [];
        return new Promise((r, i)=>{
            t.on("data", (n)=>e.push(n)), t.on("end", ()=>r(Uu.Buffer.concat(e))), t.on("error", i);
        });
    }
    a(pP, "streamToBuffer");
    var mP = a((t)=>new Uint8Array(t.buffer, t.byteOffset, t.byteLength), "bufToUint8");
    Pe.bufToUint8 = mP;
    var yP = a((t, e, r, i, n, o)=>{
        (0, Ia.validateFd)(t);
        let s = 0, l, f = null, c, u, h = typeof e, d = typeof r, p = typeof i, m = typeof n;
        h !== "string" ? d === "function" ? u = r : p === "function" ? (s = r | 0, u = i) : m === "function" ? (s = r | 0, l = i, u = n) : (s = r | 0, l = i, f = n, u = o) : d === "function" ? u = r : p === "function" ? (f = r, u = i) : m === "function" && (f = r, c = i, u = n);
        let y = (0, Ia.dataToBuffer)(e, c);
        h !== "string" ? typeof l > "u" && (l = y.length) : (s = 0, l = y.length);
        let w = M0(u);
        return [
            t,
            h === "string",
            y,
            s,
            l,
            f,
            w
        ];
    }, "getWriteArgs");
    Pe.getWriteArgs = yP;
    var wP = a((t, e, r, i, n)=>{
        (0, Ia.validateFd)(t);
        let o, s, l, f, c = typeof e != "string";
        c ? (s = (r || 0) | 0, l = i, f = n) : (f = r, o = i);
        let u = (0, Ia.dataToBuffer)(e, o);
        return c ? typeof l > "u" && (l = u.length) : (s = 0, l = u.length), [
            t,
            u,
            s || 0,
            l,
            f
        ];
    }, "getWriteSyncArgs");
    Pe.getWriteSyncArgs = wP;
    function gP(t, e) {
        return !e || e === "buffer" ? t : t.toString(e);
    }
    a(gP, "bufferToEncoding");
    function bP(t) {
        return t !== null && typeof t == "object" && typeof t.pipe == "function" && typeof t.on == "function" && t.readable === !0;
    }
    a(bP, "isReadableStream");
});
_c79 = Ar;
var G0 = T(_c80 = (Na)=>{
    "use strict";
    Object.defineProperty(Na, "__esModule", {
        value: !0
    });
    Na.Superblock = void 0;
    var Ne = Wi(), vP = eu(), q0 = ru(), _P = ou(), FP = Tr(), H0 = ia(), Vt = kt(), z0 = Zi(), V = Ar(), Pt = ya(), EP = Kf(), cn = Ne.posix ? Ne.posix.sep : Ne.sep, W0 = Ne.posix ? Ne.posix.relative : Ne.relative, SP = Ne.posix ? Ne.posix.join : Ne.join, { O_RDONLY: qu, O_WRONLY: Da, O_RDWR: Hu, O_CREAT: V0, O_EXCL: xP, O_TRUNC: TP, O_APPEND: OP, O_DIRECTORY: RP } = Vt.constants, fn = class fn {
        static fromJSON(e, r) {
            let i = new fn;
            return i.fromJSON(e, r), i;
        }
        static fromNestedJSON(e, r) {
            let i = new fn;
            return i.fromNestedJSON(e, r), i;
        }
        createLink(e, r) {
            let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = arguments.length > 3 ? arguments[3] : void 0;
            if (!e) return new q0.Link(this, void 0, "");
            if (!r) throw new Error("createLink: name cannot be empty");
            let o = n !== null && n !== void 0 ? n : i ? 511 : 438, l = n && n & Vt.constants.S_IFMT ? n & Vt.constants.S_IFMT : i ? Vt.constants.S_IFDIR : Vt.constants.S_IFREG, f = o & ~Vt.constants.S_IFMT | l;
            return e.createChild(r, this.createNode(f));
        }
        deleteLink(e) {
            let r = e.parent;
            return r ? (r.deleteChild(e), !0) : !1;
        }
        newInoNumber() {
            let e = this.releasedInos.pop();
            return e || (this.ino = (this.ino + 1) % 4294967295, this.ino);
        }
        newFdNumber() {
            let e = this.releasedFds.pop();
            return typeof e == "number" ? e : fn.fd--;
        }
        createNode(e) {
            let r = new vP.Node(this.newInoNumber(), e);
            return this.inodes[r.ino] = r, r;
        }
        deleteNode(e) {
            e.del(), delete this.inodes[e.ino], this.releasedInos.push(e.ino);
        }
        walk(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, o = arguments.length > 4 ? arguments[4] : void 0;
            let s, l;
            e instanceof q0.Link ? (s = e.steps, l = cn + s.join(cn)) : typeof e == "string" ? (s = (0, Pt.filenameToSteps)(e), l = e) : (s = e, l = cn + s.join(cn));
            let f = this.root, c = 0;
            for(; c < s.length;){
                let u = f.getNode();
                if (u.isDirectory()) {
                    if (n && !u.canExecute()) throw (0, V.createError)("EACCES", o, l);
                } else if (c < s.length - 1) throw (0, V.createError)("ENOTDIR", o, l);
                var _f_getChild;
                if (f = (_f_getChild = f.getChild(s[c])) !== null && _f_getChild !== void 0 ? _f_getChild : null, !f) {
                    if (i) throw (0, V.createError)("ENOENT", o, l);
                    return null;
                }
                if (u = f === null || f === void 0 ? void 0 : f.getNode(), u.isSymlink() && (r || c < s.length - 1)) {
                    let h = (0, Ne.isAbsolute)(u.symlink) ? u.symlink : SP((0, Ne.dirname)(f.getPath()), u.symlink);
                    s = (0, Pt.filenameToSteps)(h).concat(s.slice(c + 1)), f = this.root, c = 0;
                    continue;
                }
                if (i && !u.isDirectory() && c < s.length - 1) {
                    let h = H0.default.platform === "win32" ? "ENOENT" : "ENOTDIR";
                    throw (0, V.createError)(h, o, l);
                }
                c++;
            }
            return f;
        }
        getLink(e) {
            return this.walk(e, !1, !1, !1);
        }
        getLinkOrThrow(e, r) {
            return this.walk(e, !1, !0, !0, r);
        }
        getResolvedLink(e) {
            return this.walk(e, !0, !1, !1);
        }
        getResolvedLinkOrThrow(e, r) {
            return this.walk(e, !0, !0, !0, r);
        }
        resolveSymlinks(e) {
            return this.getResolvedLink(e.steps.slice(1));
        }
        getLinkAsDirOrThrow(e, r) {
            let i = this.getLinkOrThrow(e, r);
            if (!i.getNode().isDirectory()) throw (0, V.createError)("ENOTDIR", r, e);
            return i;
        }
        getLinkParent(e) {
            return this.getLink(e.slice(0, -1));
        }
        getLinkParentAsDirOrThrow(e, r) {
            let i = (e instanceof Array ? e : (0, Pt.filenameToSteps)(e)).slice(0, -1), n = cn + i.join(cn), o = this.getLinkOrThrow(n, r);
            if (!o.getNode().isDirectory()) throw (0, V.createError)("ENOTDIR", r, n);
            return o;
        }
        getFileByFd(e) {
            return this.fds[String(e)];
        }
        getFileByFdOrThrow(e, r) {
            if (!(0, Pt.isFd)(e)) throw TypeError(z0.ERRSTR.FD);
            let i = this.getFileByFd(e);
            if (!i) throw (0, V.createError)("EBADF", r);
            return i;
        }
        _toJSON() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.root, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 ? arguments[3] : void 0;
            let o = !0, s = e.children;
            e.getNode().isFile() && (s = new Map([
                [
                    e.getName(),
                    e.parent.getChild(e.getName())
                ]
            ]), e = e.parent);
            for (let f of s.keys()){
                if (f === "." || f === "..") continue;
                o = !1;
                let c = e.getChild(f);
                if (!c) throw new Error("_toJSON: unexpected undefined");
                let u = c.getNode();
                if (u.isFile()) {
                    let h = c.getPath();
                    i && (h = W0(i, h)), r[h] = n ? u.getBuffer() : u.getString();
                } else u.isDirectory() && this._toJSON(c, r, i, n);
            }
            let l = e.getPath();
            return i && (l = W0(i, l)), l && o && (r[l] = null), r;
        }
        toJSON(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
            let o = [];
            if (e) {
                Array.isArray(e) || (e = [
                    e
                ]);
                for (let s of e){
                    let l = (0, V.pathToFilename)(s), f = this.getResolvedLink(l);
                    f && o.push(f);
                }
            } else o.push(this.root);
            if (!o.length) return r;
            for (let s of o)this._toJSON(s, r, i ? s.getPath() : "", n);
            return r;
        }
        fromJSON(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : H0.default.cwd();
            for(let i in e){
                let n = e[i];
                if (i = (0, Pt.resolve)(i, r), typeof n == "string" || n instanceof FP.Buffer) {
                    let o = (0, Ne.dirname)(i);
                    this.mkdirp(o, 511);
                    let s = (0, Pt.dataToBuffer)(n);
                    this.writeFile(i, s, z0.FLAGS.w, 438);
                } else this.mkdirp(i, 511);
            }
        }
        fromNestedJSON(e, r) {
            this.fromJSON((0, EP.flattenJSON)(e), r);
        }
        reset() {
            this.ino = 0, this.inodes = {}, this.releasedInos = [], this.fds = {}, this.releasedFds = [], this.openFiles = 0, this.root = this.createLink(), this.root.setNode(this.createNode(Vt.constants.S_IFDIR | 511));
        }
        mountSync(e, r) {
            this.fromJSON(r, e);
        }
        openLink(e, r) {
            let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
            if (this.openFiles >= this.maxFiles) throw (0, V.createError)("EMFILE", "open", e.getPath());
            let n = e;
            i && (n = this.getResolvedLinkOrThrow(e.getPath(), "open"));
            let o = n.getNode();
            if (o.isDirectory()) {
                if ((r & (qu | Hu | Da)) !== qu) throw (0, V.createError)("EISDIR", "open", e.getPath());
            } else if (r & RP) throw (0, V.createError)("ENOTDIR", "open", e.getPath());
            if ((r & (qu | Hu | Da)) !== Da && !o.canRead() || r & (Da | Hu) && !o.canWrite()) throw (0, V.createError)("EACCES", "open", e.getPath());
            let s = new _P.File(e, o, r, this.newFdNumber());
            return this.fds[s.fd] = s, this.openFiles++, r & TP && s.truncate(), s;
        }
        openFile(e, r, i) {
            let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0;
            let o = (0, Pt.filenameToSteps)(e), s;
            try {
                if (s = n ? this.getResolvedLinkOrThrow(e, "open") : this.getLinkOrThrow(e, "open"), s && r & V0 && r & xP) throw (0, V.createError)("EEXIST", "open", e);
            } catch (l) {
                if (l.code === "ENOENT" && r & V0) {
                    let f = (0, Ne.dirname)(e), c = this.getResolvedLinkOrThrow(f), u = c.getNode();
                    if (!u.isDirectory()) throw (0, V.createError)("ENOTDIR", "open", e);
                    if (!u.canExecute() || !u.canWrite()) throw (0, V.createError)("EACCES", "open", e);
                    i !== null && i !== void 0 ? i : i = 438, s = this.createLink(c, o[o.length - 1], !1, i);
                } else throw l;
            }
            if (s) return this.openLink(s, r, n);
            throw (0, V.createError)("ENOENT", "open", e);
        }
        closeFile(e) {
            this.fds[e.fd] && (this.openFiles--, delete this.fds[e.fd], this.releasedFds.push(e.fd));
        }
        write(e, r, i, n, o) {
            let s = this.getFileByFdOrThrow(e, "write");
            if (s.node.isSymlink()) throw (0, V.createError)("EBADF", "write", s.link.getPath());
            return s.write(r, i, n, o === -1 || typeof o != "number" ? void 0 : o);
        }
        constructor(e = {}){
            var _this = this;
            this.ino = 0, this.inodes = {}, this.releasedInos = [], this.fds = {}, this.releasedFds = [], this.maxFiles = 1e4, this.openFiles = 0, this.open = function(i, n, o) {
                let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0;
                let l = _this.openFile(i, n, o, s);
                if (!l) throw (0, V.createError)("ENOENT", "open", i);
                return l.fd;
            }, this.writeFile = (i, n, o, s)=>{
                let l = typeof i == "number", f;
                l ? f = i : f = this.open((0, V.pathToFilename)(i), o, s);
                let c = 0, u = n.length, h = o & OP ? void 0 : 0;
                try {
                    for(; u > 0;){
                        let d = this.write(f, n, c, u, h);
                        c += d, u -= d, h !== void 0 && (h += d);
                    }
                } finally{
                    l || this.close(f);
                }
            }, this.read = (i, n, o, s, l)=>{
                if (n.byteLength < s) throw (0, V.createError)("ERR_OUT_OF_RANGE", "read", void 0, void 0, RangeError);
                let f = this.getFileByFdOrThrow(i);
                if (f.node.isSymlink()) throw (0, V.createError)("EPERM", "read", f.link.getPath());
                return f.read(n, Number(o), Number(s), l === -1 || typeof l != "number" ? void 0 : l);
            }, this.readv = (i, n, o)=>{
                let s = this.getFileByFdOrThrow(i), l = o !== null && o !== void 0 ? o : void 0;
                l === -1 && (l = void 0);
                let f = 0;
                for (let c of n){
                    let u = s.read(c, 0, c.byteLength, l);
                    if (l = void 0, f += u, u < c.byteLength) break;
                }
                return f;
            }, this.link = (i, n)=>{
                let o;
                try {
                    o = this.getLinkOrThrow(i, "link");
                } catch (u) {
                    throw u.code && (u = (0, V.createError)(u.code, "link", i, n)), u;
                }
                let s = (0, Ne.dirname)(n), l;
                try {
                    l = this.getLinkOrThrow(s, "link");
                } catch (u) {
                    throw u.code && (u = (0, V.createError)(u.code, "link", i, n)), u;
                }
                let f = (0, Ne.basename)(n);
                if (l.getChild(f)) throw (0, V.createError)("EEXIST", "link", i, n);
                let c = o.getNode();
                c.nlink++, l.createChild(f, c);
            }, this.unlink = (i)=>{
                let n = this.getLinkOrThrow(i, "unlink");
                if (n.length) throw Error("Dir not empty...");
                this.deleteLink(n);
                let o = n.getNode();
                o.nlink--, o.nlink <= 0 && this.deleteNode(o);
            }, this.symlink = (i, n)=>{
                let o = (0, Pt.filenameToSteps)(n), s;
                try {
                    s = this.getLinkParentAsDirOrThrow(o);
                } catch (u) {
                    throw u.code && (u = (0, V.createError)(u.code, "symlink", i, n)), u;
                }
                let l = o[o.length - 1];
                if (s.getChild(l)) throw (0, V.createError)("EEXIST", "symlink", i, n);
                let f = s.getNode();
                if (!f.canExecute() || !f.canWrite()) throw (0, V.createError)("EACCES", "symlink", i, n);
                let c = s.createChild(l);
                return c.getNode().makeSymlink(i), c;
            }, this.rename = (i, n)=>{
                let o;
                try {
                    o = this.getResolvedLinkOrThrow(i);
                } catch (h) {
                    throw h.code && (h = (0, V.createError)(h.code, "rename", i, n)), h;
                }
                let s;
                try {
                    s = this.getLinkParentAsDirOrThrow(n);
                } catch (h) {
                    throw h.code && (h = (0, V.createError)(h.code, "rename", i, n)), h;
                }
                let l = o.parent;
                if (!l) throw (0, V.createError)("EINVAL", "rename", i, n);
                let f = l.getNode(), c = s.getNode();
                if (!f.canExecute() || !f.canWrite() || !c.canExecute() || !c.canWrite()) throw (0, V.createError)("EACCES", "rename", i, n);
                l.deleteChild(o);
                let u = (0, Ne.basename)(n);
                o.name = u, o.steps = [
                    ...s.steps,
                    u
                ], s.setChild(o.getName(), o);
            }, this.mkdir = (i, n)=>{
                let o = (0, Pt.filenameToSteps)(i);
                if (!o.length) throw (0, V.createError)("EEXIST", "mkdir", i);
                let s = this.getLinkParentAsDirOrThrow(i, "mkdir"), l = o[o.length - 1];
                if (s.getChild(l)) throw (0, V.createError)("EEXIST", "mkdir", i);
                let f = s.getNode();
                if (!f.canWrite() || !f.canExecute()) throw (0, V.createError)("EACCES", "mkdir", i);
                s.createChild(l, this.createNode(Vt.constants.S_IFDIR | n));
            }, this.mkdirp = (i, n)=>{
                let o = !1, s = (0, Pt.filenameToSteps)(i), l = null, f = s.length;
                for(f = s.length; f >= 0 && (l = this.getResolvedLink(s.slice(0, f)), !l); f--);
                for(l || (l = this.root, f = 0), l = this.getResolvedLinkOrThrow(Ne.sep + s.slice(0, f).join(Ne.sep), "mkdir"), f; f < s.length; f++){
                    let c = l.getNode();
                    if (c.isDirectory()) {
                        if (!c.canExecute() || !c.canWrite()) throw (0, V.createError)("EACCES", "mkdir", i);
                    } else throw (0, V.createError)("ENOTDIR", "mkdir", i);
                    o = !0, l = l.createChild(s[f], this.createNode(Vt.constants.S_IFDIR | n));
                }
                return o ? i : void 0;
            }, this.rmdir = function(i) {
                let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
                let o = _this.getLinkAsDirOrThrow(i, "rmdir");
                if (o.length && !n) throw (0, V.createError)("ENOTEMPTY", "rmdir", i);
                _this.deleteLink(o);
            }, this.rm = function(i) {
                let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
                var _s_parent;
                let s;
                try {
                    s = _this.getResolvedLinkOrThrow(i, "stat");
                } catch (l) {
                    if (l.code === "ENOENT" && n) return;
                    throw l;
                }
                if (s.getNode().isDirectory() && !o) throw (0, V.createError)("ERR_FS_EISDIR", "rm", i);
                if (!((_s_parent = s.parent) === null || _s_parent === void 0 ? void 0 : _s_parent.getNode().canWrite())) throw (0, V.createError)("EACCES", "rm", i);
                _this.deleteLink(s);
            }, this.close = (i)=>{
                (0, Pt.validateFd)(i);
                let n = this.getFileByFdOrThrow(i, "close");
                this.closeFile(n);
            };
            let r = this.createLink();
            r.setNode(this.createNode(Vt.constants.S_IFDIR | 511)), r.setChild(".", r), r.getNode().nlink++, r.setChild("..", r), r.getNode().nlink++, this.root = r;
        }
    };
    a(fn, "Superblock");
    var Ca = fn;
    Na.Superblock = Ca;
    Ca.fd = 2147483647;
});
_c81 = G0;
var Z0 = T(_c82 = (pt)=>{
    "use strict";
    Object.defineProperty(pt, "__esModule", {
        value: !0
    });
    pt.Superblock = pt.File = pt.Link = pt.Node = void 0;
    var K0 = (Vf(), wm(Wf));
    K0.__exportStar(by(), pt);
    K0.__exportStar(Kf(), pt);
    var kP = eu();
    Object.defineProperty(pt, "Node", {
        enumerable: !0,
        get: a(function() {
            return kP.Node;
        }, "get")
    });
    var PP = ru();
    Object.defineProperty(pt, "Link", {
        enumerable: !0,
        get: a(function() {
            return PP.Link;
        }, "get")
    });
    var AP = ou();
    Object.defineProperty(pt, "File", {
        enumerable: !0,
        get: a(function() {
            return AP.File;
        }, "get")
    });
    var IP = G0();
    Object.defineProperty(pt, "Superblock", {
        enumerable: !0,
        get: a(function() {
            return IP.Superblock;
        }, "get")
    });
});
_c83 = Z0;
var X0 = T(_c84 = (ko)=>{
    "use strict";
    Object.defineProperty(ko, "__esModule", {
        value: !0
    });
    ko.StatFs = void 0;
    var La = class La {
        static build(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            let i = new La, n = r ? (u)=>BigInt(u) : (u)=>u;
            i.type = n(2240043254), i.bsize = n(4096);
            let o = Object.keys(e.inodes).length, s = 1e6, l = Math.min(o * 2, s), f = s - l;
            i.blocks = n(s), i.bfree = n(f), i.bavail = n(f);
            let c = 1e6;
            return i.files = n(c), i.ffree = n(c - o), i;
        }
    };
    a(La, "StatFs");
    var Ba = La;
    ko.StatFs = Ba;
    ko.default = Ba;
});
_c85 = X0;
var Y0 = T(_c86 = (zu)=>{
    "use strict";
    Object.defineProperty(zu, "__esModule", {
        value: !0
    });
    function DP(t, e, r) {
        let i = setTimeout.apply(globalThis, arguments);
        return i && typeof i == "object" && typeof i.unref == "function" && i.unref(), i;
    }
    a(DP, "setTimeoutUnref");
    zu.default = DP;
});
_c87 = Y0;
var Po = T(_c88 = (zj, Wu)=>{
    "use strict";
    var un = typeof Reflect == "object" ? Reflect : null, J0 = un && typeof un.apply == "function" ? un.apply : a(function(e, r, i) {
        return Function.prototype.apply.call(e, r, i);
    }, "ReflectApply"), $a;
    un && typeof un.ownKeys == "function" ? $a = un.ownKeys : Object.getOwnPropertySymbols ? $a = a(function(e) {
        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
    }, "ReflectOwnKeys") : $a = a(function(e) {
        return Object.getOwnPropertyNames(e);
    }, "ReflectOwnKeys");
    function CP(t) {
        console && console.warn && console.warn(t);
    }
    a(CP, "ProcessEmitWarning");
    var eg = Number.isNaN || a(function(e) {
        return e !== e;
    }, "NumberIsNaN");
    function le() {
        le.init.call(this);
    }
    a(le, "EventEmitter");
    Wu.exports = le;
    Wu.exports.once = $P;
    le.EventEmitter = le;
    le.prototype._events = void 0;
    le.prototype._eventsCount = 0;
    le.prototype._maxListeners = void 0;
    var Q0 = 10;
    function Ma(t) {
        if (typeof t != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
    }
    a(Ma, "checkListener");
    Object.defineProperty(le, "defaultMaxListeners", {
        enumerable: !0,
        get: a(function() {
            return Q0;
        }, "get"),
        set: a(function(t) {
            if (typeof t != "number" || t < 0 || eg(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
            Q0 = t;
        }, "set")
    });
    le.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    };
    le.prototype.setMaxListeners = a(function(e) {
        if (typeof e != "number" || e < 0 || eg(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
        return this._maxListeners = e, this;
    }, "setMaxListeners");
    function tg(t) {
        return t._maxListeners === void 0 ? le.defaultMaxListeners : t._maxListeners;
    }
    a(tg, "_getMaxListeners");
    le.prototype.getMaxListeners = a(function() {
        return tg(this);
    }, "getMaxListeners");
    le.prototype.emit = a(function(e) {
        for(var r = [], i = 1; i < arguments.length; i++)r.push(arguments[i]);
        var n = e === "error", o = this._events;
        if (o !== void 0) n = n && o.error === void 0;
        else if (!n) return !1;
        if (n) {
            var s;
            if (r.length > 0 && (s = r[0]), s instanceof Error) throw s;
            var l = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
            throw l.context = s, l;
        }
        var f = o[e];
        if (f === void 0) return !1;
        if (typeof f == "function") J0(f, this, r);
        else for(var c = f.length, u = sg(f, c), i = 0; i < c; ++i)J0(u[i], this, r);
        return !0;
    }, "emit");
    function rg(t, e, r, i) {
        var n, o, s;
        if (Ma(r), o = t._events, o === void 0 ? (o = t._events = Object.create(null), t._eventsCount = 0) : (o.newListener !== void 0 && (t.emit("newListener", e, r.listener ? r.listener : r), o = t._events), s = o[e]), s === void 0) s = o[e] = r, ++t._eventsCount;
        else if (typeof s == "function" ? s = o[e] = i ? [
            r,
            s
        ] : [
            s,
            r
        ] : i ? s.unshift(r) : s.push(r), n = tg(t), n > 0 && s.length > n && !s.warned) {
            s.warned = !0;
            var l = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            l.name = "MaxListenersExceededWarning", l.emitter = t, l.type = e, l.count = s.length, CP(l);
        }
        return t;
    }
    a(rg, "_addListener");
    le.prototype.addListener = a(function(e, r) {
        return rg(this, e, r, !1);
    }, "addListener");
    le.prototype.on = le.prototype.addListener;
    le.prototype.prependListener = a(function(e, r) {
        return rg(this, e, r, !0);
    }, "prependListener");
    function NP() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    a(NP, "onceWrapper");
    function ig(t, e, r) {
        var i = {
            fired: !1,
            wrapFn: void 0,
            target: t,
            type: e,
            listener: r
        }, n = NP.bind(i);
        return n.listener = r, i.wrapFn = n, n;
    }
    a(ig, "_onceWrap");
    le.prototype.once = a(function(e, r) {
        return Ma(r), this.on(e, ig(this, e, r)), this;
    }, "once");
    le.prototype.prependOnceListener = a(function(e, r) {
        return Ma(r), this.prependListener(e, ig(this, e, r)), this;
    }, "prependOnceListener");
    le.prototype.removeListener = a(function(e, r) {
        var i, n, o, s, l;
        if (Ma(r), n = this._events, n === void 0) return this;
        if (i = n[e], i === void 0) return this;
        if (i === r || i.listener === r) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete n[e], n.removeListener && this.emit("removeListener", e, i.listener || r));
        else if (typeof i != "function") {
            for(o = -1, s = i.length - 1; s >= 0; s--)if (i[s] === r || i[s].listener === r) {
                l = i[s].listener, o = s;
                break;
            }
            if (o < 0) return this;
            o === 0 ? i.shift() : BP(i, o), i.length === 1 && (n[e] = i[0]), n.removeListener !== void 0 && this.emit("removeListener", e, l || r);
        }
        return this;
    }, "removeListener");
    le.prototype.off = le.prototype.removeListener;
    le.prototype.removeAllListeners = a(function(e) {
        var r, i, n;
        if (i = this._events, i === void 0) return this;
        if (i.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : i[e] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete i[e]), this;
        if (arguments.length === 0) {
            var o = Object.keys(i), s;
            for(n = 0; n < o.length; ++n)s = o[n], s !== "removeListener" && this.removeAllListeners(s);
            return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
        }
        if (r = i[e], typeof r == "function") this.removeListener(e, r);
        else if (r !== void 0) for(n = r.length - 1; n >= 0; n--)this.removeListener(e, r[n]);
        return this;
    }, "removeAllListeners");
    function ng(t, e, r) {
        var i = t._events;
        if (i === void 0) return [];
        var n = i[e];
        return n === void 0 ? [] : typeof n == "function" ? r ? [
            n.listener || n
        ] : [
            n
        ] : r ? LP(n) : sg(n, n.length);
    }
    a(ng, "_listeners");
    le.prototype.listeners = a(function(e) {
        return ng(this, e, !0);
    }, "listeners");
    le.prototype.rawListeners = a(function(e) {
        return ng(this, e, !1);
    }, "rawListeners");
    le.listenerCount = function(t, e) {
        return typeof t.listenerCount == "function" ? t.listenerCount(e) : og.call(t, e);
    };
    le.prototype.listenerCount = og;
    function og(t) {
        var e = this._events;
        if (e !== void 0) {
            var r = e[t];
            if (typeof r == "function") return 1;
            if (r !== void 0) return r.length;
        }
        return 0;
    }
    a(og, "listenerCount");
    le.prototype.eventNames = a(function() {
        return this._eventsCount > 0 ? $a(this._events) : [];
    }, "eventNames");
    function sg(t, e) {
        for(var r = new Array(e), i = 0; i < e; ++i)r[i] = t[i];
        return r;
    }
    a(sg, "arrayClone");
    function BP(t, e) {
        for(; e + 1 < t.length; e++)t[e] = t[e + 1];
        t.pop();
    }
    a(BP, "spliceOne");
    function LP(t) {
        for(var e = new Array(t.length), r = 0; r < e.length; ++r)e[r] = t[r].listener || t[r];
        return e;
    }
    a(LP, "unwrapListeners");
    function $P(t, e) {
        return new Promise(function(r, i) {
            function n(s) {
                t.removeListener(e, o), i(s);
            }
            a(n, "errorListener");
            function o() {
                typeof t.removeListener == "function" && t.removeListener("error", n), r([].slice.call(arguments));
            }
            a(o, "resolver"), ag(t, e, o, {
                once: !0
            }), e !== "error" && MP(t, n, {
                once: !0
            });
        });
    }
    a($P, "once");
    function MP(t, e, r) {
        typeof t.on == "function" && ag(t, "error", e, r);
    }
    a(MP, "addErrorHandlerIfEventEmitter");
    function ag(t, e, r, i) {
        if (typeof t.on == "function") i.once ? t.once(e, r) : t.on(e, r);
        else if (typeof t.addEventListener == "function") t.addEventListener(e, a(function n(o) {
            i.once && t.removeEventListener(e, n), r(o);
        }, "wrapListener"));
        else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
    }
    a(ag, "eventTargetAgnosticAddListener");
});
_c89 = Po;
var Gt = T(_c90 = (Vj, Vu)=>{
    typeof Object.create == "function" ? Vu.exports = a(function(e, r) {
        r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }));
    }, "inherits") : Vu.exports = a(function(e, r) {
        if (r) {
            e.super_ = r;
            var i = a(function() {}, "TempCtor");
            i.prototype = r.prototype, e.prototype = new i, e.prototype.constructor = e;
        }
    }, "inherits");
});
_c91 = Gt;
var Gu = T(_c92 = (Kj, lg)=>{
    lg.exports = Po().EventEmitter;
});
_c93 = Gu;
var Ku = T(_c94 = ()=>{});
_c95 = Ku;
var pg = T((Yj, dg)=>{
    "use strict";
    function cg(t, e) {
        var r = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(t);
            e && (i = i.filter(function(n) {
                return Object.getOwnPropertyDescriptor(t, n).enumerable;
            })), r.push.apply(r, i);
        }
        return r;
    }
    a(cg, "ownKeys");
    function fg(t) {
        for(var e = 1; e < arguments.length; e++){
            var r = arguments[e] != null ? arguments[e] : {};
            e % 2 ? cg(Object(r), !0).forEach(function(i) {
                jP(t, i, r[i]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : cg(Object(r)).forEach(function(i) {
                Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(r, i));
            });
        }
        return t;
    }
    a(fg, "_objectSpread");
    function jP(t, e, r) {
        return e = hg(e), e in t ? Object.defineProperty(t, e, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = r, t;
    }
    a(jP, "_defineProperty");
    function UP(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
    }
    a(UP, "_classCallCheck");
    function ug(t, e) {
        for(var r = 0; r < e.length; r++){
            var i = e[r];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, hg(i.key), i);
        }
    }
    a(ug, "_defineProperties");
    function qP(t, e, r) {
        return e && ug(t.prototype, e), r && ug(t, r), Object.defineProperty(t, "prototype", {
            writable: !1
        }), t;
    }
    a(qP, "_createClass");
    function hg(t) {
        var e = HP(t, "string");
        return typeof e == "symbol" ? e : String(e);
    }
    a(hg, "_toPropertyKey");
    function HP(t, e) {
        if (typeof t != "object" || t === null) return t;
        var r = t[Symbol.toPrimitive];
        if (r !== void 0) {
            var i = r.call(t, e || "default");
            if (typeof i != "object") return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (e === "string" ? String : Number)(t);
    }
    a(HP, "_toPrimitive");
    var zP = ri(), ja = zP.Buffer, WP = Ku(), Zu = WP.inspect, VP = Zu && Zu.custom || "inspect";
    function GP(t, e, r) {
        ja.prototype.copy.call(t, e, r);
    }
    a(GP, "copyBuffer");
    dg.exports = function() {
        function t() {
            UP(this, t), this.head = null, this.tail = null, this.length = 0;
        }
        return a(t, "BufferList"), qP(t, [
            {
                key: "push",
                value: a(function(r) {
                    var i = {
                        data: r,
                        next: null
                    };
                    this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
                }, "push")
            },
            {
                key: "unshift",
                value: a(function(r) {
                    var i = {
                        data: r,
                        next: this.head
                    };
                    this.length === 0 && (this.tail = i), this.head = i, ++this.length;
                }, "unshift")
            },
            {
                key: "shift",
                value: a(function() {
                    if (this.length !== 0) {
                        var r = this.head.data;
                        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
                    }
                }, "shift")
            },
            {
                key: "clear",
                value: a(function() {
                    this.head = this.tail = null, this.length = 0;
                }, "clear")
            },
            {
                key: "join",
                value: a(function(r) {
                    if (this.length === 0) return "";
                    for(var i = this.head, n = "" + i.data; i = i.next;)n += r + i.data;
                    return n;
                }, "join")
            },
            {
                key: "concat",
                value: a(function(r) {
                    if (this.length === 0) return ja.alloc(0);
                    for(var i = ja.allocUnsafe(r >>> 0), n = this.head, o = 0; n;)GP(n.data, i, o), o += n.data.length, n = n.next;
                    return i;
                }, "concat")
            },
            {
                key: "consume",
                value: a(function(r, i) {
                    var n;
                    return r < this.head.data.length ? (n = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? n = this.shift() : n = i ? this._getString(r) : this._getBuffer(r), n;
                }, "consume")
            },
            {
                key: "first",
                value: a(function() {
                    return this.head.data;
                }, "first")
            },
            {
                key: "_getString",
                value: a(function(r) {
                    var i = this.head, n = 1, o = i.data;
                    for(r -= o.length; i = i.next;){
                        var s = i.data, l = r > s.length ? s.length : r;
                        if (l === s.length ? o += s : o += s.slice(0, r), r -= l, r === 0) {
                            l === s.length ? (++n, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = s.slice(l));
                            break;
                        }
                        ++n;
                    }
                    return this.length -= n, o;
                }, "_getString")
            },
            {
                key: "_getBuffer",
                value: a(function(r) {
                    var i = ja.allocUnsafe(r), n = this.head, o = 1;
                    for(n.data.copy(i), r -= n.data.length; n = n.next;){
                        var s = n.data, l = r > s.length ? s.length : r;
                        if (s.copy(i, i.length - r, 0, l), r -= l, r === 0) {
                            l === s.length ? (++o, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = s.slice(l));
                            break;
                        }
                        ++o;
                    }
                    return this.length -= o, i;
                }, "_getBuffer")
            },
            {
                key: VP,
                value: a(function(r, i) {
                    return Zu(this, fg(fg({}, i), {}, {
                        depth: 0,
                        customInspect: !1
                    }));
                }, "value")
            }
        ]), t;
    }();
});
var Yu = T(_c96 = (Qj, yg)=>{
    "use strict";
    function KP(t, e) {
        var r = this, i = this._readableState && this._readableState.destroyed, n = this._writableState && this._writableState.destroyed;
        return i || n ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(Xu, this, t)) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(Xu, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, function(o) {
            !e && o ? r._writableState ? r._writableState.errorEmitted ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(Ua, r) : (r._writableState.errorEmitted = !0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(mg, r, o)) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(mg, r, o) : e ? (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(Ua, r), e(o)) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(Ua, r);
        }), this);
    }
    a(KP, "destroy");
    function mg(t, e) {
        Xu(t, e), Ua(t);
    }
    a(mg, "emitErrorAndCloseNT");
    function Ua(t) {
        t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    a(Ua, "emitCloseNT");
    function ZP() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
    }
    a(ZP, "undestroy");
    function Xu(t, e) {
        t.emit("error", e);
    }
    a(Xu, "emitErrorNT");
    function XP(t, e) {
        var r = t._readableState, i = t._writableState;
        r && r.autoDestroy || i && i.autoDestroy ? t.destroy(e) : t.emit("error", e);
    }
    a(XP, "errorOrDestroy");
    yg.exports = {
        destroy: KP,
        undestroy: ZP,
        errorOrDestroy: XP
    };
});
_c97 = Yu;
var li = T((t6, bg)=>{
    "use strict";
    function YP(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
    }
    a(YP, "_inheritsLoose");
    var gg = {};
    function mt(t, e, r) {
        r || (r = Error);
        function i(o, s, l) {
            return typeof e == "string" ? e : e(o, s, l);
        }
        a(i, "getMessage");
        var n = function(o) {
            YP(s, o);
            function s(l, f, c) {
                return o.call(this, i(l, f, c)) || this;
            }
            return a(s, "NodeError"), s;
        }(r);
        n.prototype.name = r.name, n.prototype.code = t, gg[t] = n;
    }
    a(mt, "createErrorType");
    function wg(t, e) {
        if (Array.isArray(t)) {
            var r = t.length;
            return t = t.map(function(i) {
                return String(i);
            }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
        } else return "of ".concat(e, " ").concat(String(t));
    }
    a(wg, "oneOf");
    function JP(t, e, r) {
        return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    a(JP, "startsWith");
    function QP(t, e, r) {
        return (r === void 0 || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
    }
    a(QP, "endsWith");
    function eA(t, e, r) {
        return typeof r != "number" && (r = 0), r + e.length > t.length ? !1 : t.indexOf(e, r) !== -1;
    }
    a(eA, "includes");
    mt("ERR_INVALID_OPT_VALUE", function(t, e) {
        return 'The value "' + e + '" is invalid for option "' + t + '"';
    }, TypeError);
    mt("ERR_INVALID_ARG_TYPE", function(t, e, r) {
        var i;
        typeof e == "string" && JP(e, "not ") ? (i = "must not be", e = e.replace(/^not /, "")) : i = "must be";
        var n;
        if (QP(t, " argument")) n = "The ".concat(t, " ").concat(i, " ").concat(wg(e, "type"));
        else {
            var o = eA(t, ".") ? "property" : "argument";
            n = 'The "'.concat(t, '" ').concat(o, " ").concat(i, " ").concat(wg(e, "type"));
        }
        return n += ". Received type ".concat(typeof r), n;
    }, TypeError);
    mt("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    mt("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
        return "The " + t + " method is not implemented";
    });
    mt("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    mt("ERR_STREAM_DESTROYED", function(t) {
        return "Cannot call " + t + " after a stream was destroyed";
    });
    mt("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    mt("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    mt("ERR_STREAM_WRITE_AFTER_END", "write after end");
    mt("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    mt("ERR_UNKNOWN_ENCODING", function(t) {
        return "Unknown encoding: " + t;
    }, TypeError);
    mt("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    bg.exports.codes = gg;
});
var Ju = T(_c98 = (i6, vg)=>{
    "use strict";
    var tA = li().codes.ERR_INVALID_OPT_VALUE;
    function rA(t, e, r) {
        return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    a(rA, "highWaterMarkFrom");
    function iA(t, e, r, i) {
        var n = rA(e, i, r);
        if (n != null) {
            if (!(isFinite(n) && Math.floor(n) === n) || n < 0) {
                var o = i ? r : "highWaterMark";
                throw new tA(o, n);
            }
            return Math.floor(n);
        }
        return t.objectMode ? 16 : 16 * 1024;
    }
    a(iA, "getHighWaterMark");
    vg.exports = {
        getHighWaterMark: iA
    };
});
_c99 = Ju;
var Fg = T(_c100 = (o6, _g)=>{
    _g.exports = nA;
    function nA(t, e) {
        if (Qu("noDeprecation")) return t;
        var r = !1;
        function i() {
            if (!r) {
                if (Qu("throwDeprecation")) throw new Error(e);
                Qu("traceDeprecation") ? console.trace(e) : console.warn(e), r = !0;
            }
            return t.apply(this, arguments);
        }
        return a(i, "deprecated"), i;
    }
    a(nA, "deprecate");
    function Qu(t) {
        try {
            if (!globalThis.localStorage) return !1;
        } catch (e) {
            return !1;
        }
        var e = globalThis.localStorage[t];
        return e == null ? !1 : String(e).toLowerCase() === "true";
    }
    a(Qu, "config");
});
_c101 = Fg;
var za = T((a6, Rg)=>{
    "use strict";
    Rg.exports = ge;
    function Sg(t) {
        var e = this;
        this.next = null, this.entry = null, this.finish = function() {
            AA(e, t);
        };
    }
    a(Sg, "CorkedRequest");
    var hn;
    ge.WritableState = Io;
    var oA = {
        deprecate: Fg()
    }, xg = Gu(), Ha = ri().Buffer, sA = (typeof globalThis < "u" ? globalThis : "object" < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};
    function aA(t) {
        return Ha.from(t);
    }
    a(aA, "_uint8ArrayToBuffer");
    function lA(t) {
        return Ha.isBuffer(t) || t instanceof sA;
    }
    a(lA, "_isUint8Array");
    var th = Yu(), cA = Ju(), fA = cA.getHighWaterMark, Ir = li().codes, uA = Ir.ERR_INVALID_ARG_TYPE, hA = Ir.ERR_METHOD_NOT_IMPLEMENTED, dA = Ir.ERR_MULTIPLE_CALLBACK, pA = Ir.ERR_STREAM_CANNOT_PIPE, mA = Ir.ERR_STREAM_DESTROYED, yA = Ir.ERR_STREAM_NULL_VALUES, wA = Ir.ERR_STREAM_WRITE_AFTER_END, gA = Ir.ERR_UNKNOWN_ENCODING, dn = th.errorOrDestroy;
    Gt()(ge, xg);
    function bA() {}
    a(bA, "nop");
    function Io(t, e, r) {
        hn = hn || Dr(), t = t || {}, typeof r != "boolean" && (r = e instanceof hn), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = fA(this, t, "writableHighWaterMark", r), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var i = t.decodeStrings === !1;
        this.decodeStrings = !i, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(n) {
            TA(e, n);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = t.emitClose !== !1, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Sg(this);
    }
    a(Io, "WritableState");
    Io.prototype.getBuffer = a(function() {
        for(var e = this.bufferedRequest, r = []; e;)r.push(e), e = e.next;
        return r;
    }, "getBuffer");
    (function() {
        try {
            Object.defineProperty(Io.prototype, "buffer", {
                get: oA.deprecate(a(function() {
                    return this.getBuffer();
                }, "writableStateBufferGetter"), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            });
        } catch (e) {}
    })();
    var qa;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (qa = Function.prototype[Symbol.hasInstance], Object.defineProperty(ge, Symbol.hasInstance, {
        value: a(function(e) {
            return qa.call(this, e) ? !0 : this !== ge ? !1 : e && e._writableState instanceof Io;
        }, "value")
    })) : qa = a(function(e) {
        return e instanceof this;
    }, "realHasInstance");
    function ge(t) {
        hn = hn || Dr();
        var e = this instanceof hn;
        if (!e && !qa.call(ge, this)) return new ge(t);
        this._writableState = new Io(t, this, e), this.writable = !0, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), xg.call(this);
    }
    a(ge, "Writable");
    ge.prototype.pipe = function() {
        dn(this, new pA);
    };
    function vA(t, e) {
        var r = new wA;
        dn(t, r), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(e, r);
    }
    a(vA, "writeAfterEnd");
    function _A(t, e, r, i) {
        var n;
        return r === null ? n = new yA : typeof r != "string" && !e.objectMode && (n = new uA("chunk", [
            "string",
            "Buffer"
        ], r)), n ? (dn(t, n), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(i, n), !1) : !0;
    }
    a(_A, "validChunk");
    ge.prototype.write = function(t, e, r) {
        var i = this._writableState, n = !1, o = !i.objectMode && lA(t);
        return o && !Ha.isBuffer(t) && (t = aA(t)), typeof e == "function" && (r = e, e = null), o ? e = "buffer" : e || (e = i.defaultEncoding), typeof r != "function" && (r = bA), i.ending ? vA(this, r) : (o || _A(this, i, t, r)) && (i.pendingcb++, n = EA(this, i, o, t, e, r)), n;
    };
    ge.prototype.cork = function() {
        this._writableState.corked++;
    };
    ge.prototype.uncork = function() {
        var t = this._writableState;
        t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Tg(this, t));
    };
    ge.prototype.setDefaultEncoding = a(function(e) {
        if (typeof e == "string" && (e = e.toLowerCase()), !([
            "hex",
            "utf8",
            "utf-8",
            "ascii",
            "binary",
            "base64",
            "ucs2",
            "ucs-2",
            "utf16le",
            "utf-16le",
            "raw"
        ].indexOf((e + "").toLowerCase()) > -1)) throw new gA(e);
        return this._writableState.defaultEncoding = e, this;
    }, "setDefaultEncoding");
    Object.defineProperty(ge.prototype, "writableBuffer", {
        enumerable: !1,
        get: a(function() {
            return this._writableState && this._writableState.getBuffer();
        }, "get")
    });
    function FA(t, e, r) {
        return !t.objectMode && t.decodeStrings !== !1 && typeof e == "string" && (e = Ha.from(e, r)), e;
    }
    a(FA, "decodeChunk");
    Object.defineProperty(ge.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: a(function() {
            return this._writableState.highWaterMark;
        }, "get")
    });
    function EA(t, e, r, i, n, o) {
        if (!r) {
            var s = FA(e, i, n);
            i !== s && (r = !0, n = "buffer", i = s);
        }
        var l = e.objectMode ? 1 : i.length;
        e.length += l;
        var f = e.length < e.highWaterMark;
        if (f || (e.needDrain = !0), e.writing || e.corked) {
            var c = e.lastBufferedRequest;
            e.lastBufferedRequest = {
                chunk: i,
                encoding: n,
                isBuf: r,
                callback: o,
                next: null
            }, c ? c.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
        } else eh(t, e, !1, l, i, n, o);
        return f;
    }
    a(EA, "writeOrBuffer");
    function eh(t, e, r, i, n, o, s) {
        e.writelen = i, e.writecb = s, e.writing = !0, e.sync = !0, e.destroyed ? e.onwrite(new mA("write")) : r ? t._writev(n, e.onwrite) : t._write(n, o, e.onwrite), e.sync = !1;
    }
    a(eh, "doWrite");
    function SA(t, e, r, i, n) {
        --e.pendingcb, r ? (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(n, i), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(Ao, t, e), t._writableState.errorEmitted = !0, dn(t, i)) : (n(i), t._writableState.errorEmitted = !0, dn(t, i), Ao(t, e));
    }
    a(SA, "onwriteError");
    function xA(t) {
        t.writing = !1, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    a(xA, "onwriteStateUpdate");
    function TA(t, e) {
        var r = t._writableState, i = r.sync, n = r.writecb;
        if (typeof n != "function") throw new dA;
        if (xA(r), e) SA(t, r, i, e, n);
        else {
            var o = Og(r) || t.destroyed;
            !o && !r.corked && !r.bufferProcessing && r.bufferedRequest && Tg(t, r), i ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(Eg, t, r, o, n) : Eg(t, r, o, n);
        }
    }
    a(TA, "onwrite");
    function Eg(t, e, r, i) {
        r || OA(t, e), e.pendingcb--, i(), Ao(t, e);
    }
    a(Eg, "afterWrite");
    function OA(t, e) {
        e.length === 0 && e.needDrain && (e.needDrain = !1, t.emit("drain"));
    }
    a(OA, "onwriteDrain");
    function Tg(t, e) {
        e.bufferProcessing = !0;
        var r = e.bufferedRequest;
        if (t._writev && r && r.next) {
            var i = e.bufferedRequestCount, n = new Array(i), o = e.corkedRequestsFree;
            o.entry = r;
            for(var s = 0, l = !0; r;)n[s] = r, r.isBuf || (l = !1), r = r.next, s += 1;
            n.allBuffers = l, eh(t, e, !0, e.length, n, "", o.finish), e.pendingcb++, e.lastBufferedRequest = null, o.next ? (e.corkedRequestsFree = o.next, o.next = null) : e.corkedRequestsFree = new Sg(e), e.bufferedRequestCount = 0;
        } else {
            for(; r;){
                var f = r.chunk, c = r.encoding, u = r.callback, h = e.objectMode ? 1 : f.length;
                if (eh(t, e, !1, h, f, c, u), r = r.next, e.bufferedRequestCount--, e.writing) break;
            }
            r === null && (e.lastBufferedRequest = null);
        }
        e.bufferedRequest = r, e.bufferProcessing = !1;
    }
    a(Tg, "clearBuffer");
    ge.prototype._write = function(t, e, r) {
        r(new hA("_write()"));
    };
    ge.prototype._writev = null;
    ge.prototype.end = function(t, e, r) {
        var i = this._writableState;
        return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), i.corked && (i.corked = 1, this.uncork()), i.ending || PA(this, i, r), this;
    };
    Object.defineProperty(ge.prototype, "writableLength", {
        enumerable: !1,
        get: a(function() {
            return this._writableState.length;
        }, "get")
    });
    function Og(t) {
        return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    a(Og, "needFinish");
    function RA(t, e) {
        t._final(function(r) {
            e.pendingcb--, r && dn(t, r), e.prefinished = !0, t.emit("prefinish"), Ao(t, e);
        });
    }
    a(RA, "callFinal");
    function kA(t, e) {
        !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = !0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(RA, t, e)) : (e.prefinished = !0, t.emit("prefinish")));
    }
    a(kA, "prefinish");
    function Ao(t, e) {
        var r = Og(e);
        if (r && (kA(t, e), e.pendingcb === 0 && (e.finished = !0, t.emit("finish"), e.autoDestroy))) {
            var i = t._readableState;
            (!i || i.autoDestroy && i.endEmitted) && t.destroy();
        }
        return r;
    }
    a(Ao, "finishMaybe");
    function PA(t, e, r) {
        e.ending = !0, Ao(t, e), r && (e.finished ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(r) : t.once("finish", r)), e.ended = !0, t.writable = !1;
    }
    a(PA, "endWritable");
    function AA(t, e, r) {
        var i = t.entry;
        for(t.entry = null; i;){
            var n = i.callback;
            e.pendingcb--, n(r), i = i.next;
        }
        e.corkedRequestsFree.next = t;
    }
    a(AA, "onCorkedFinish");
    Object.defineProperty(ge.prototype, "destroyed", {
        enumerable: !1,
        get: a(function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed;
        }, "get"),
        set: a(function(e) {
            this._writableState && (this._writableState.destroyed = e);
        }, "set")
    });
    ge.prototype.destroy = th.destroy;
    ge.prototype._undestroy = th.undestroy;
    ge.prototype._destroy = function(t, e) {
        e(t);
    };
});
var Dr = T(_c102 = (c6, Pg)=>{
    "use strict";
    var IA = Object.keys || function(t) {
        var e = [];
        for(var r in t)e.push(r);
        return e;
    };
    Pg.exports = Kt;
    var kg = Ga(), ih = za();
    Gt()(Kt, kg);
    for(rh = IA(ih.prototype), Wa = 0; Wa < rh.length; Wa++)Va = rh[Wa], Kt.prototype[Va] || (Kt.prototype[Va] = ih.prototype[Va]);
    var rh, Va, Wa;
    function Kt(t) {
        if (!(this instanceof Kt)) return new Kt(t);
        kg.call(this, t), ih.call(this, t), this.allowHalfOpen = !0, t && (t.readable === !1 && (this.readable = !1), t.writable === !1 && (this.writable = !1), t.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", DA)));
    }
    a(Kt, "Duplex");
    Object.defineProperty(Kt.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: a(function() {
            return this._writableState.highWaterMark;
        }, "get")
    });
    Object.defineProperty(Kt.prototype, "writableBuffer", {
        enumerable: !1,
        get: a(function() {
            return this._writableState && this._writableState.getBuffer();
        }, "get")
    });
    Object.defineProperty(Kt.prototype, "writableLength", {
        enumerable: !1,
        get: a(function() {
            return this._writableState.length;
        }, "get")
    });
    function DA() {
        this._writableState.ended || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(CA, this);
    }
    a(DA, "onend");
    function CA(t) {
        t.end();
    }
    a(CA, "onEndNT");
    Object.defineProperty(Kt.prototype, "destroyed", {
        enumerable: !1,
        get: a(function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
        }, "get"),
        set: a(function(e) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = e, this._writableState.destroyed = e);
        }, "set")
    });
});
_c103 = Dr;
var Do = T(_c104 = (nh, Ig)=>{
    var Ka = ri(), Zt = Ka.Buffer;
    function Ag(t, e) {
        for(var r in t)e[r] = t[r];
    }
    a(Ag, "copyProps");
    Zt.from && Zt.alloc && Zt.allocUnsafe && Zt.allocUnsafeSlow ? Ig.exports = Ka : (Ag(Ka, nh), nh.Buffer = ci);
    function ci(t, e, r) {
        return Zt(t, e, r);
    }
    a(ci, "SafeBuffer");
    ci.prototype = Object.create(Zt.prototype);
    Ag(Zt, ci);
    ci.from = function(t, e, r) {
        if (typeof t == "number") throw new TypeError("Argument must not be a number");
        return Zt(t, e, r);
    };
    ci.alloc = function(t, e, r) {
        if (typeof t != "number") throw new TypeError("Argument must be a number");
        var i = Zt(t);
        return e !== void 0 ? typeof r == "string" ? i.fill(e, r) : i.fill(e) : i.fill(0), i;
    };
    ci.allocUnsafe = function(t) {
        if (typeof t != "number") throw new TypeError("Argument must be a number");
        return Zt(t);
    };
    ci.allocUnsafeSlow = function(t) {
        if (typeof t != "number") throw new TypeError("Argument must be a number");
        return Ka.SlowBuffer(t);
    };
});
_c105 = Do;
var ah = T((Cg)=>{
    "use strict";
    var sh = Do().Buffer, Dg = sh.isEncoding || function(t) {
        switch(t = "" + t, t && t.toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
                return !0;
            default:
                return !1;
        }
    };
    function NA(t) {
        if (!t) return "utf8";
        for(var e;;)switch(t){
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return t;
            default:
                if (e) return;
                t = ("" + t).toLowerCase(), e = !0;
        }
    }
    a(NA, "_normalizeEncoding");
    function BA(t) {
        var e = NA(t);
        if (typeof e != "string" && (sh.isEncoding === Dg || !Dg(t))) throw new Error("Unknown encoding: " + t);
        return e || t;
    }
    a(BA, "normalizeEncoding");
    Cg.StringDecoder = Co;
    function Co(t) {
        this.encoding = BA(t);
        var e;
        switch(this.encoding){
            case "utf16le":
                this.text = qA, this.end = HA, e = 4;
                break;
            case "utf8":
                this.fillLast = MA, e = 4;
                break;
            case "base64":
                this.text = zA, this.end = WA, e = 3;
                break;
            default:
                this.write = VA, this.end = GA;
                return;
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = sh.allocUnsafe(e);
    }
    a(Co, "StringDecoder");
    Co.prototype.write = function(t) {
        if (t.length === 0) return "";
        var e, r;
        if (this.lastNeed) {
            if (e = this.fillLast(t), e === void 0) return "";
            r = this.lastNeed, this.lastNeed = 0;
        } else r = 0;
        return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
    };
    Co.prototype.end = UA;
    Co.prototype.text = jA;
    Co.prototype.fillLast = function(t) {
        if (this.lastNeed <= t.length) return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
    };
    function oh(t) {
        return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
    }
    a(oh, "utf8CheckByte");
    function LA(t, e, r) {
        var i = e.length - 1;
        if (i < r) return 0;
        var n = oh(e[i]);
        return n >= 0 ? (n > 0 && (t.lastNeed = n - 1), n) : --i < r || n === -2 ? 0 : (n = oh(e[i]), n >= 0 ? (n > 0 && (t.lastNeed = n - 2), n) : --i < r || n === -2 ? 0 : (n = oh(e[i]), n >= 0 ? (n > 0 && (n === 2 ? n = 0 : t.lastNeed = n - 3), n) : 0));
    }
    a(LA, "utf8CheckIncomplete");
    function $A(t, e, r) {
        if ((e[0] & 192) !== 128) return t.lastNeed = 0, "\uFFFD";
        if (t.lastNeed > 1 && e.length > 1) {
            if ((e[1] & 192) !== 128) return t.lastNeed = 1, "\uFFFD";
            if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128) return t.lastNeed = 2, "\uFFFD";
        }
    }
    a($A, "utf8CheckExtraBytes");
    function MA(t) {
        var e = this.lastTotal - this.lastNeed, r = $A(this, t, e);
        if (r !== void 0) return r;
        if (this.lastNeed <= t.length) return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
    }
    a(MA, "utf8FillLast");
    function jA(t, e) {
        var r = LA(this, t, e);
        if (!this.lastNeed) return t.toString("utf8", e);
        this.lastTotal = r;
        var i = t.length - (r - this.lastNeed);
        return t.copy(this.lastChar, 0, i), t.toString("utf8", e, i);
    }
    a(jA, "utf8Text");
    function UA(t) {
        var e = t && t.length ? this.write(t) : "";
        return this.lastNeed ? e + "\uFFFD" : e;
    }
    a(UA, "utf8End");
    function qA(t, e) {
        if ((t.length - e) % 2 === 0) {
            var r = t.toString("utf16le", e);
            if (r) {
                var i = r.charCodeAt(r.length - 1);
                if (i >= 55296 && i <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
            }
            return r;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
    }
    a(qA, "utf16Text");
    function HA(t) {
        var e = t && t.length ? this.write(t) : "";
        if (this.lastNeed) {
            var r = this.lastTotal - this.lastNeed;
            return e + this.lastChar.toString("utf16le", 0, r);
        }
        return e;
    }
    a(HA, "utf16End");
    function zA(t, e) {
        var r = (t.length - e) % 3;
        return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
    }
    a(zA, "base64Text");
    function WA(t) {
        var e = t && t.length ? this.write(t) : "";
        return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
    }
    a(WA, "base64End");
    function VA(t) {
        return t.toString(this.encoding);
    }
    a(VA, "simpleWrite");
    function GA(t) {
        return t && t.length ? this.write(t) : "";
    }
    a(GA, "simpleEnd");
});
var No = T(_c106 = (p6, Lg)=>{
    "use strict";
    var Ng = li().codes.ERR_STREAM_PREMATURE_CLOSE;
    function KA(t) {
        var e = !1;
        return function() {
            if (!e) {
                e = !0;
                for(var r = arguments.length, i = new Array(r), n = 0; n < r; n++)i[n] = arguments[n];
                t.apply(this, i);
            }
        };
    }
    a(KA, "once");
    function ZA() {}
    a(ZA, "noop");
    function XA(t) {
        return t.setHeader && typeof t.abort == "function";
    }
    a(XA, "isRequest");
    function Bg(t, e, r) {
        if (typeof e == "function") return Bg(t, null, e);
        e || (e = {}), r = KA(r || ZA);
        var i = e.readable || e.readable !== !1 && t.readable, n = e.writable || e.writable !== !1 && t.writable, o = a(function() {
            t.writable || l();
        }, "onlegacyfinish"), s = t._writableState && t._writableState.finished, l = a(function() {
            n = !1, s = !0, i || r.call(t);
        }, "onfinish"), f = t._readableState && t._readableState.endEmitted, c = a(function() {
            i = !1, f = !0, n || r.call(t);
        }, "onend"), u = a(function(m) {
            r.call(t, m);
        }, "onerror"), h = a(function() {
            var m;
            if (i && !f) return (!t._readableState || !t._readableState.ended) && (m = new Ng), r.call(t, m);
            if (n && !s) return (!t._writableState || !t._writableState.ended) && (m = new Ng), r.call(t, m);
        }, "onclose"), d = a(function() {
            t.req.on("finish", l);
        }, "onrequest");
        return XA(t) ? (t.on("complete", l), t.on("abort", h), t.req ? d() : t.on("request", d)) : n && !t._writableState && (t.on("end", o), t.on("close", o)), t.on("end", c), t.on("finish", l), e.error !== !1 && t.on("error", u), t.on("close", h), function() {
            t.removeListener("complete", l), t.removeListener("abort", h), t.removeListener("request", d), t.req && t.req.removeListener("finish", l), t.removeListener("end", o), t.removeListener("close", o), t.removeListener("finish", l), t.removeListener("end", c), t.removeListener("error", u), t.removeListener("close", h);
        };
    }
    a(Bg, "eos");
    Lg.exports = Bg;
});
_c107 = No;
var Mg = T(_c108 = (y6, $g)=>{
    "use strict";
    var Za;
    function Cr(t, e, r) {
        return e = YA(e), e in t ? Object.defineProperty(t, e, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = r, t;
    }
    a(Cr, "_defineProperty");
    function YA(t) {
        var e = JA(t, "string");
        return typeof e == "symbol" ? e : String(e);
    }
    a(YA, "_toPropertyKey");
    function JA(t, e) {
        if (typeof t != "object" || t === null) return t;
        var r = t[Symbol.toPrimitive];
        if (r !== void 0) {
            var i = r.call(t, e || "default");
            if (typeof i != "object") return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (e === "string" ? String : Number)(t);
    }
    a(JA, "_toPrimitive");
    var QA = No(), Nr = Symbol("lastResolve"), fi = Symbol("lastReject"), Bo = Symbol("error"), Xa = Symbol("ended"), ui = Symbol("lastPromise"), lh = Symbol("handlePromise"), hi = Symbol("stream");
    function Br(t, e) {
        return {
            value: t,
            done: e
        };
    }
    a(Br, "createIterResult");
    function eI(t) {
        var e = t[Nr];
        if (e !== null) {
            var r = t[hi].read();
            r !== null && (t[ui] = null, t[Nr] = null, t[fi] = null, e(Br(r, !1)));
        }
    }
    a(eI, "readAndResolve");
    function tI(t) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(eI, t);
    }
    a(tI, "onReadable");
    function rI(t, e) {
        return function(r, i) {
            t.then(function() {
                if (e[Xa]) {
                    r(Br(void 0, !0));
                    return;
                }
                e[lh](r, i);
            }, i);
        };
    }
    a(rI, "wrapForNext");
    var iI = Object.getPrototypeOf(function() {}), nI = Object.setPrototypeOf((Za = {
        get stream () {
            return this[hi];
        },
        next: a(function() {
            var e = this, r = this[Bo];
            if (r !== null) return Promise.reject(r);
            if (this[Xa]) return Promise.resolve(Br(void 0, !0));
            if (this[hi].destroyed) return new Promise(function(s, l) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
                    e[Bo] ? l(e[Bo]) : s(Br(void 0, !0));
                });
            });
            var i = this[ui], n;
            if (i) n = new Promise(rI(i, this));
            else {
                var o = this[hi].read();
                if (o !== null) return Promise.resolve(Br(o, !1));
                n = new Promise(this[lh]);
            }
            return this[ui] = n, n;
        }, "next")
    }, Cr(Za, Symbol.asyncIterator, function() {
        return this;
    }), Cr(Za, "return", a(function() {
        var e = this;
        return new Promise(function(r, i) {
            e[hi].destroy(null, function(n) {
                if (n) {
                    i(n);
                    return;
                }
                r(Br(void 0, !0));
            });
        });
    }, "_return")), Za), iI), oI = a(function(e) {
        var r, i = Object.create(nI, (r = {}, Cr(r, hi, {
            value: e,
            writable: !0
        }), Cr(r, Nr, {
            value: null,
            writable: !0
        }), Cr(r, fi, {
            value: null,
            writable: !0
        }), Cr(r, Bo, {
            value: null,
            writable: !0
        }), Cr(r, Xa, {
            value: e._readableState.endEmitted,
            writable: !0
        }), Cr(r, lh, {
            value: a(function(o, s) {
                var l = i[hi].read();
                l ? (i[ui] = null, i[Nr] = null, i[fi] = null, o(Br(l, !1))) : (i[Nr] = o, i[fi] = s);
            }, "value"),
            writable: !0
        }), r));
        return i[ui] = null, QA(e, function(n) {
            if (n && n.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var o = i[fi];
                o !== null && (i[ui] = null, i[Nr] = null, i[fi] = null, o(n)), i[Bo] = n;
                return;
            }
            var s = i[Nr];
            s !== null && (i[ui] = null, i[Nr] = null, i[fi] = null, s(Br(void 0, !0))), i[Xa] = !0;
        }), e.on("readable", tI.bind(null, i)), i;
    }, "createReadableStreamAsyncIterator");
    $g.exports = oI;
});
_c109 = Mg;
var Ug = T(_c110 = (g6, jg)=>{
    jg.exports = function() {
        throw new Error("Readable.from is not available in the browser");
    };
});
_c111 = Ug;
var Ga = T(_c112 = (v6, Yg)=>{
    "use strict";
    Yg.exports = ie;
    var pn;
    ie.ReadableState = Wg;
    var b6 = Po().EventEmitter, zg = a(function(e, r) {
        return e.listeners(r).length;
    }, "EElistenerCount"), $o = Gu(), Ya = ri().Buffer, sI = (typeof globalThis < "u" ? globalThis : "object" < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};
    function aI(t) {
        return Ya.from(t);
    }
    a(aI, "_uint8ArrayToBuffer");
    function lI(t) {
        return Ya.isBuffer(t) || t instanceof sI;
    }
    a(lI, "_isUint8Array");
    var ch = Ku(), K;
    ch && ch.debuglog ? K = ch.debuglog("stream") : K = a(function() {}, "debug");
    var cI = pg(), yh = Yu(), fI = Ju(), uI = fI.getHighWaterMark, Ja = li().codes, hI = Ja.ERR_INVALID_ARG_TYPE, dI = Ja.ERR_STREAM_PUSH_AFTER_EOF, pI = Ja.ERR_METHOD_NOT_IMPLEMENTED, mI = Ja.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, mn, fh, uh;
    Gt()(ie, $o);
    var Lo = yh.errorOrDestroy, hh = [
        "error",
        "close",
        "destroy",
        "pause",
        "resume"
    ];
    function yI(t, e, r) {
        if (typeof t.prependListener == "function") return t.prependListener(e, r);
        !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [
            r,
            t._events[e]
        ];
    }
    a(yI, "prependListener");
    function Wg(t, e, r) {
        pn = pn || Dr(), t = t || {}, typeof r != "boolean" && (r = e instanceof pn), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = uI(this, t, "readableHighWaterMark", r), this.buffer = new cI, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = t.emitClose !== !1, this.autoDestroy = !!t.autoDestroy, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (mn || (mn = ah().StringDecoder), this.decoder = new mn(t.encoding), this.encoding = t.encoding);
    }
    a(Wg, "ReadableState");
    function ie(t) {
        if (pn = pn || Dr(), !(this instanceof ie)) return new ie(t);
        var e = this instanceof pn;
        this._readableState = new Wg(t, this, e), this.readable = !0, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), $o.call(this);
    }
    a(ie, "Readable");
    Object.defineProperty(ie.prototype, "destroyed", {
        enumerable: !1,
        get: a(function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed;
        }, "get"),
        set: a(function(e) {
            this._readableState && (this._readableState.destroyed = e);
        }, "set")
    });
    ie.prototype.destroy = yh.destroy;
    ie.prototype._undestroy = yh.undestroy;
    ie.prototype._destroy = function(t, e) {
        e(t);
    };
    ie.prototype.push = function(t, e) {
        var r = this._readableState, i;
        return r.objectMode ? i = !0 : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = Ya.from(t, e), e = ""), i = !0), Vg(this, t, e, !1, i);
    };
    ie.prototype.unshift = function(t) {
        return Vg(this, t, null, !0, !1);
    };
    function Vg(t, e, r, i, n) {
        K("readableAddChunk", e);
        var o = t._readableState;
        if (e === null) o.reading = !1, bI(t, o);
        else {
            var s;
            if (n || (s = wI(o, e)), s) Lo(t, s);
            else if (o.objectMode || e && e.length > 0) if (typeof e != "string" && !o.objectMode && Object.getPrototypeOf(e) !== Ya.prototype && (e = aI(e)), i) o.endEmitted ? Lo(t, new mI) : dh(t, o, e, !0);
            else if (o.ended) Lo(t, new dI);
            else {
                if (o.destroyed) return !1;
                o.reading = !1, o.decoder && !r ? (e = o.decoder.write(e), o.objectMode || e.length !== 0 ? dh(t, o, e, !1) : mh(t, o)) : dh(t, o, e, !1);
            }
            else i || (o.reading = !1, mh(t, o));
        }
        return !o.ended && (o.length < o.highWaterMark || o.length === 0);
    }
    a(Vg, "readableAddChunk");
    function dh(t, e, r, i) {
        e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, i ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Qa(t)), mh(t, e);
    }
    a(dh, "addChunk");
    function wI(t, e) {
        var r;
        return !lI(e) && typeof e != "string" && e !== void 0 && !t.objectMode && (r = new hI("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], e)), r;
    }
    a(wI, "chunkInvalid");
    ie.prototype.isPaused = function() {
        return this._readableState.flowing === !1;
    };
    ie.prototype.setEncoding = function(t) {
        mn || (mn = ah().StringDecoder);
        var e = new mn(t);
        this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
        for(var r = this._readableState.buffer.head, i = ""; r !== null;)i += e.write(r.data), r = r.next;
        return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
    };
    var qg = 1073741824;
    function gI(t) {
        return t >= qg ? t = qg : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    a(gI, "computeNewHighWaterMark");
    function Hg(t, e) {
        return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = gI(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = !0, 0));
    }
    a(Hg, "howMuchToRead");
    ie.prototype.read = function(t) {
        K("read", t), t = parseInt(t, 10);
        var e = this._readableState, r = t;
        if (t !== 0 && (e.emittedReadable = !1), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended)) return K("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? ph(this) : Qa(this), null;
        if (t = Hg(t, e), t === 0 && e.ended) return e.length === 0 && ph(this), null;
        var i = e.needReadable;
        K("need readable", i), (e.length === 0 || e.length - t < e.highWaterMark) && (i = !0, K("length less than watermark", i)), e.ended || e.reading ? (i = !1, K("reading or ended", i)) : i && (K("do read"), e.reading = !0, e.sync = !0, e.length === 0 && (e.needReadable = !0), this._read(e.highWaterMark), e.sync = !1, e.reading || (t = Hg(r, e)));
        var n;
        return t > 0 ? n = Zg(t, e) : n = null, n === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = !0), r !== t && e.ended && ph(this)), n !== null && this.emit("data", n), n;
    };
    function bI(t, e) {
        if (K("onEofChunk"), !e.ended) {
            if (e.decoder) {
                var r = e.decoder.end();
                r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
            }
            e.ended = !0, e.sync ? Qa(t) : (e.needReadable = !1, e.emittedReadable || (e.emittedReadable = !0, Gg(t)));
        }
    }
    a(bI, "onEofChunk");
    function Qa(t) {
        var e = t._readableState;
        K("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = !1, e.emittedReadable || (K("emitReadable", e.flowing), e.emittedReadable = !0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(Gg, t));
    }
    a(Qa, "emitReadable");
    function Gg(t) {
        var e = t._readableState;
        K("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = !1), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, wh(t);
    }
    a(Gg, "emitReadable_");
    function mh(t, e) {
        e.readingMore || (e.readingMore = !0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(vI, t, e));
    }
    a(mh, "maybeReadMore");
    function vI(t, e) {
        for(; !e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0);){
            var r = e.length;
            if (K("maybeReadMore read 0"), t.read(0), r === e.length) break;
        }
        e.readingMore = !1;
    }
    a(vI, "maybeReadMore_");
    ie.prototype._read = function(t) {
        Lo(this, new pI("_read()"));
    };
    ie.prototype.pipe = function(t, e) {
        var r = this, i = this._readableState;
        switch(i.pipesCount){
            case 0:
                i.pipes = t;
                break;
            case 1:
                i.pipes = [
                    i.pipes,
                    t
                ];
                break;
            default:
                i.pipes.push(t);
                break;
        }
        i.pipesCount += 1, K("pipe count=%d opts=%j", i.pipesCount, e);
        var n = (!e || e.end !== !1) && t !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].stdout && t !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].stderr, o = n ? l : y;
        i.endEmitted ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(o) : r.once("end", o), t.on("unpipe", s);
        function s(w, v) {
            K("onunpipe"), w === r && v && v.hasUnpiped === !1 && (v.hasUnpiped = !0, u());
        }
        a(s, "onunpipe");
        function l() {
            K("onend"), t.end();
        }
        a(l, "onend");
        var f = _I(r);
        t.on("drain", f);
        var c = !1;
        function u() {
            K("cleanup"), t.removeListener("close", p), t.removeListener("finish", m), t.removeListener("drain", f), t.removeListener("error", d), t.removeListener("unpipe", s), r.removeListener("end", l), r.removeListener("end", y), r.removeListener("data", h), c = !0, i.awaitDrain && (!t._writableState || t._writableState.needDrain) && f();
        }
        a(u, "cleanup"), r.on("data", h);
        function h(w) {
            K("ondata");
            var v = t.write(w);
            K("dest.write", v), v === !1 && ((i.pipesCount === 1 && i.pipes === t || i.pipesCount > 1 && Xg(i.pipes, t) !== -1) && !c && (K("false write response, pause", i.awaitDrain), i.awaitDrain++), r.pause());
        }
        a(h, "ondata");
        function d(w) {
            K("onerror", w), y(), t.removeListener("error", d), zg(t, "error") === 0 && Lo(t, w);
        }
        a(d, "onerror"), yI(t, "error", d);
        function p() {
            t.removeListener("finish", m), y();
        }
        a(p, "onclose"), t.once("close", p);
        function m() {
            K("onfinish"), t.removeListener("close", p), y();
        }
        a(m, "onfinish"), t.once("finish", m);
        function y() {
            K("unpipe"), r.unpipe(t);
        }
        return a(y, "unpipe"), t.emit("pipe", r), i.flowing || (K("pipe resume"), r.resume()), t;
    };
    function _I(t) {
        return a(function() {
            var r = t._readableState;
            K("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && zg(t, "data") && (r.flowing = !0, wh(t));
        }, "pipeOnDrainFunctionResult");
    }
    a(_I, "pipeOnDrain");
    ie.prototype.unpipe = function(t) {
        var e = this._readableState, r = {
            hasUnpiped: !1
        };
        if (e.pipesCount === 0) return this;
        if (e.pipesCount === 1) return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = !1, t && t.emit("unpipe", this, r), this);
        if (!t) {
            var i = e.pipes, n = e.pipesCount;
            e.pipes = null, e.pipesCount = 0, e.flowing = !1;
            for(var o = 0; o < n; o++)i[o].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this;
        }
        var s = Xg(e.pipes, t);
        return s === -1 ? this : (e.pipes.splice(s, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
    };
    ie.prototype.on = function(t, e) {
        var r = $o.prototype.on.call(this, t, e), i = this._readableState;
        return t === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== !1 && this.resume()) : t === "readable" && !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, K("on readable", i.length, i.reading), i.length ? Qa(this) : i.reading || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(FI, this)), r;
    };
    ie.prototype.addListener = ie.prototype.on;
    ie.prototype.removeListener = function(t, e) {
        var r = $o.prototype.removeListener.call(this, t, e);
        return t === "readable" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(Kg, this), r;
    };
    ie.prototype.removeAllListeners = function(t) {
        var e = $o.prototype.removeAllListeners.apply(this, arguments);
        return (t === "readable" || t === void 0) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(Kg, this), e;
    };
    function Kg(t) {
        var e = t._readableState;
        e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = !0 : t.listenerCount("data") > 0 && t.resume();
    }
    a(Kg, "updateReadableListening");
    function FI(t) {
        K("readable nexttick read 0"), t.read(0);
    }
    a(FI, "nReadingNextTick");
    ie.prototype.resume = function() {
        var t = this._readableState;
        return t.flowing || (K("resume"), t.flowing = !t.readableListening, EI(this, t)), t.paused = !1, this;
    };
    function EI(t, e) {
        e.resumeScheduled || (e.resumeScheduled = !0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(SI, t, e));
    }
    a(EI, "resume");
    function SI(t, e) {
        K("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = !1, t.emit("resume"), wh(t), e.flowing && !e.reading && t.read(0);
    }
    a(SI, "resume_");
    ie.prototype.pause = function() {
        return K("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (K("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
    };
    function wh(t) {
        var e = t._readableState;
        for(K("flow", e.flowing); e.flowing && t.read() !== null;);
    }
    a(wh, "flow");
    ie.prototype.wrap = function(t) {
        var e = this, r = this._readableState, i = !1;
        t.on("end", function() {
            if (K("wrapped end"), r.decoder && !r.ended) {
                var s = r.decoder.end();
                s && s.length && e.push(s);
            }
            e.push(null);
        }), t.on("data", function(s) {
            if (K("wrapped data"), r.decoder && (s = r.decoder.write(s)), !(r.objectMode && s == null) && !(!r.objectMode && (!s || !s.length))) {
                var l = e.push(s);
                l || (i = !0, t.pause());
            }
        });
        for(var n in t)this[n] === void 0 && typeof t[n] == "function" && (this[n] = a(function(l) {
            return a(function() {
                return t[l].apply(t, arguments);
            }, "methodWrapReturnFunction");
        }, "methodWrap")(n));
        for(var o = 0; o < hh.length; o++)t.on(hh[o], this.emit.bind(this, hh[o]));
        return this._read = function(s) {
            K("wrapped _read", s), i && (i = !1, t.resume());
        }, this;
    };
    typeof Symbol == "function" && (ie.prototype[Symbol.asyncIterator] = function() {
        return fh === void 0 && (fh = Mg()), fh(this);
    });
    Object.defineProperty(ie.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: a(function() {
            return this._readableState.highWaterMark;
        }, "get")
    });
    Object.defineProperty(ie.prototype, "readableBuffer", {
        enumerable: !1,
        get: a(function() {
            return this._readableState && this._readableState.buffer;
        }, "get")
    });
    Object.defineProperty(ie.prototype, "readableFlowing", {
        enumerable: !1,
        get: a(function() {
            return this._readableState.flowing;
        }, "get"),
        set: a(function(e) {
            this._readableState && (this._readableState.flowing = e);
        }, "set")
    });
    ie._fromList = Zg;
    Object.defineProperty(ie.prototype, "readableLength", {
        enumerable: !1,
        get: a(function() {
            return this._readableState.length;
        }, "get")
    });
    function Zg(t, e) {
        if (e.length === 0) return null;
        var r;
        return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    a(Zg, "fromList");
    function ph(t) {
        var e = t._readableState;
        K("endReadable", e.endEmitted), e.endEmitted || (e.ended = !0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(xI, e, t));
    }
    a(ph, "endReadable");
    function xI(t, e) {
        if (K("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = !0, e.readable = !1, e.emit("end"), t.autoDestroy)) {
            var r = e._writableState;
            (!r || r.autoDestroy && r.finished) && e.destroy();
        }
    }
    a(xI, "endReadableNT");
    typeof Symbol == "function" && (ie.from = function(t, e) {
        return uh === void 0 && (uh = Ug()), uh(ie, t, e);
    });
    function Xg(t, e) {
        for(var r = 0, i = t.length; r < i; r++)if (t[r] === e) return r;
        return -1;
    }
    a(Xg, "indexOf");
});
_c113 = Ga;
var rl = T((F6, Qg)=>{
    "use strict";
    Qg.exports = lr;
    var el = li().codes, TI = el.ERR_METHOD_NOT_IMPLEMENTED, OI = el.ERR_MULTIPLE_CALLBACK, RI = el.ERR_TRANSFORM_ALREADY_TRANSFORMING, kI = el.ERR_TRANSFORM_WITH_LENGTH_0, tl = Dr();
    Gt()(lr, tl);
    function PI(t, e) {
        var r = this._transformState;
        r.transforming = !1;
        var i = r.writecb;
        if (i === null) return this.emit("error", new OI);
        r.writechunk = null, r.writecb = null, e != null && this.push(e), i(t);
        var n = this._readableState;
        n.reading = !1, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
    }
    a(PI, "afterTransform");
    function lr(t) {
        if (!(this instanceof lr)) return new lr(t);
        tl.call(this, t), this._transformState = {
            afterTransform: PI.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", AI);
    }
    a(lr, "Transform");
    function AI() {
        var t = this;
        typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
            Jg(t, e, r);
        }) : Jg(this, null, null);
    }
    a(AI, "prefinish");
    lr.prototype.push = function(t, e) {
        return this._transformState.needTransform = !1, tl.prototype.push.call(this, t, e);
    };
    lr.prototype._transform = function(t, e, r) {
        r(new TI("_transform()"));
    };
    lr.prototype._write = function(t, e, r) {
        var i = this._transformState;
        if (i.writecb = r, i.writechunk = t, i.writeencoding = e, !i.transforming) {
            var n = this._readableState;
            (i.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
        }
    };
    lr.prototype._read = function(t) {
        var e = this._transformState;
        e.writechunk !== null && !e.transforming ? (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = !0;
    };
    lr.prototype._destroy = function(t, e) {
        tl.prototype._destroy.call(this, t, function(r) {
            e(r);
        });
    };
    function Jg(t, e, r) {
        if (e) return t.emit("error", e);
        if (r != null && t.push(r), t._writableState.length) throw new kI;
        if (t._transformState.transforming) throw new RI;
        return t.push(null);
    }
    a(Jg, "done");
});
var gh = T((S6, tb)=>{
    "use strict";
    tb.exports = Mo;
    var eb = rl();
    Gt()(Mo, eb);
    function Mo(t) {
        if (!(this instanceof Mo)) return new Mo(t);
        eb.call(this, t);
    }
    a(Mo, "PassThrough");
    Mo.prototype._transform = function(t, e, r) {
        r(null, t);
    };
});
var vh = T((T6, ob)=>{
    "use strict";
    var bh;
    function II(t) {
        var e = !1;
        return function() {
            e || (e = !0, t.apply(void 0, arguments));
        };
    }
    a(II, "once");
    var nb = li().codes, DI = nb.ERR_MISSING_ARGS, CI = nb.ERR_STREAM_DESTROYED;
    function rb(t) {
        if (t) throw t;
    }
    a(rb, "noop");
    function NI(t) {
        return t.setHeader && typeof t.abort == "function";
    }
    a(NI, "isRequest");
    function BI(t, e, r, i) {
        i = II(i);
        var n = !1;
        t.on("close", function() {
            n = !0;
        }), bh === void 0 && (bh = No()), bh(t, {
            readable: e,
            writable: r
        }, function(s) {
            if (s) return i(s);
            n = !0, i();
        });
        var o = !1;
        return function(s) {
            if (!n && !o) {
                if (o = !0, NI(t)) return t.abort();
                if (typeof t.destroy == "function") return t.destroy();
                i(s || new CI("pipe"));
            }
        };
    }
    a(BI, "destroyer");
    function ib(t) {
        t();
    }
    a(ib, "call");
    function LI(t, e) {
        return t.pipe(e);
    }
    a(LI, "pipe");
    function $I(t) {
        return !t.length || typeof t[t.length - 1] != "function" ? rb : t.pop();
    }
    a($I, "popCallback");
    function MI() {
        for(var t = arguments.length, e = new Array(t), r = 0; r < t; r++)e[r] = arguments[r];
        var i = $I(e);
        if (Array.isArray(e[0]) && (e = e[0]), e.length < 2) throw new DI("streams");
        var n, o = e.map(function(s, l) {
            var f = l < e.length - 1, c = l > 0;
            return BI(s, f, c, function(u) {
                n || (n = u), u && o.forEach(ib), !f && (o.forEach(ib), i(n));
            });
        });
        return e.reduce(LI);
    }
    a(MI, "pipeline");
    ob.exports = MI;
});
var ab = T((R6, sb)=>{
    sb.exports = yt;
    var _h = Po().EventEmitter, jI = Gt();
    jI(yt, _h);
    yt.Readable = Ga();
    yt.Writable = za();
    yt.Duplex = Dr();
    yt.Transform = rl();
    yt.PassThrough = gh();
    yt.finished = No();
    yt.pipeline = vh();
    yt.Stream = yt;
    function yt() {
        _h.call(this);
    }
    a(yt, "Stream");
    yt.prototype.pipe = function(t, e) {
        var r = this;
        function i(u) {
            t.writable && t.write(u) === !1 && r.pause && r.pause();
        }
        a(i, "ondata"), r.on("data", i);
        function n() {
            r.readable && r.resume && r.resume();
        }
        a(n, "ondrain"), t.on("drain", n), !t._isStdio && (!e || e.end !== !1) && (r.on("end", s), r.on("close", l));
        var o = !1;
        function s() {
            o || (o = !0, t.end());
        }
        a(s, "onend");
        function l() {
            o || (o = !0, typeof t.destroy == "function" && t.destroy());
        }
        a(l, "onclose");
        function f(u) {
            if (c(), _h.listenerCount(this, "error") === 0) throw u;
        }
        a(f, "onerror"), r.on("error", f), t.on("error", f);
        function c() {
            r.removeListener("data", i), t.removeListener("drain", n), r.removeListener("end", s), r.removeListener("close", l), r.removeListener("error", f), t.removeListener("error", f), r.removeListener("end", c), r.removeListener("close", c), t.removeListener("close", c);
        }
        return a(c, "cleanup"), r.on("end", c), r.on("close", c), t.on("close", c), t.emit("pipe", r), t;
    };
});
var cb = T((yn)=>{
    "use strict";
    Object.defineProperty(yn, "__esModule", {
        value: !0
    });
    yn.Writable = yn.Readable = void 0;
    var lb = ab();
    Object.defineProperty(yn, "Readable", {
        enumerable: !0,
        get: a(function() {
            return lb.Readable;
        }, "get")
    });
    Object.defineProperty(yn, "Writable", {
        enumerable: !0,
        get: a(function() {
            return lb.Writable;
        }, "get")
    });
});
var Fh = T(_c114 = (il)=>{
    "use strict";
    Object.defineProperty(il, "__esModule", {
        value: !0
    });
    il.EventEmitter = void 0;
    var UI = Po();
    Object.defineProperty(il, "EventEmitter", {
        enumerable: !0,
        get: a(function() {
            return UI.EventEmitter;
        }, "get")
    });
});
_c115 = Fh;
var fb = T((nl)=>{
    "use strict";
    Object.defineProperty(nl, "__esModule", {
        value: !0
    });
    nl.FileHandle = void 0;
    var Ue = Ar(), qI = Fh(), Sh = class Sh extends qI.EventEmitter {
        getAsyncId() {
            return this.fd;
        }
        appendFile(e, r) {
            return (0, Ue.promisify)(this.fs, "appendFile")(this.fd, e, r);
        }
        chmod(e) {
            return (0, Ue.promisify)(this.fs, "fchmod")(this.fd, e);
        }
        chown(e, r) {
            return (0, Ue.promisify)(this.fs, "fchown")(this.fd, e, r);
        }
        close() {
            if (this.fd === -1) return Promise.resolve();
            if (this.closePromise) return this.closePromise;
            if (this.refs--, this.refs === 0) {
                let e = this.fd;
                this.fd = -1, this.closePromise = (0, Ue.promisify)(this.fs, "close")(e).finally(()=>{
                    this.closePromise = null;
                });
            } else this.closePromise = new Promise((e, r)=>{
                this.closeResolve = e, this.closeReject = r;
            }).finally(()=>{
                this.closePromise = null, this.closeReject = void 0, this.closeResolve = void 0;
            });
            return this.emit("close"), this.closePromise;
        }
        datasync() {
            return (0, Ue.promisify)(this.fs, "fdatasync")(this.fd);
        }
        createReadStream(e) {
            return this.fs.createReadStream("", {
                ...e,
                fd: this
            });
        }
        createWriteStream(e) {
            return this.fs.createWriteStream("", {
                ...e,
                fd: this
            });
        }
        readableWebStream() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            let { type: r = "bytes", autoClose: i = !1 } = e, n = 0;
            if (this.fd === -1) throw new Error("The FileHandle is closed");
            if (this.closePromise) throw new Error("The FileHandle is closing");
            if (this.readableWebStreamLocked) throw new Error("An error will be thrown if this method is called more than once or is called after the FileHandle is closed or closing.");
            this.readableWebStreamLocked = !0, this.ref();
            let o = a(()=>{
                this.readableWebStreamLocked = !1, this.unref(), i && this.close().catch(()=>{});
            }, "unlockAndCleanup");
            return new ReadableStream({
                type: r === "bytes" ? "bytes" : void 0,
                autoAllocateChunkSize: 16384,
                pull: a(async (s)=>{
                    try {
                        var _s_byobRequest;
                        let l = (_s_byobRequest = s.byobRequest) === null || _s_byobRequest === void 0 ? void 0 : _s_byobRequest.view;
                        if (!l) {
                            let c = new Uint8Array(16384), u = await this.read(c, 0, c.length, n);
                            if (u.bytesRead === 0) {
                                s.close(), o();
                                return;
                            }
                            n += u.bytesRead, s.enqueue(c.slice(0, u.bytesRead));
                            return;
                        }
                        let f = await this.read(l, l.byteOffset, l.byteLength, n);
                        if (f.bytesRead === 0) {
                            s.close(), o();
                            return;
                        }
                        n += f.bytesRead, s.byobRequest.respond(f.bytesRead);
                    } catch (l) {
                        s.error(l), o();
                    }
                }, "pull"),
                cancel: a(async ()=>{
                    o();
                }, "cancel")
            });
        }
        async read(e, r, i, n) {
            let o = n !== null && n !== void 0 ? n : this.position, s = await (0, Ue.promisify)(this.fs, "read", (l)=>({
                    bytesRead: l,
                    buffer: e
                }))(this.fd, e, r, i, o);
            return n == null && (this.position += s.bytesRead), s;
        }
        readv(e, r) {
            return (0, Ue.promisify)(this.fs, "readv", (i)=>({
                    bytesRead: i,
                    buffers: e
                }))(this.fd, e, r);
        }
        readFile(e) {
            return (0, Ue.promisify)(this.fs, "readFile")(this.fd, e);
        }
        stat(e) {
            return (0, Ue.promisify)(this.fs, "fstat")(this.fd, e);
        }
        sync() {
            return (0, Ue.promisify)(this.fs, "fsync")(this.fd);
        }
        truncate(e) {
            return (0, Ue.promisify)(this.fs, "ftruncate")(this.fd, e);
        }
        utimes(e, r) {
            return (0, Ue.promisify)(this.fs, "futimes")(this.fd, e, r);
        }
        async write(e, r, i, n) {
            let o = typeof n != "number", s = o ? this.position : n, l = await (0, Ue.promisify)(this.fs, "write", (f)=>({
                    bytesWritten: f,
                    buffer: e
                }))(this.fd, e, r, i, s);
            return o && (this.position += l.bytesWritten), l;
        }
        writev(e, r) {
            return (0, Ue.promisify)(this.fs, "writev", (i)=>({
                    bytesWritten: i,
                    buffers: e
                }))(this.fd, e, r);
        }
        writeFile(e, r) {
            return (0, Ue.promisify)(this.fs, "writeFile")(this.fd, e, r);
        }
        async [Symbol.asyncDispose]() {
            await this.close();
        }
        ref() {
            this.refs++;
        }
        unref() {
            this.refs--, this.refs === 0 && (this.fd = -1, this.closeResolve && (0, Ue.promisify)(this.fs, "close")(this.fd).then(this.closeResolve, this.closeReject));
        }
        constructor(e, r){
            super(), this.refs = 1, this.closePromise = null, this.position = 0, this.readableWebStreamLocked = !1, this.fs = e, this.fd = r;
        }
    };
    a(Sh, "FileHandle");
    var Eh = Sh;
    nl.FileHandle = Eh;
});
var ub = T((ol)=>{
    "use strict";
    Object.defineProperty(ol, "__esModule", {
        value: !0
    });
    ol.FsPromises = void 0;
    var ne = Ar(), HI = kt(), Oh = class Oh {
        startWatching() {
            try {
                this.watcher = this.fs.watch(this.path, this.options, (e, r)=>{
                    this.enqueueEvent({
                        eventType: e,
                        filename: r
                    });
                });
            } catch (e) {
                throw this.finish(), e;
            }
        }
        enqueueEvent(e) {
            if (!this.finished) {
                if (this.eventQueue.length >= this.maxQueue) if (this.overflow === "throw") {
                    let r = new Error("Watch queue overflow: more than ".concat(this.maxQueue, " events queued"));
                    this.finish(r);
                    return;
                } else this.eventQueue.shift(), console.warn("Watch queue overflow: dropping event due to exceeding maxQueue of ".concat(this.maxQueue));
                if (this.eventQueue.push(e), this.resolveQueue.length > 0) {
                    let { resolve: r } = this.resolveQueue.shift(), i = this.eventQueue.shift();
                    r({
                        value: i,
                        done: !1
                    });
                }
            }
        }
        finish(e) {
            if (!this.finished) for(this.finished = !0, this.watcher && (this.watcher.close(), this.watcher = null); this.resolveQueue.length > 0;){
                let { resolve: r, reject: i } = this.resolveQueue.shift();
                e ? i(e) : r({
                    value: void 0,
                    done: !0
                });
            }
        }
        async next() {
            return this.finished ? {
                value: void 0,
                done: !0
            } : this.eventQueue.length > 0 ? {
                value: this.eventQueue.shift(),
                done: !1
            } : new Promise((e, r)=>{
                this.resolveQueue.push({
                    resolve: e,
                    reject: r
                });
            });
        }
        async return() {
            return this.finish(), {
                value: void 0,
                done: !0
            };
        }
        async throw(e) {
            throw this.finish(e), e;
        }
        [Symbol.asyncIterator]() {
            return this;
        }
        constructor(e, r, i = {}){
            if (this.fs = e, this.path = r, this.options = i, this.eventQueue = [], this.resolveQueue = [], this.finished = !1, this.maxQueue = i.maxQueue || 2048, this.overflow = i.overflow || "ignore", this.startWatching(), i.signal) {
                if (i.signal.aborted) {
                    this.finish();
                    return;
                }
                i.signal.addEventListener("abort", ()=>{
                    this.finish();
                });
            }
        }
    };
    a(Oh, "FSWatchAsyncIterator");
    var xh = Oh, Rh = class Rh {
        constructor(e, r){
            var _this = this;
            this.fs = e, this.FileHandle = r, this.constants = HI.constants, this.cp = (0, ne.promisify)(this.fs, "cp"), this.opendir = (0, ne.promisify)(this.fs, "opendir"), this.statfs = (0, ne.promisify)(this.fs, "statfs"), this.lutimes = (0, ne.promisify)(this.fs, "lutimes"), this.glob = (0, ne.promisify)(this.fs, "glob"), this.access = (0, ne.promisify)(this.fs, "access"), this.chmod = (0, ne.promisify)(this.fs, "chmod"), this.chown = (0, ne.promisify)(this.fs, "chown"), this.copyFile = (0, ne.promisify)(this.fs, "copyFile"), this.lchmod = (0, ne.promisify)(this.fs, "lchmod"), this.lchown = (0, ne.promisify)(this.fs, "lchown"), this.link = (0, ne.promisify)(this.fs, "link"), this.lstat = (0, ne.promisify)(this.fs, "lstat"), this.mkdir = (0, ne.promisify)(this.fs, "mkdir"), this.mkdtemp = (0, ne.promisify)(this.fs, "mkdtemp"), this.readdir = (0, ne.promisify)(this.fs, "readdir"), this.readlink = (0, ne.promisify)(this.fs, "readlink"), this.realpath = (0, ne.promisify)(this.fs, "realpath"), this.rename = (0, ne.promisify)(this.fs, "rename"), this.rmdir = (0, ne.promisify)(this.fs, "rmdir"), this.rm = (0, ne.promisify)(this.fs, "rm"), this.stat = (0, ne.promisify)(this.fs, "stat"), this.symlink = (0, ne.promisify)(this.fs, "symlink"), this.truncate = (0, ne.promisify)(this.fs, "truncate"), this.unlink = (0, ne.promisify)(this.fs, "unlink"), this.utimes = (0, ne.promisify)(this.fs, "utimes"), this.readFile = (i, n)=>(0, ne.promisify)(this.fs, "readFile")(i instanceof this.FileHandle ? i.fd : i, n), this.appendFile = (i, n, o)=>(0, ne.promisify)(this.fs, "appendFile")(i instanceof this.FileHandle ? i.fd : i, n, o), this.open = function(i) {
                let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "r", o = arguments.length > 2 ? arguments[2] : void 0;
                return (0, ne.promisify)(_this.fs, "open", (s)=>new _this.FileHandle(_this.fs, s))(i, n, o);
            }, this.writeFile = (i, n, o)=>((0, ne.isReadableStream)(n) ? (0, ne.streamToBuffer)(n) : Promise.resolve(n)).then((l)=>(0, ne.promisify)(this.fs, "writeFile")(i instanceof this.FileHandle ? i.fd : i, l, o)), this.watch = (i, n)=>{
                let o = typeof n == "string" ? {
                    encoding: n
                } : n || {};
                return new xh(this.fs, i, o);
            };
        }
    };
    a(Rh, "FsPromises");
    var Th = Rh;
    ol.FsPromises = Th;
});
var hb = T((sl)=>{
    "use strict";
    Object.defineProperty(sl, "__esModule", {
        value: !0
    });
    sl.printTree = void 0;
    var zI = a(function() {
        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", e = arguments.length > 1 ? arguments[1] : void 0;
        let r = "", i = e.length - 1;
        for(; i >= 0 && !e[i]; i--);
        for(let n = 0; n <= i; n++){
            let o = e[n];
            if (!o) continue;
            let s = n === i, l = o(t + (s ? " " : "\u2502") + "  "), f = l ? s ? "\u2514\u2500" : "\u251C\u2500" : "\u2502";
            r += "\n" + t + f + (l ? " " + l : "");
        }
        return r;
    }, "printTree");
    sl.printTree = zI;
});
var db = T((al)=>{
    "use strict";
    Object.defineProperty(al, "__esModule", {
        value: !0
    });
    al.printBinary = void 0;
    var WI = a(function() {
        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", e = arguments.length > 1 ? arguments[1] : void 0;
        let r = e[0], i = e[1], n = "";
        return r && (n += "\n" + t + "\u2190 " + r(t + "  ")), i && (n += "\n" + t + "\u2192 " + i(t + "  ")), n;
    }, "printBinary");
    al.printBinary = WI;
});
var pb = T((ll)=>{
    "use strict";
    Object.defineProperty(ll, "__esModule", {
        value: !0
    });
    ll.printJson = void 0;
    var VI = a(function() {
        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", e = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;
        return (JSON.stringify(e, null, r) || "nil").split("\n").join("\n" + t);
    }, "printJson");
    ll.printJson = VI;
});
var mb = T((jo)=>{
    "use strict";
    Object.defineProperty(jo, "__esModule", {
        value: !0
    });
    var kh = (Vf(), wm(Wf));
    kh.__exportStar(hb(), jo);
    kh.__exportStar(db(), jo);
    kh.__exportStar(pb(), jo);
});
var yb = T((qe)=>{
    "use strict";
    Object.defineProperty(qe, "__esModule", {
        value: !0
    });
    qe.newNotAllowedError = qe.newTypeMismatchError = qe.newNotFoundError = qe.assertCanWrite = qe.assertName = qe.basename = qe.ctx = void 0;
    var GI = a(function() {
        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return {
            separator: "/",
            syncHandleAllowed: !1,
            mode: "read",
            ...t
        };
    }, "ctx");
    qe.ctx = GI;
    var KI = a((t, e)=>{
        t[t.length - 1] === e && (t = t.slice(0, -1));
        let r = t.lastIndexOf(e);
        return r === -1 ? t : t.slice(r + 1);
    }, "basename");
    qe.basename = KI;
    var ZI = /^(\.{1,2})$|^(.*([\/\\]).*)$/, XI = a((t, e, r)=>{
        if (!t || ZI.test(t)) throw new TypeError("Failed to execute '".concat(e, "' on '").concat(r, "': Name is not allowed."));
    }, "assertName");
    qe.assertName = XI;
    var YI = a((t)=>{
        if (t !== "readwrite") throw new DOMException("The request is not allowed by the user agent or the platform in the current context.", "NotAllowedError");
    }, "assertCanWrite");
    qe.assertCanWrite = YI;
    var JI = a(()=>new DOMException("A requested file or directory could not be found at the time an operation was processed.", "NotFoundError"), "newNotFoundError");
    qe.newNotFoundError = JI;
    var QI = a(()=>new DOMException("The path supplied exists, but was not an entry of requested type.", "TypeMismatchError"), "newTypeMismatchError");
    qe.newTypeMismatchError = QI;
    var eD = a(()=>new DOMException("Permission not granted.", "NotAllowedError"), "newNotAllowedError");
    qe.newNotAllowedError = eD;
});
var wb = T((Uo)=>{
    "use strict";
    Object.defineProperty(Uo, "__esModule", {
        value: !0
    });
    Uo.toTreeSync = void 0;
    var tD = mb(), rD = yb(), iD = a(function(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let r = e.separator || "/", i = e.dir || r;
        i[i.length - 1] !== r && (i += r);
        var _e_depth;
        let n = e.tab || "", o = (_e_depth = e.depth) !== null && _e_depth !== void 0 ? _e_depth : 10, s = " (...)";
        if (o > 0) {
            let f = t.readdirSync(i, {
                withFileTypes: !0
            });
            s = (0, tD.printTree)(n, f.map((c)=>(u)=>c.isDirectory() ? (0, Uo.toTreeSync)(t, {
                        dir: i + c.name,
                        depth: o - 1,
                        tab: u
                    }) : c.isSymbolicLink() ? "" + c.name + " \u2192 " + t.readlinkSync(i + c.name) : "" + c.name));
        }
        return (0, rD.basename)(i, r) + r + s;
    }, "toTreeSync");
    Uo.toTreeSync = iD;
});
var vb = T((j)=>{
    "use strict";
    Object.defineProperty(j, "__esModule", {
        value: !0
    });
    j.getWriteFileOptions = j.writeFileDefaults = j.getRealpathOptsAndCb = j.getRealpathOptions = j.getStatfsOptsAndCb = j.getStatfsOptions = j.getStatOptsAndCb = j.getStatOptions = j.getAppendFileOptsAndCb = j.getAppendFileOpts = j.getOpendirOptsAndCb = j.getOpendirOptions = j.getReaddirOptsAndCb = j.getReaddirOptions = j.getReadFileOptions = j.getRmOptsAndCb = j.getRmdirOptions = j.getDefaultOptsAndCb = j.getDefaultOpts = j.optsDefaults = j.getMkdirOptions = void 0;
    j.getOptions = bb;
    j.optsGenerator = cr;
    j.optsAndCbGenerator = di;
    var cl = Zi(), nD = co(), Ph = Ar(), gb = {
        mode: 511,
        recursive: !1
    }, oD = a((t)=>typeof t == "number" ? Object.assign({}, gb, {
            mode: t
        }) : Object.assign({}, gb, t), "getMkdirOptions");
    j.getMkdirOptions = oD;
    var sD = a((t)=>"Expected options to be either an object or a string, but got ".concat(t, " instead"), "ERRSTR_OPTS");
    function bb(t, e) {
        let r;
        if (e) {
            let i = typeof e;
            switch(i){
                case "string":
                    r = Object.assign({}, t, {
                        encoding: e
                    });
                    break;
                case "object":
                    r = Object.assign({}, t, e);
                    break;
                default:
                    throw TypeError(sD(i));
            }
        } else return t;
        return r.encoding !== "buffer" && (0, nD.assertEncoding)(r.encoding), r;
    }
    a(bb, "getOptions");
    function cr(t) {
        return (e)=>bb(t, e);
    }
    a(cr, "optsGenerator");
    function di(t) {
        return (e, r)=>typeof e == "function" ? [
                t(),
                e
            ] : [
                t(e),
                (0, Ph.validateCallback)(r)
            ];
    }
    a(di, "optsAndCbGenerator");
    j.optsDefaults = {
        encoding: "utf8"
    };
    j.getDefaultOpts = cr(j.optsDefaults);
    j.getDefaultOptsAndCb = di(j.getDefaultOpts);
    var aD = {
        recursive: !1
    }, lD = a((t)=>Object.assign({}, aD, t), "getRmdirOptions");
    j.getRmdirOptions = lD;
    var cD = cr(j.optsDefaults);
    j.getRmOptsAndCb = di(cD);
    var fD = {
        flag: "r"
    };
    j.getReadFileOptions = cr(fD);
    var uD = {
        encoding: "utf8",
        recursive: !1,
        withFileTypes: !1
    };
    j.getReaddirOptions = cr(uD);
    j.getReaddirOptsAndCb = di(j.getReaddirOptions);
    var hD = {
        encoding: "utf8",
        bufferSize: 32,
        recursive: !1
    };
    j.getOpendirOptions = cr(hD);
    j.getOpendirOptsAndCb = di(j.getOpendirOptions);
    var dD = {
        encoding: "utf8",
        mode: 438,
        flag: cl.FLAGS[cl.FLAGS.a]
    };
    j.getAppendFileOpts = cr(dD);
    j.getAppendFileOptsAndCb = di(j.getAppendFileOpts);
    var pD = {
        bigint: !1
    }, mD = a(function() {
        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return Object.assign({}, pD, t);
    }, "getStatOptions");
    j.getStatOptions = mD;
    var yD = a((t, e)=>typeof t == "function" ? [
            (0, j.getStatOptions)(),
            t
        ] : [
            (0, j.getStatOptions)(t),
            (0, Ph.validateCallback)(e)
        ], "getStatOptsAndCb");
    j.getStatOptsAndCb = yD;
    var wD = {
        bigint: !1
    }, gD = a(function() {
        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return Object.assign({}, wD, t);
    }, "getStatfsOptions");
    j.getStatfsOptions = gD;
    var bD = a((t, e)=>typeof t == "function" ? [
            (0, j.getStatfsOptions)(),
            t
        ] : [
            (0, j.getStatfsOptions)(t),
            (0, Ph.validateCallback)(e)
        ], "getStatfsOptsAndCb");
    j.getStatfsOptsAndCb = bD;
    var vD = j.optsDefaults;
    j.getRealpathOptions = cr(vD);
    j.getRealpathOptsAndCb = di(j.getRealpathOptions);
    j.writeFileDefaults = {
        encoding: "utf8",
        mode: 438,
        flag: cl.FLAGS[cl.FLAGS.w]
    };
    j.getWriteFileOptions = cr(j.writeFileDefaults);
});
var Fb = T(_c116 = (fl)=>{
    "use strict";
    Object.defineProperty(fl, "__esModule", {
        value: !0
    });
    fl.Dir = void 0;
    var _b = Ar(), _D = Xs(), pi = lo(), Ih = class Ih {
        closeBase() {}
        readBase(e) {
            let r, i, n, o;
            do {
                do if ({ done: r, value: i } = e[e.length - 1].next(), !r) [n, o] = i;
                else break;
                while (n === "." || n === "..")
                if (r) {
                    if (e.pop(), e.length === 0) break;
                    r = !1;
                } else return this.options.recursive && o.children.size && e.push(o.children[Symbol.iterator]()), _D.default.build(o, this.options.encoding);
            }while (!r)
            return null;
        }
        close(e) {
            if (e === void 0) return this.closed ? Promise.reject(new pi.Error("ERR_DIR_CLOSED")) : new Promise((r, i)=>{
                this.close((n)=>{
                    n ? i(n) : r();
                });
            });
            if ((0, _b.validateCallback)(e), this.closed) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(e, new pi.Error("ERR_DIR_CLOSED"));
                return;
            }
            if (this.operationQueue !== null) {
                this.operationQueue.push(()=>{
                    this.close(e);
                });
                return;
            }
            this.closed = !0;
            try {
                this.closeBase(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(e);
            } catch (r) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(e, r);
            }
        }
        closeSync() {
            if (this.closed) throw new pi.Error("ERR_DIR_CLOSED");
            if (this.operationQueue !== null) throw new pi.Error("ERR_DIR_CONCURRENT_OPERATION");
            this.closed = !0, this.closeBase();
        }
        read(e) {
            if (e === void 0) return new Promise((r, i)=>{
                this.read((n, o)=>{
                    n ? i(n) : r(o !== null && o !== void 0 ? o : null);
                });
            });
            if ((0, _b.validateCallback)(e), this.closed) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(e, new pi.Error("ERR_DIR_CLOSED"));
                return;
            }
            if (this.operationQueue !== null) {
                this.operationQueue.push(()=>{
                    this.read(e);
                });
                return;
            }
            this.operationQueue = [];
            try {
                let r = this.readBase(this.iteratorInfo);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(()=>{
                    let i = this.operationQueue;
                    this.operationQueue = null;
                    for (let n of i)n();
                    e(null, r);
                });
            } catch (r) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(()=>{
                    let i = this.operationQueue;
                    this.operationQueue = null;
                    for (let n of i)n();
                    e(r);
                });
            }
        }
        readSync() {
            if (this.closed) throw new pi.Error("ERR_DIR_CLOSED");
            if (this.operationQueue !== null) throw new pi.Error("ERR_DIR_CONCURRENT_OPERATION");
            return this.readBase(this.iteratorInfo);
        }
        [Symbol.asyncIterator]() {
            return {
                next: a(async ()=>{
                    try {
                        let e = await this.read();
                        return e !== null ? {
                            done: !1,
                            value: e
                        } : {
                            done: !0,
                            value: void 0
                        };
                    } catch (e) {
                        throw e;
                    }
                }, "next"),
                [Symbol.asyncIterator] () {
                    return this;
                }
            };
        }
        constructor(e, r){
            this.link = e, this.options = r, this.iteratorInfo = [], this.closed = !1, this.operationQueue = null, this.path = e.getPath(), this.iteratorInfo.push(e.children[Symbol.iterator]());
        }
    };
    a(Ih, "Dir");
    var Ah = Ih;
    fl.Dir = Ah;
});
_c117 = Fb;
var Eb = T(_c118 = (fr)=>{
    "use strict";
    Object.defineProperty(fr, "__esModule", {
        value: !0
    });
    fr.toMatcher = fr.toRegex = void 0;
    var FD = a((t)=>/[.^$+{}()|\\]/.test(t) ? "\\".concat(t) : t, "escapeRe"), ED = a((t, e, r, i)=>{
        let n = e, o = [], s = "", l = 1;
        for(; n < t.length && l > 0;){
            let u = t[n];
            if (u === "(") l++, s += u, n++;
            else if (u === ")") if (l--, l === 0) {
                o.push(s), n++;
                break;
            } else s += u, n++;
            else u === "|" && l === 1 ? (o.push(s), s = "", n++) : (s += u, n++);
        }
        if (l !== 0) return;
        let f = "", c = o.length;
        for(let u = 0; u < c; u++)f += (f ? "|" : "") + (0, fr.toRegex)(o[u], i).source.replace(/^\^/, "").replace(/\$$/, "");
        switch(r){
            case "?":
                return [
                    "(?:".concat(f, ")?"),
                    n
                ];
            case "*":
                return [
                    "(?:".concat(f, ")*"),
                    n
                ];
            case "+":
                return [
                    "(?:".concat(f, ")+"),
                    n
                ];
            case "@":
                return [
                    "(?:".concat(f, ")"),
                    n
                ];
            case "!":
                return [
                    "(?!".concat(f, ")[^/]*"),
                    n
                ];
        }
    }, "parseExtGlob"), SD = a((t, e)=>{
        let r = "", i = 0, n = a(()=>{
            i++;
            let l = [], f = "", c = !1;
            for(; i < t.length;){
                let h = t[i];
                if (h === "}") {
                    l.push(f), i++, c = !0;
                    break;
                }
                if (h === ",") {
                    l.push(f), f = "", i++;
                    continue;
                }
                f += h, i++;
            }
            return c ? "(?:".concat(l.map((h)=>(0, fr.toRegex)(h, e).source.replace(/^\^/, "").replace(/\$$/, "")).join("|"), ")") : "\\{" + FD(f);
        }, "parseBraceGroup"), o = !!(e === null || e === void 0 ? void 0 : e.extglob);
        for(; i < t.length;){
            let l = t[i];
            if (o && t[i + 1] === "(" && (l === "?" || l === "*" || l === "+" || l === "@" || l === "!")) {
                let f = ED(t, i + 2, l, e);
                if (f) {
                    r += f[0], i = f[1];
                    continue;
                }
            }
            switch(l){
                case "*":
                    {
                        if (t[i + 1] === "*") {
                            let f = i + 2;
                            for(; t[f] === "*";)f++;
                            t[f] === "/" ? (r += "(?:.*/)?", i = f + 1) : (r += ".*", i = f);
                        } else r += "[^/]*", i++;
                        break;
                    }
                case "?":
                    r += "[^/]", i++;
                    break;
                case "[":
                    {
                        let f = "[";
                        for(i++, i < t.length && t[i] === "!" && (f += "^", i++), i < t.length && t[i] === "]" && (f += "]", i++); i < t.length && t[i] !== "]";){
                            let c = t[i];
                            f += c === "\\" ? "\\\\" : c, i++;
                        }
                        if (i < t.length && t[i] === "]") f += "]", i++;
                        else {
                            r += "\\[";
                            continue;
                        }
                        r += f;
                        break;
                    }
                case "{":
                    {
                        r += n();
                        break;
                    }
                case "/":
                    r += "/", i++;
                    break;
                case ".":
                case "^":
                case "$":
                case "+":
                case "(":
                case ")":
                case "|":
                case "\\":
                    r += "\\".concat(l), i++;
                    break;
                default:
                    r += l, i++;
                    break;
            }
        }
        let s = (e === null || e === void 0 ? void 0 : e.nocase) ? "i" : "";
        return new RegExp("^" + r + "$", s);
    }, "toRegex");
    fr.toRegex = SD;
    var xD = /^\/(.{1,4096})\/([gimsuy]{0,6})$/, TD = a((t, e)=>{
        let r = [], i = Array.isArray(t) ? t : [
            t
        ];
        for (let n of i)if (typeof n == "string") {
            let o = xD.exec(n);
            if (o) {
                let [, s, l] = o;
                r.push(new RegExp(s, l));
            } else r.push((0, fr.toRegex)(n, e));
        } else r.push(n);
        return r.length ? new Function("p", "return " + r.map((n)=>n + ".test(p)").join("||")) : ()=>!1;
    }, "toMatcher");
    fr.toMatcher = TD;
});
_c119 = Eb;
var Tb = T(_c120 = (Ch)=>{
    "use strict";
    Object.defineProperty(Ch, "__esModule", {
        value: !0
    });
    Ch.globSync = ID;
    var mi = Wi(), OD = Eb(), Sb = Ar(), RD = mi.posix.join, kD = mi.posix.relative, PD = mi.posix.resolve;
    function xb(t, e) {
        return (0, OD.toRegex)(e).test(t);
    }
    a(xb, "matchesPattern");
    function AD(t, e) {
        return e ? typeof e == "function" ? e(t) : (Array.isArray(e) ? e : [
            e
        ]).some((i)=>xb(t, i)) : !1;
    }
    a(AD, "isExcluded");
    function Dh(t, e, r, i) {
        let n = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
        var _i_maxdepth;
        let o = [], s = (_i_maxdepth = i.maxdepth) !== null && _i_maxdepth !== void 0 ? _i_maxdepth : 1 / 0, l = i.cwd ? (0, Sb.pathToFilename)(i.cwd) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cwd();
        if (n > s) return o;
        try {
            let f = t.readdirSync(e, {
                withFileTypes: !0
            });
            for (let c of f){
                let u = RD(e, c.name.toString()), h = kD(l, u);
                if (AD(h, i.exclude)) continue;
                if (r.some((p)=>xb(h, p)) && o.push(h), c.isDirectory() && n < s) {
                    let p = Dh(t, u, r, i, n + 1);
                    o.push(...p);
                }
            }
        } catch (e) {}
        return o;
    }
    a(Dh, "walkDirectory");
    function ID(t, e) {
        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        let i = r.cwd ? (0, Sb.pathToFilename)(r.cwd) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cwd(), n = PD(i), o = {
            cwd: n,
            exclude: r.exclude,
            maxdepth: r.maxdepth,
            withFileTypes: r.withFileTypes || !1
        }, s = [];
        if (mi.posix.isAbsolute(e)) {
            let l = mi.posix.dirname(e), f = mi.posix.basename(e), c = Dh(t, l, [
                f
            ], {
                ...o,
                cwd: l
            });
            s.push(...c.map((u)=>mi.posix.resolve(l, u)));
        } else {
            let l = Dh(t, n, [
                e
            ], o);
            s.push(...l);
        }
        return s = [
            ...new Set(s)
        ].sort(), s;
    }
    a(ID, "globSync");
});
_c121 = Tb;
var Db = T(_c122 = (ot)=>{
    "use strict";
    Object.defineProperty(ot, "__esModule", {
        value: !0
    });
    ot.FSWatcher = ot.StatWatcher = ot.Volume = void 0;
    ot.pathToSteps = ZD;
    ot.dataToStr = XD;
    ot.toUnixTimestamp = nt;
    var xe = Wi(), $h = Z0(), Nh = Sf(), DD = Xs(), CD = X0(), bn = Tr(), ml = au(), ND = Y0(), yl = cb(), BD = kt(), Pb = Fh(), yi = co(), LD = fb(), Ab = Bf(), $D = ub(), MD = wb(), hl = Zi(), jD = lo(), te = vb(), I = Ar(), UD = Fb(), Le = ya(), qD = xe.resolve, { O_SYMLINK: Ob, F_OK: Bh, R_OK: HD, W_OK: zD, X_OK: WD, COPYFILE_EXCL: VD, COPYFILE_FICLONE_FORCE: GD } = BD.constants, i4 = xe.posix ? xe.posix.sep : xe.sep, ul = xe.posix ? xe.posix.relative : xe.relative, Lh = xe.posix ? xe.posix.join : xe.join, Rb = xe.posix ? xe.posix.dirname : xe.dirname, kb = xe.posix ? xe.posix.normalize : xe.normalize, KD = 128;
    function ZD(t) {
        return (0, Le.filenameToSteps)((0, I.pathToFilename)(t));
    }
    a(ZD, "pathToSteps");
    function XD(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : yi.ENCODING_UTF8;
        return bn.Buffer.isBuffer(t) ? t.toString(e) : t instanceof Uint8Array ? (0, bn.bufferFrom)(t).toString(e) : String(t);
    }
    a(XD, "dataToStr");
    function nt(t) {
        if (typeof t == "string" && +t == t) return +t;
        if (t instanceof Date) return t.getTime() / 1e3;
        if (isFinite(t)) return t < 0 ? Date.now() / 1e3 : t;
        throw new Error("Cannot parse time: " + t);
    }
    a(nt, "toUnixTimestamp");
    function wn(t) {
        if (typeof t != "number") throw TypeError(hl.ERRSTR.UID);
    }
    a(wn, "validateUid");
    function gn(t) {
        if (typeof t != "number") throw TypeError(hl.ERRSTR.GID);
    }
    a(gn, "validateGid");
    var Mh = class Mh {
        get promises() {
            if (this.promisesApi === null) throw new Error("Promise is not supported in this environment.");
            return this.promisesApi;
        }
        wrapAsync(e, r, i) {
            (0, I.validateCallback)(i), Promise.resolve().then(()=>{
                let n;
                try {
                    n = e.apply(this, r);
                } catch (o) {
                    i(o);
                    return;
                }
                i(null, n);
            });
        }
        toTree() {
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
                separator: xe.sep
            };
            return (0, MD.toTreeSync)(this, e);
        }
        reset() {
            this._core.reset();
        }
        toJSON(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
            return this._core.toJSON(e, r, i, n);
        }
        fromJSON(e, r) {
            return this._core.fromJSON(e, r);
        }
        fromNestedJSON(e, r) {
            return this._core.fromNestedJSON(e, r);
        }
        mountSync(e, r) {
            this._core.fromJSON(r, e);
        }
        _write(e, r, i, n, o) {
            let s = this._core.getFileByFdOrThrow(e, "write");
            if (s.node.isSymlink()) throw (0, I.createError)("EBADF", "write", s.link.getPath());
            return s.write(r, i, n, o === -1 || typeof o != "number" ? void 0 : o);
        }
        writevBase(e, r, i) {
            let n = this._core.getFileByFdOrThrow(e), o = i !== null && i !== void 0 ? i : void 0;
            o === -1 && (o = void 0);
            let s = 0;
            for (let l of r){
                let f = bn.Buffer.from(l.buffer, l.byteOffset, l.byteLength), c = n.write(f, 0, f.byteLength, o);
                if (o = void 0, s += c, c < f.byteLength) break;
            }
            return s;
        }
        _copyFile(e, r, i) {
            let n = this.readFileSync(e);
            if (i & VD && this.existsSync(r)) throw (0, I.createError)("EEXIST", "copyFile", e, r);
            if (i & GD) throw (0, I.createError)("ENOSYS", "copyFile", e, r);
            this._core.writeFile(r, n, hl.FLAGS.w, 438);
        }
        isSrcSubdir(e, r) {
            try {
                let i = kb(e.startsWith("/") ? e : "/" + e), n = kb(r.startsWith("/") ? r : "/" + r);
                if (i === n) return !0;
                let o = ul(i, n);
                return o === "" || !o.startsWith("..") && !(0, xe.isAbsolute)(o);
            } catch (e) {
                return !1;
            }
        }
        cpFileSync(e, r, i, n, o) {
            if (r) {
                if (o.errorOnExist) throw (0, I.createError)("EEXIST", "cp", n);
                if (!o.force) return;
                this.unlinkSync(n);
            }
            this.copyFileSync(i, n, o.mode), o.preserveTimestamps && this.utimesSync(n, e.atime, e.mtime), this.chmodSync(n, Number(e.mode));
        }
        cpDirSync(e, r, i, n, o) {
            r || this.mkdirSync(n);
            let s = this.readdirSync(i);
            for (let l of s){
                let f = Lh(i, String(l)), c = Lh(n, String(l));
                o.filter && !o.filter(f, c) || this._cp(f, c, o);
            }
            this.chmodSync(n, Number(e.mode));
        }
        cpSymlinkSync(e, r, i, n) {
            let o = String(this.readlinkSync(r));
            !n.verbatimSymlinks && !(0, xe.isAbsolute)(o) && (o = qD(Rb(r), o)), e && this.unlinkSync(i), this.symlinkSync(o, i);
        }
        lstat(e, r, i) {
            let [{ throwIfNoEntry: n = !0, bigint: o = !1 }, s] = (0, te.getStatOptsAndCb)(r, i);
            this.wrapAsync(this._lstat, [
                (0, I.pathToFilename)(e),
                o,
                n
            ], s);
        }
        _stat(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
            let n;
            try {
                n = this._core.getResolvedLinkOrThrow(e, "stat");
            } catch (o) {
                if (o.code === "ENOENT" && !i) return;
                throw o;
            }
            return Nh.default.build(n.getNode(), r);
        }
        statSync(e, r) {
            let { bigint: i = !0, throwIfNoEntry: n = !0 } = (0, te.getStatOptions)(r);
            return this._stat((0, I.pathToFilename)(e), i, n);
        }
        stat(e, r, i) {
            let [{ bigint: n = !1, throwIfNoEntry: o = !0 }, s] = (0, te.getStatOptsAndCb)(r, i);
            this.wrapAsync(this._stat, [
                (0, I.pathToFilename)(e),
                n,
                o
            ], s);
        }
        fstatBase(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            let i = this._core.getFileByFd(e);
            if (!i) throw (0, I.createError)("EBADF", "fstat");
            return Nh.default.build(i.node, r);
        }
        fstatSync(e, r) {
            return this.fstatBase(e, (0, te.getStatOptions)(r).bigint);
        }
        fstat(e, r, i) {
            let [n, o] = (0, te.getStatOptsAndCb)(r, i);
            this.wrapAsync(this.fstatBase, [
                e,
                n.bigint
            ], o);
        }
        _exists(e) {
            return !!this._stat(e);
        }
        _access(e, r) {
            let n = this._core.getLinkOrThrow(e, "access").getNode();
            if (r !== Bh && (r & HD && !n.canRead() || r & zD && !n.canWrite() || r & WD && !n.canExecute())) throw (0, I.createError)("EACCES", "access", e);
        }
        watchFile(e, r, i) {
            let n = (0, I.pathToFilename)(e), o = r, s = i;
            if (typeof o == "function" && (s = r, o = null), typeof s != "function") throw Error('"watchFile()" requires a listener function');
            let l = 5007, f = !0;
            o && typeof o == "object" && (typeof o.interval == "number" && (l = o.interval), typeof o.persistent == "boolean" && (f = o.persistent));
            let c = this.statWatchers[n];
            return c || (c = new this.StatWatcher, c.start(n, f, l), this.statWatchers[n] = c), c.addListener("change", s), c;
        }
        unwatchFile(e, r) {
            let i = (0, I.pathToFilename)(e), n = this.statWatchers[i];
            n && (typeof r == "function" ? n.removeListener("change", r) : n.removeAllListeners("change"), n.listenerCount("change") === 0 && (n.stop(), delete this.statWatchers[i]));
        }
        createReadStream(e, r) {
            return new this.ReadStream(e, r);
        }
        createWriteStream(e, r) {
            return new this.WriteStream(e, r);
        }
        watch(e, r, i) {
            let n = (0, I.pathToFilename)(e), o = r;
            typeof r == "function" && (i = r, o = null);
            let { persistent: s, recursive: l, encoding: f } = (0, te.getDefaultOpts)(o);
            s === void 0 && (s = !0), l === void 0 && (l = !1);
            let c = new this.FSWatcher;
            return c.start(n, s, l, f), i && c.addListener("change", i), c;
        }
        _statfs(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            return this._core.getResolvedLinkOrThrow(e, "statfs"), CD.default.build(this._core, r);
        }
        statfsSync(e, r) {
            let { bigint: i = !1 } = (0, te.getStatfsOptions)(r);
            return this._statfs((0, I.pathToFilename)(e), i);
        }
        statfs(e, r, i) {
            let [{ bigint: n = !1 }, o] = (0, te.getStatfsOptsAndCb)(r, i);
            this.wrapAsync(this._statfs, [
                (0, I.pathToFilename)(e),
                n
            ], o);
        }
        constructor(e = new $h.Superblock){
            var _this = this;
            this._core = e, this.promisesApi = new $D.FsPromises(this, LD.FileHandle), this.openSync = function(f, c) {
                let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 438;
                let h = (0, I.modeToNumber)(u), d = (0, I.pathToFilename)(f), p = (0, I.flagsToNumber)(c);
                return _this._core.open(d, p, h, !(p & Ob));
            }, this.open = (f, c, u, h)=>{
                let d = u, p = h;
                typeof u == "function" && (d = 438, p = u), d = d || 438;
                let m = (0, I.modeToNumber)(d), y = (0, I.pathToFilename)(f), w = (0, I.flagsToNumber)(c);
                this.wrapAsync(this._core.open, [
                    y,
                    w,
                    m,
                    !(w & Ob)
                ], p);
            }, this.closeSync = (f)=>{
                this._core.close(f);
            }, this.close = (f, c)=>{
                (0, Le.validateFd)(f);
                let u = this._core.getFileByFdOrThrow(f, "close");
                this.wrapAsync(this._core.close, [
                    u.fd
                ], c);
            }, this.readSync = (f, c, u, h, d)=>((0, Le.validateFd)(f), this._core.read(f, c, u, h, d)), this.read = (f, c, u, h, d, p)=>{
                if ((0, I.validateCallback)(p), h === 0) return (0, ml.default)(()=>{
                    p && p(null, 0, c);
                });
                Promise.resolve().then(()=>{
                    try {
                        let m = this._core.read(f, c, u, h, d);
                        p(null, m, c);
                    } catch (m) {
                        p(m);
                    }
                });
            }, this.readv = (f, c, u, h)=>{
                let d = u, p = h;
                typeof u == "function" && ([d, p] = [
                    null,
                    u
                ]), (0, I.validateCallback)(p), Promise.resolve().then(()=>{
                    try {
                        let m = this._core.readv(f, c, d);
                        p(null, m, c);
                    } catch (m) {
                        p(m);
                    }
                });
            }, this.readvSync = (f, c, u)=>((0, Le.validateFd)(f), this._core.readv(f, c, u !== null && u !== void 0 ? u : null)), this._readfile = (f, c, u)=>{
                let h, p = typeof f == "number" && (0, Le.isFd)(f), m;
                if (p) m = f;
                else {
                    let y = (0, I.pathToFilename)(f), w = String(f), v = w.length > 1 && w.endsWith("/"), g = this._core.getResolvedLinkOrThrow(y, "open"), F = g.getNode();
                    if (F.isDirectory()) throw (0, I.createError)("EISDIR", "open", g.getPath());
                    if (v && F.isFile()) throw (0, I.createError)("ENOTDIR", "open", w);
                    m = this.openSync(f, c);
                }
                try {
                    h = (0, I.bufferToEncoding)(this._core.getFileByFdOrThrow(m).getBuffer(), u);
                } finally{
                    p || this.closeSync(m);
                }
                return h;
            }, this.readFileSync = (f, c)=>{
                let u = (0, te.getReadFileOptions)(c), h = (0, I.flagsToNumber)(u.flag);
                return this._readfile(f, h, u.encoding);
            }, this.readFile = (f, c, u)=>{
                let [h, d] = (0, te.optsAndCbGenerator)(te.getReadFileOptions)(c, u), p = (0, I.flagsToNumber)(h.flag);
                this.wrapAsync(this._readfile, [
                    f,
                    p,
                    h.encoding
                ], d);
            }, this.writeSync = (f, c, u, h, d)=>{
                let [, p, m, y, w] = (0, I.getWriteSyncArgs)(f, c, u, h, d);
                return this._write(f, p, m, y, w);
            }, this.write = (f, c, u, h, d, p)=>{
                let [, m, y, w, v, g, F] = (0, I.getWriteArgs)(f, c, u, h, d, p);
                Promise.resolve().then(()=>{
                    try {
                        let O = this._write(f, y, w, v, g);
                        m ? F(null, O, c) : F(null, O, y);
                    } catch (O) {
                        F(O);
                    }
                });
            }, this.writev = (f, c, u, h)=>{
                let d = u, p = h;
                typeof u == "function" && ([d, p] = [
                    null,
                    u
                ]), (0, I.validateCallback)(p), Promise.resolve().then(()=>{
                    try {
                        let m = this.writevBase(f, c, d);
                        p(null, m, c);
                    } catch (m) {
                        p(m);
                    }
                });
            }, this.writevSync = (f, c, u)=>((0, Le.validateFd)(f), this.writevBase(f, c, u !== null && u !== void 0 ? u : null)), this.writeFileSync = (f, c, u)=>{
                let h = (0, te.getWriteFileOptions)(u), d = (0, I.flagsToNumber)(h.flag), p = (0, I.modeToNumber)(h.mode), m = (0, Le.dataToBuffer)(c, h.encoding);
                this._core.writeFile(f, m, d, p);
            }, this.writeFile = (f, c, u, h)=>{
                let d = u, p = h;
                typeof u == "function" && ([d, p] = [
                    te.writeFileDefaults,
                    u
                ]);
                let m = (0, I.validateCallback)(p), y = (0, te.getWriteFileOptions)(d), w = (0, I.flagsToNumber)(y.flag), v = (0, I.modeToNumber)(y.mode), g = (0, Le.dataToBuffer)(c, y.encoding);
                this.wrapAsync(this._core.writeFile, [
                    f,
                    g,
                    w,
                    v
                ], m);
            }, this.copyFileSync = (f, c, u)=>{
                let h = (0, I.pathToFilename)(f), d = (0, I.pathToFilename)(c);
                return this._copyFile(h, d, (u || 0) | 0);
            }, this.copyFile = (f, c, u, h)=>{
                let d = (0, I.pathToFilename)(f), p = (0, I.pathToFilename)(c), m, y;
                typeof u == "function" ? [m, y] = [
                    0,
                    u
                ] : [m, y] = [
                    u,
                    h
                ], (0, I.validateCallback)(y), this.wrapAsync(this._copyFile, [
                    d,
                    p,
                    m
                ], y);
            }, this._cp = (f, c, u)=>{
                if (u.filter && !u.filter(f, c)) return;
                let h = u.dereference ? this.statSync(f) : this.lstatSync(f), d = null;
                try {
                    d = this.lstatSync(c);
                } catch (p) {
                    if (p.code !== "ENOENT") throw p;
                }
                if (d && h.ino === d.ino && h.dev === d.dev) throw (0, I.createError)("EINVAL", "cp", f, c);
                if (d) {
                    if (h.isDirectory() && !d.isDirectory()) throw (0, I.createError)("EISDIR", "cp", f, c);
                    if (!h.isDirectory() && d.isDirectory()) throw (0, I.createError)("ENOTDIR", "cp", f, c);
                }
                if (h.isDirectory() && this.isSrcSubdir(f, c)) throw (0, I.createError)("EINVAL", "cp", f, c);
                {
                    let p = Rb(c);
                    this.existsSync(p) || this.mkdirSync(p, {
                        recursive: !0
                    });
                }
                if (h.isDirectory()) {
                    if (!u.recursive) throw (0, I.createError)("EISDIR", "cp", f);
                    this.cpDirSync(h, d, f, c, u);
                } else if (h.isFile() || h.isCharacterDevice() || h.isBlockDevice()) this.cpFileSync(h, d, f, c, u);
                else if (h.isSymbolicLink() && !u.dereference) this.cpSymlinkSync(d, f, c, u);
                else throw (0, I.createError)("EINVAL", "cp", f);
            }, this.linkSync = (f, c)=>{
                let u = (0, I.pathToFilename)(f), h = (0, I.pathToFilename)(c);
                this._core.link(u, h);
            }, this.link = (f, c, u)=>{
                let h = (0, I.pathToFilename)(f), d = (0, I.pathToFilename)(c);
                this.wrapAsync(this._core.link, [
                    h,
                    d
                ], u);
            }, this.unlinkSync = (f)=>{
                let c = (0, I.pathToFilename)(f);
                this._core.unlink(c);
            }, this.unlink = (f, c)=>{
                let u = (0, I.pathToFilename)(f);
                this.wrapAsync(this._core.unlink, [
                    u
                ], c);
            }, this.symlinkSync = (f, c, u)=>{
                let h = (0, I.pathToFilename)(f), d = (0, I.pathToFilename)(c);
                this._core.symlink(h, d);
            }, this.symlink = (f, c, u, h)=>{
                let d = (0, I.validateCallback)(typeof u == "function" ? u : h), p = (0, I.pathToFilename)(f), m = (0, I.pathToFilename)(c);
                this.wrapAsync(this._core.symlink, [
                    p,
                    m
                ], d);
            }, this._lstat = function(f) {
                let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
                let h;
                try {
                    h = _this._core.getLinkOrThrow(f, "lstat");
                } catch (d) {
                    if (d.code === "ENOENT" && !u) return;
                    throw d;
                }
                return Nh.default.build(h.getNode(), c);
            }, this.lstatSync = (f, c)=>{
                let { throwIfNoEntry: u = !0, bigint: h = !1 } = (0, te.getStatOptions)(c);
                return this._lstat((0, I.pathToFilename)(f), h, u);
            }, this.renameSync = (f, c)=>{
                let u = (0, I.pathToFilename)(f), h = (0, I.pathToFilename)(c);
                this._core.rename(u, h);
            }, this.rename = (f, c, u)=>{
                let h = (0, I.pathToFilename)(f), d = (0, I.pathToFilename)(c);
                this.wrapAsync(this._core.rename, [
                    h,
                    d
                ], u);
            }, this.existsSync = (f)=>{
                try {
                    return this._exists((0, I.pathToFilename)(f));
                } catch (e) {
                    return !1;
                }
            }, this.exists = (f, c)=>{
                let u = (0, I.pathToFilename)(f);
                if (typeof c != "function") throw Error(hl.ERRSTR.CB);
                Promise.resolve().then(()=>{
                    try {
                        c(this._exists(u));
                    } catch (e) {
                        c(!1);
                    }
                });
            }, this.accessSync = function(f) {
                let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Bh;
                let u = (0, I.pathToFilename)(f);
                c = c | 0, _this._access(u, c);
            }, this.access = (f, c, u)=>{
                let h = Bh, d;
                typeof c != "function" ? [h, d] = [
                    c | 0,
                    (0, I.validateCallback)(u)
                ] : d = c;
                let p = (0, I.pathToFilename)(f);
                this.wrapAsync(this._access, [
                    p,
                    h
                ], d);
            }, this.appendFileSync = (f, c, u)=>{
                let h = (0, te.getAppendFileOpts)(u);
                (!h.flag || (0, Le.isFd)(f)) && (h.flag = "a"), this.writeFileSync(f, c, h);
            }, this.appendFile = (f, c, u, h)=>{
                let [d, p] = (0, te.getAppendFileOptsAndCb)(u, h);
                (!d.flag || (0, Le.isFd)(f)) && (d.flag = "a"), this.writeFile(f, c, d, p);
            }, this._readdir = (f, c)=>{
                let u = (0, Le.filenameToSteps)(f), h = this._core.getResolvedLinkOrThrow(f, "scandir"), d = h.getNode();
                if (!d.isDirectory()) throw (0, I.createError)("ENOTDIR", "scandir", f);
                if (!d.canRead()) throw (0, I.createError)("EACCES", "scandir", f);
                let p = [];
                for (let y of h.children.keys()){
                    let w = h.getChild(y);
                    if (!(!w || y === "." || y === "..") && (p.push(DD.default.build(w, c.encoding)), c.recursive && w.children.size)) {
                        let v = {
                            ...c,
                            recursive: !0,
                            withFileTypes: !0
                        }, g = this._readdir(w.getPath(), v);
                        p.push(...g);
                    }
                }
                if (!Le.isWin && c.encoding !== "buffer" && p.sort((y, w)=>y.name < w.name ? -1 : y.name > w.name ? 1 : 0), c.withFileTypes) return p;
                let m = f;
                return Le.isWin && (m = m.replace(/\\/g, "/")), p.map((y)=>{
                    if (c.recursive) {
                        let w = Lh(y.parentPath, y.name.toString());
                        return Le.isWin && (w = w.replace(/\\/g, "/")), w.replace(m + xe.posix.sep, "");
                    }
                    return y.name;
                });
            }, this.readdirSync = (f, c)=>{
                let u = (0, te.getReaddirOptions)(c), h = (0, I.pathToFilename)(f);
                return this._readdir(h, u);
            }, this.readdir = (f, c, u)=>{
                let [h, d] = (0, te.getReaddirOptsAndCb)(c, u), p = (0, I.pathToFilename)(f);
                this.wrapAsync(this._readdir, [
                    p,
                    h
                ], d);
            }, this._readlink = (f, c)=>{
                let h = this._core.getLinkOrThrow(f, "readlink").getNode();
                if (!h.isSymlink()) throw (0, I.createError)("EINVAL", "readlink", f);
                return (0, yi.strToEncoding)(h.symlink, c);
            }, this.readlinkSync = (f, c)=>{
                let u = (0, te.getDefaultOpts)(c), h = (0, I.pathToFilename)(f);
                return this._readlink(h, u.encoding);
            }, this.readlink = (f, c, u)=>{
                let [h, d] = (0, te.getDefaultOptsAndCb)(c, u), p = (0, I.pathToFilename)(f);
                this.wrapAsync(this._readlink, [
                    p,
                    h.encoding
                ], d);
            }, this._fsync = (f)=>{
                this._core.getFileByFdOrThrow(f, "fsync");
            }, this.fsyncSync = (f)=>{
                this._fsync(f);
            }, this.fsync = (f, c)=>{
                this.wrapAsync(this._fsync, [
                    f
                ], c);
            }, this._fdatasync = (f)=>{
                this._core.getFileByFdOrThrow(f, "fdatasync");
            }, this.fdatasyncSync = (f)=>{
                this._fdatasync(f);
            }, this.fdatasync = (f, c)=>{
                this.wrapAsync(this._fdatasync, [
                    f
                ], c);
            }, this._ftruncate = (f, c)=>{
                this._core.getFileByFdOrThrow(f, "ftruncate").truncate(c);
            }, this.ftruncateSync = (f, c)=>{
                this._ftruncate(f, c);
            }, this.ftruncate = (f, c, u)=>{
                let h = typeof c == "number" ? c : 0, d = (0, I.validateCallback)(typeof c == "number" ? u : c);
                this.wrapAsync(this._ftruncate, [
                    f,
                    h
                ], d);
            }, this._truncate = (f, c)=>{
                let u = this.openSync(f, "r+");
                try {
                    this.ftruncateSync(u, c);
                } finally{
                    this.closeSync(u);
                }
            }, this.truncateSync = (f, c)=>{
                if ((0, Le.isFd)(f)) return this.ftruncateSync(f, c);
                this._truncate(f, c);
            }, this.truncate = (f, c, u)=>{
                let h = typeof c == "number" ? c : 0, d = (0, I.validateCallback)(typeof c == "number" ? u : c);
                if ((0, Le.isFd)(f)) return this.ftruncate(f, h, d);
                this.wrapAsync(this._truncate, [
                    f,
                    h
                ], d);
            }, this._futimes = (f, c, u)=>{
                let d = this._core.getFileByFdOrThrow(f, "futimes").node;
                d.atime = new Date(c * 1e3), d.mtime = new Date(u * 1e3);
            }, this.futimesSync = (f, c, u)=>{
                this._futimes(f, nt(c), nt(u));
            }, this.futimes = (f, c, u, h)=>{
                this.wrapAsync(this._futimes, [
                    f,
                    nt(c),
                    nt(u)
                ], h);
            }, this._utimes = function(f, c, u) {
                let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0;
                let d = _this._core, m = (h ? d.getResolvedLinkOrThrow(f, "utimes") : d.getLinkOrThrow(f, "lutimes")).getNode();
                m.atime = new Date(c * 1e3), m.mtime = new Date(u * 1e3);
            }, this.utimesSync = (f, c, u)=>{
                this._utimes((0, I.pathToFilename)(f), nt(c), nt(u), !0);
            }, this.utimes = (f, c, u, h)=>{
                this.wrapAsync(this._utimes, [
                    (0, I.pathToFilename)(f),
                    nt(c),
                    nt(u),
                    !0
                ], h);
            }, this.lutimesSync = (f, c, u)=>{
                this._utimes((0, I.pathToFilename)(f), nt(c), nt(u), !1);
            }, this.lutimes = (f, c, u, h)=>{
                this.wrapAsync(this._utimes, [
                    (0, I.pathToFilename)(f),
                    nt(c),
                    nt(u),
                    !1
                ], h);
            }, this.mkdirSync = (f, c)=>{
                let u = (0, te.getMkdirOptions)(c), h = (0, I.modeToNumber)(u.mode, 511), d = (0, I.pathToFilename)(f);
                if (u.recursive) return this._core.mkdirp(d, h);
                this._core.mkdir(d, h);
            }, this.mkdir = (f, c, u)=>{
                let h = (0, te.getMkdirOptions)(c), d = (0, I.validateCallback)(typeof c == "function" ? c : u), p = (0, I.modeToNumber)(h.mode, 511), m = (0, I.pathToFilename)(f);
                h.recursive ? this.wrapAsync(this._core.mkdirp, [
                    m,
                    p
                ], d) : this.wrapAsync(this._core.mkdir, [
                    m,
                    p
                ], d);
            }, this._mkdtemp = function(f, c) {
                let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5;
                let h = f + (0, I.genRndStr6)();
                try {
                    return _this._core.mkdir(h, 511), (0, yi.strToEncoding)(h, c);
                } catch (d) {
                    if (d.code === "EEXIST") {
                        if (u > 1) return _this._mkdtemp(f, c, u - 1);
                        throw Error("Could not create temp dir.");
                    } else throw d;
                }
            }, this.mkdtempSync = (f, c)=>{
                let { encoding: u } = (0, te.getDefaultOpts)(c);
                if (!f || typeof f != "string") throw new TypeError("filename prefix is required");
                return (0, I.nullCheck)(f), this._mkdtemp(f, u);
            }, this.mkdtemp = (f, c, u)=>{
                let [{ encoding: h }, d] = (0, te.getDefaultOptsAndCb)(c, u);
                if (!f || typeof f != "string") throw new TypeError("filename prefix is required");
                (0, I.nullCheck)(f) && this.wrapAsync(this._mkdtemp, [
                    f,
                    h
                ], d);
            }, this.rmdirSync = (f, c)=>{
                let u = (0, te.getRmdirOptions)(c);
                this._core.rmdir((0, I.pathToFilename)(f), u.recursive);
            }, this.rmdir = (f, c, u)=>{
                let h = (0, te.getRmdirOptions)(c), d = (0, I.validateCallback)(typeof c == "function" ? c : u);
                this.wrapAsync(this._core.rmdir, [
                    (0, I.pathToFilename)(f),
                    h.recursive
                ], d);
            }, this.rmSync = (f, c)=>{
                this._core.rm((0, I.pathToFilename)(f), c === null || c === void 0 ? void 0 : c.force, c === null || c === void 0 ? void 0 : c.recursive);
            }, this.rm = (f, c, u)=>{
                let [h, d] = (0, te.getRmOptsAndCb)(c, u);
                this.wrapAsync(this._core.rm, [
                    (0, I.pathToFilename)(f),
                    h === null || h === void 0 ? void 0 : h.force,
                    h === null || h === void 0 ? void 0 : h.recursive
                ], d);
            }, this._fchmod = (f, c)=>{
                this._core.getFileByFdOrThrow(f, "fchmod").chmod(c);
            }, this.fchmodSync = (f, c)=>{
                this._fchmod(f, (0, I.modeToNumber)(c));
            }, this.fchmod = (f, c, u)=>{
                this.wrapAsync(this._fchmod, [
                    f,
                    (0, I.modeToNumber)(c)
                ], u);
            }, this._chmod = function(f, c) {
                let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
                (u ? _this._core.getResolvedLinkOrThrow(f, "chmod") : _this._core.getLinkOrThrow(f, "chmod")).getNode().chmod(c);
            }, this.chmodSync = (f, c)=>{
                let u = (0, I.modeToNumber)(c), h = (0, I.pathToFilename)(f);
                this._chmod(h, u, !0);
            }, this.chmod = (f, c, u)=>{
                let h = (0, I.modeToNumber)(c), d = (0, I.pathToFilename)(f);
                this.wrapAsync(this._chmod, [
                    d,
                    h
                ], u);
            }, this._lchmod = (f, c)=>{
                this._chmod(f, c, !1);
            }, this.lchmodSync = (f, c)=>{
                let u = (0, I.modeToNumber)(c), h = (0, I.pathToFilename)(f);
                this._lchmod(h, u);
            }, this.lchmod = (f, c, u)=>{
                let h = (0, I.modeToNumber)(c), d = (0, I.pathToFilename)(f);
                this.wrapAsync(this._lchmod, [
                    d,
                    h
                ], u);
            }, this._fchown = (f, c, u)=>{
                this._core.getFileByFdOrThrow(f, "fchown").chown(c, u);
            }, this.fchownSync = (f, c, u)=>{
                wn(c), gn(u), this._fchown(f, c, u);
            }, this.fchown = (f, c, u, h)=>{
                wn(c), gn(u), this.wrapAsync(this._fchown, [
                    f,
                    c,
                    u
                ], h);
            }, this._chown = (f, c, u)=>{
                this._core.getResolvedLinkOrThrow(f, "chown").getNode().chown(c, u);
            }, this.chownSync = (f, c, u)=>{
                wn(c), gn(u), this._chown((0, I.pathToFilename)(f), c, u);
            }, this.chown = (f, c, u, h)=>{
                wn(c), gn(u), this.wrapAsync(this._chown, [
                    (0, I.pathToFilename)(f),
                    c,
                    u
                ], h);
            }, this._lchown = (f, c, u)=>{
                this._core.getLinkOrThrow(f, "lchown").getNode().chown(c, u);
            }, this.lchownSync = (f, c, u)=>{
                wn(c), gn(u), this._lchown((0, I.pathToFilename)(f), c, u);
            }, this.lchown = (f, c, u, h)=>{
                wn(c), gn(u), this.wrapAsync(this._lchown, [
                    (0, I.pathToFilename)(f),
                    c,
                    u
                ], h);
            }, this.statWatchers = {}, this.cpSync = (f, c, u)=>{
                var _u_dereference, _u_errorOnExist, _u_force, _u_mode, _u_preserveTimestamps, _u_recursive, _u_verbatimSymlinks;
                let h = (0, I.pathToFilename)(f), d = (0, I.pathToFilename)(c), p = {
                    dereference: (_u_dereference = u === null || u === void 0 ? void 0 : u.dereference) !== null && _u_dereference !== void 0 ? _u_dereference : !1,
                    errorOnExist: (_u_errorOnExist = u === null || u === void 0 ? void 0 : u.errorOnExist) !== null && _u_errorOnExist !== void 0 ? _u_errorOnExist : !1,
                    filter: u === null || u === void 0 ? void 0 : u.filter,
                    force: (_u_force = u === null || u === void 0 ? void 0 : u.force) !== null && _u_force !== void 0 ? _u_force : !0,
                    mode: (_u_mode = u === null || u === void 0 ? void 0 : u.mode) !== null && _u_mode !== void 0 ? _u_mode : 0,
                    preserveTimestamps: (_u_preserveTimestamps = u === null || u === void 0 ? void 0 : u.preserveTimestamps) !== null && _u_preserveTimestamps !== void 0 ? _u_preserveTimestamps : !1,
                    recursive: (_u_recursive = u === null || u === void 0 ? void 0 : u.recursive) !== null && _u_recursive !== void 0 ? _u_recursive : !1,
                    verbatimSymlinks: (_u_verbatimSymlinks = u === null || u === void 0 ? void 0 : u.verbatimSymlinks) !== null && _u_verbatimSymlinks !== void 0 ? _u_verbatimSymlinks : !1
                };
                return this._cp(h, d, p);
            }, this.cp = (f, c, u, h)=>{
                let d = (0, I.pathToFilename)(f), p = (0, I.pathToFilename)(c), m, y;
                typeof u == "function" ? [m, y] = [
                    {},
                    u
                ] : [m, y] = [
                    u || {},
                    h
                ], (0, I.validateCallback)(y);
                var _m_dereference, _m_errorOnExist, _m_force, _m_mode, _m_preserveTimestamps, _m_recursive, _m_verbatimSymlinks;
                let w = {
                    dereference: (_m_dereference = m === null || m === void 0 ? void 0 : m.dereference) !== null && _m_dereference !== void 0 ? _m_dereference : !1,
                    errorOnExist: (_m_errorOnExist = m === null || m === void 0 ? void 0 : m.errorOnExist) !== null && _m_errorOnExist !== void 0 ? _m_errorOnExist : !1,
                    filter: m === null || m === void 0 ? void 0 : m.filter,
                    force: (_m_force = m === null || m === void 0 ? void 0 : m.force) !== null && _m_force !== void 0 ? _m_force : !0,
                    mode: (_m_mode = m === null || m === void 0 ? void 0 : m.mode) !== null && _m_mode !== void 0 ? _m_mode : 0,
                    preserveTimestamps: (_m_preserveTimestamps = m === null || m === void 0 ? void 0 : m.preserveTimestamps) !== null && _m_preserveTimestamps !== void 0 ? _m_preserveTimestamps : !1,
                    recursive: (_m_recursive = m === null || m === void 0 ? void 0 : m.recursive) !== null && _m_recursive !== void 0 ? _m_recursive : !1,
                    verbatimSymlinks: (_m_verbatimSymlinks = m === null || m === void 0 ? void 0 : m.verbatimSymlinks) !== null && _m_verbatimSymlinks !== void 0 ? _m_verbatimSymlinks : !1
                };
                this.wrapAsync(this._cp, [
                    d,
                    p,
                    w
                ], y);
            }, this.openAsBlob = async (f, c)=>{
                let u = (0, I.pathToFilename)(f), h;
                try {
                    h = this._core.getResolvedLinkOrThrow(u, "open");
                } catch (y) {
                    throw y && typeof y == "object" && y.code === "ENOENT" ? new jD.TypeError("ERR_INVALID_ARG_VALUE") : y;
                }
                let p = h.getNode().getBuffer(), m = (c === null || c === void 0 ? void 0 : c.type) || "";
                return new Blob([
                    p
                ], {
                    type: m
                });
            }, this.glob = function(f) {
                for(var _len = arguments.length, c = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    c[_key - 1] = arguments[_key];
                }
                let [u, h] = c.length === 1 ? [
                    {},
                    c[0]
                ] : [
                    c[0],
                    c[1]
                ];
                _this.wrapAsync(_this._globSync, [
                    f,
                    u || {}
                ], h);
            }, this.globSync = function(f) {
                let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                return _this._globSync(f, c);
            }, this._globSync = function(f) {
                let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                let { globSync: u } = Tb();
                return u(_this, f, c);
            }, this._opendir = (f, c)=>{
                let u = this._core.getResolvedLinkOrThrow(f, "scandir");
                if (!u.getNode().isDirectory()) throw (0, I.createError)("ENOTDIR", "scandir", f);
                return new UD.Dir(u, c);
            }, this.opendirSync = (f, c)=>{
                let u = (0, te.getOpendirOptions)(c), h = (0, I.pathToFilename)(f);
                return this._opendir(h, u);
            }, this.opendir = (f, c, u)=>{
                let [h, d] = (0, te.getOpendirOptsAndCb)(c, u), p = (0, I.pathToFilename)(f);
                this.wrapAsync(this._opendir, [
                    p,
                    h
                ], d);
            };
            let r = this;
            this.StatWatcher = class extends dl {
                constructor(){
                    super(r);
                }
            };
            let i = Xt;
            this.ReadStream = class extends i {
                constructor(...f){
                    super(r, ...f);
                }
            };
            let n = gt;
            this.WriteStream = class extends n {
                constructor(...f){
                    super(r, ...f);
                }
            }, this.FSWatcher = class extends pl {
                constructor(){
                    super(r);
                }
            };
            let o = a((f, c)=>{
                let u = this._core.getResolvedLinkOrThrow(f, "realpath");
                return (0, yi.strToEncoding)(u.getPath() || "/", c);
            }, "_realpath"), s = a((f, c, u)=>{
                let [h, d] = (0, te.getRealpathOptsAndCb)(c, u), p = (0, I.pathToFilename)(f);
                r.wrapAsync(o, [
                    p,
                    h.encoding
                ], d);
            }, "realpathImpl"), l = a((f, c)=>o((0, I.pathToFilename)(f), (0, te.getRealpathOptions)(c).encoding), "realpathSyncImpl");
            this.realpath = s, this.realpath.native = s, this.realpathSync = l, this.realpathSync.native = l;
        }
    };
    a(Mh, "Volume");
    var wi = Mh;
    ot.Volume = wi;
    wi.fromJSON = (t, e)=>new wi($h.Superblock.fromJSON(t, e));
    wi.fromNestedJSON = (t, e)=>new wi($h.Superblock.fromNestedJSON(t, e));
    function YD(t) {
        t.emit("stop");
    }
    a(YD, "emitStop");
    var jh = class jh extends Pb.EventEmitter {
        loop() {
            this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
        }
        hasChanged(e) {
            return e.mtimeMs > this.prev.mtimeMs || e.nlink !== this.prev.nlink;
        }
        start(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5007;
            this.filename = (0, I.pathToFilename)(e), this.setTimeout = r ? setTimeout.bind(globalThis) : ND.default, this.interval = i, this.prev = this.vol.statSync(this.filename), this.loop();
        }
        stop() {
            clearTimeout(this.timeoutRef), (0, ml.default)(()=>{
                YD.call(this, this);
            });
        }
        constructor(e){
            super(), this.onInterval = ()=>{
                try {
                    let r = this.vol.statSync(this.filename);
                    this.hasChanged(r) && (this.emit("change", r, this.prev), this.prev = r);
                } finally{
                    this.loop();
                }
            }, this.vol = e;
        }
    };
    a(jh, "StatWatcher");
    var dl = jh;
    ot.StatWatcher = dl;
    var wt;
    function JD(t) {
        wt = (0, bn.bufferAllocUnsafe)(t), wt.used = 0;
    }
    a(JD, "allocNewPool");
    (0, Ab.inherits)(Xt, yl.Readable);
    ot.ReadStream = Xt;
    function Xt(t, e, r) {
        if (!(this instanceof Xt)) return new Xt(t, e, r);
        if (this._vol = t, r = Object.assign({}, (0, te.getOptions)(r, {})), r.highWaterMark === void 0 && (r.highWaterMark = 64 * 1024), yl.Readable.call(this, r), this.path = (0, I.pathToFilename)(e), this.fd = r.fd === void 0 ? null : typeof r.fd != "number" ? r.fd.fd : r.fd, this.flags = r.flags === void 0 ? "r" : r.flags, this.mode = r.mode === void 0 ? 438 : r.mode, this.start = r.start, this.end = r.end, this.autoClose = r.autoClose === void 0 ? !0 : r.autoClose, this.pos = void 0, this.bytesRead = 0, this.start !== void 0) {
            if (typeof this.start != "number") throw new TypeError('"start" option must be a Number');
            if (this.end === void 0) this.end = 1 / 0;
            else if (typeof this.end != "number") throw new TypeError('"end" option must be a Number');
            if (this.start > this.end) throw new Error('"start" option must be <= "end" option');
            this.pos = this.start;
        }
        typeof this.fd != "number" && this.open(), this.on("end", function() {
            this.autoClose && this.destroy && this.destroy();
        });
    }
    a(Xt, "FsReadStream");
    Xt.prototype.open = function() {
        var t = this;
        this._vol.open(this.path, this.flags, this.mode, (e, r)=>{
            if (e) {
                t.autoClose && t.destroy && t.destroy(), t.emit("error", e);
                return;
            }
            t.fd = r, t.emit("open", r), t.read();
        });
    };
    Xt.prototype._read = function(t) {
        if (typeof this.fd != "number") return this.once("open", function() {
            this._read(t);
        });
        if (this.destroyed) return;
        (!wt || wt.length - wt.used < KD) && JD(this._readableState.highWaterMark);
        var e = wt, r = Math.min(wt.length - wt.used, t), i = wt.used;
        if (this.pos !== void 0 && (r = Math.min(this.end - this.pos + 1, r)), r <= 0) return this.push(null);
        var n = this;
        this._vol.read(this.fd, wt, wt.used, r, this.pos, o), this.pos !== void 0 && (this.pos += r), wt.used += r;
        function o(s, l) {
            if (s) n.autoClose && n.destroy && n.destroy(), n.emit("error", s);
            else {
                var f = null;
                l > 0 && (n.bytesRead += l, f = e.slice(i, i + l)), n.push(f);
            }
        }
        a(o, "onread");
    };
    Xt.prototype._destroy = function(t, e) {
        this.close((r)=>{
            e(t || r);
        });
    };
    Xt.prototype.close = function(t) {
        var _this__readableState;
        if (t && this.once("close", t), this.closed || typeof this.fd != "number") {
            if (typeof this.fd != "number") {
                this.once("open", Ib);
                return;
            }
            return (0, ml.default)(()=>this.emit("close"));
        }
        typeof ((_this__readableState = this._readableState) === null || _this__readableState === void 0 ? void 0 : _this__readableState.closed) == "boolean" ? this._readableState.closed = !0 : this.closed = !0, this._vol.close(this.fd, (e)=>{
            e ? this.emit("error", e) : this.emit("close");
        }), this.fd = null;
    };
    function Ib(t) {
        this.close();
    }
    a(Ib, "closeOnOpen");
    (0, Ab.inherits)(gt, yl.Writable);
    ot.WriteStream = gt;
    function gt(t, e, r) {
        if (!(this instanceof gt)) return new gt(t, e, r);
        if (this._vol = t, r = Object.assign({}, (0, te.getOptions)(r, {})), yl.Writable.call(this, r), this.path = (0, I.pathToFilename)(e), this.fd = r.fd === void 0 ? null : typeof r.fd != "number" ? r.fd.fd : r.fd, this.flags = r.flags === void 0 ? "w" : r.flags, this.mode = r.mode === void 0 ? 438 : r.mode, this.start = r.start, this.autoClose = r.autoClose === void 0 ? !0 : !!r.autoClose, this.pos = void 0, this.bytesWritten = 0, this.pending = !0, this.start !== void 0) {
            if (typeof this.start != "number") throw new TypeError('"start" option must be a Number');
            if (this.start < 0) throw new Error('"start" must be >= zero');
            this.pos = this.start;
        }
        r.encoding && this.setDefaultEncoding(r.encoding), typeof this.fd != "number" && this.open(), this.once("finish", function() {
            this.autoClose && this.close();
        });
    }
    a(gt, "FsWriteStream");
    gt.prototype.open = function() {
        this._vol.open(this.path, this.flags, this.mode, (function(t, e) {
            if (t) {
                this.autoClose && this.destroy && this.destroy(), this.emit("error", t);
                return;
            }
            this.fd = e, this.pending = !1, this.emit("open", e);
        }).bind(this));
    };
    gt.prototype._write = function(t, e, r) {
        if (!(t instanceof bn.Buffer || t instanceof Uint8Array)) return this.emit("error", new Error("Invalid data"));
        if (typeof this.fd != "number") return this.once("open", function() {
            this._write(t, e, r);
        });
        var i = this;
        this._vol.write(this.fd, t, 0, t.length, this.pos, (n, o)=>{
            if (n) return i.autoClose && i.destroy && i.destroy(), r(n);
            i.bytesWritten += o, r();
        }), this.pos !== void 0 && (this.pos += t.length);
    };
    gt.prototype._writev = function(t, e) {
        if (typeof this.fd != "number") return this.once("open", function() {
            this._writev(t, e);
        });
        let r = this, i = t.length, n = new Array(i);
        for(var o = 0, s = 0; s < i; s++){
            var l = t[s].chunk;
            n[s] = l, o += l.length;
        }
        let f = bn.Buffer.concat(n);
        this._vol.write(this.fd, f, 0, f.length, this.pos, (c, u)=>{
            if (c) return r.destroy && r.destroy(), e(c);
            r.bytesWritten += u, e();
        }), this.pos !== void 0 && (this.pos += o);
    };
    gt.prototype.close = function(t) {
        var _this__writableState;
        if (t && this.once("close", t), this.closed || typeof this.fd != "number") {
            if (typeof this.fd != "number") {
                this.once("open", Ib);
                return;
            }
            return (0, ml.default)(()=>this.emit("close"));
        }
        typeof ((_this__writableState = this._writableState) === null || _this__writableState === void 0 ? void 0 : _this__writableState.closed) == "boolean" ? this._writableState.closed = !0 : this.closed = !0, this._vol.close(this.fd, (e)=>{
            e ? this.emit("error", e) : this.emit("close");
        }), this.fd = null;
    };
    gt.prototype._destroy = Xt.prototype._destroy;
    gt.prototype.destroySoon = gt.prototype.end;
    var Uh = class Uh extends Pb.EventEmitter {
        _getName() {
            return this._steps[this._steps.length - 1];
        }
        start(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : yi.ENCODING_UTF8;
            this._filename = (0, I.pathToFilename)(e), this._steps = (0, Le.filenameToSteps)(this._filename), this._filenameEncoded = (0, yi.strToEncoding)(this._filename), this._recursive = i, this._encoding = n;
            try {
                this._link = this._vol._core.getLinkOrThrow(this._filename, "FSWatcher");
            } catch (f) {
                let c = new Error("watch ".concat(this._filename, " ").concat(f.code));
                throw c.code = f.code, c.errno = f.code, c;
            }
            let o = a((f)=>{
                var _this__listenerRemovers_get;
                let c = f.getPath(), u = f.getNode(), h = a(()=>{
                    let m = ul(this._filename, c);
                    return m || (m = this._getName()), this.emit("change", "change", m);
                }, "onNodeChange"), d = u.changes.listen((param)=>{
                    let [m] = param;
                    m === "modify" && h();
                }), p = (_this__listenerRemovers_get = this._listenerRemovers.get(u.ino)) !== null && _this__listenerRemovers_get !== void 0 ? _this__listenerRemovers_get : [];
                p.push(()=>d()), this._listenerRemovers.set(u.ino, p);
            }, "watchLinkNodeChanged"), s = a((f)=>{
                let c = f.getNode(), u = a((m)=>{
                    this.emit("change", "rename", ul(this._filename, m.getPath())), o(m), s(m);
                }, "onLinkChildAdd"), h = a((m)=>{
                    let y = a((w)=>{
                        let v = w.getNode().ino, g = this._listenerRemovers.get(v);
                        g && (g.forEach((F)=>F()), this._listenerRemovers.delete(v));
                        for (let [F, O] of w.children.entries())O && F !== "." && F !== ".." && y(O);
                    }, "removeLinkNodeListeners");
                    y(m), this.emit("change", "rename", ul(this._filename, m.getPath()));
                }, "onLinkChildDelete");
                for (let [m, y] of f.children.entries())y && m !== "." && m !== ".." && o(y);
                let d = f.changes.listen((param)=>{
                    let [m, y] = param;
                    m === "child:add" ? u(y) : m === "child:del" && h(y);
                });
                var _this__listenerRemovers_get;
                if (((_this__listenerRemovers_get = this._listenerRemovers.get(c.ino)) !== null && _this__listenerRemovers_get !== void 0 ? _this__listenerRemovers_get : []).push(()=>{
                    d();
                }), i) for (let [m, y] of f.children.entries())y && m !== "." && m !== ".." && s(y);
            }, "watchLinkChildrenChanged");
            o(this._link), s(this._link);
            let l = this._link.parent;
            l && l.changes.listen((param)=>{
                let [f, c] = param;
                f === "child:del" && this._onParentChild(c);
            }), r && this._persist();
        }
        close() {
            var _this__parentChangesUnsub, _this;
            clearTimeout(this._timer), this._listenerRemovers.forEach((e)=>{
                e.forEach((r)=>r());
            }), this._listenerRemovers.clear(), (_this__parentChangesUnsub = (_this = this)._parentChangesUnsub) === null || _this__parentChangesUnsub === void 0 ? void 0 : _this__parentChangesUnsub.call(_this);
        }
        constructor(e){
            super(), this._filename = "", this._filenameEncoded = "", this._recursive = !1, this._encoding = yi.ENCODING_UTF8, this._listenerRemovers = new Map, this._onParentChild = (r)=>{
                r.getName() === this._getName() && this._emit("rename");
            }, this._emit = (r)=>{
                this.emit("change", r, this._filenameEncoded);
            }, this._persist = ()=>{
                this._timer = setTimeout(this._persist, 1e6);
            }, this._vol = e;
        }
    };
    a(Uh, "FSWatcher");
    var pl = Uh;
    ot.FSWatcher = pl;
});
_c123 = Db;
var Cb = T(_c124 = (wl)=>{
    "use strict";
    Object.defineProperty(wl, "__esModule", {
        value: !0
    });
    wl.fsSynchronousApiList = void 0;
    wl.fsSynchronousApiList = [
        "accessSync",
        "appendFileSync",
        "chmodSync",
        "chownSync",
        "closeSync",
        "copyFileSync",
        "existsSync",
        "fchmodSync",
        "fchownSync",
        "fdatasyncSync",
        "fstatSync",
        "fsyncSync",
        "ftruncateSync",
        "futimesSync",
        "lchmodSync",
        "lchownSync",
        "linkSync",
        "lstatSync",
        "mkdirSync",
        "mkdtempSync",
        "openSync",
        "opendirSync",
        "readdirSync",
        "readFileSync",
        "readlinkSync",
        "readSync",
        "readvSync",
        "realpathSync",
        "renameSync",
        "rmdirSync",
        "rmSync",
        "statSync",
        "symlinkSync",
        "truncateSync",
        "unlinkSync",
        "utimesSync",
        "lutimesSync",
        "writeFileSync",
        "writeSync",
        "writevSync"
    ];
});
_c125 = Cb;
var Nb = T(_c126 = (gl)=>{
    "use strict";
    Object.defineProperty(gl, "__esModule", {
        value: !0
    });
    gl.fsCallbackApiList = void 0;
    gl.fsCallbackApiList = [
        "access",
        "appendFile",
        "chmod",
        "chown",
        "close",
        "copyFile",
        "cp",
        "createReadStream",
        "createWriteStream",
        "exists",
        "fchmod",
        "fchown",
        "fdatasync",
        "fstat",
        "fsync",
        "ftruncate",
        "futimes",
        "lchmod",
        "lchown",
        "link",
        "lstat",
        "mkdir",
        "mkdtemp",
        "open",
        "openAsBlob",
        "opendir",
        "read",
        "readv",
        "readdir",
        "readFile",
        "readlink",
        "realpath",
        "rename",
        "rm",
        "rmdir",
        "stat",
        "statfs",
        "symlink",
        "truncate",
        "unlink",
        "unwatchFile",
        "utimes",
        "lutimes",
        "watch",
        "watchFile",
        "write",
        "writev",
        "writeFile"
    ];
});
_c127 = Nb;
var qo = T((st, bl)=>{
    "use strict";
    Object.defineProperty(st, "__esModule", {
        value: !0
    });
    st.memfs = st.fs = st.vol = st.Volume = void 0;
    st.createFsFromVolume = qh;
    var QD = Sf(), eC = Xs(), vl = Db();
    Object.defineProperty(st, "Volume", {
        enumerable: !0,
        get: a(function() {
            return vl.Volume;
        }, "get")
    });
    var Bb = kt(), tC = Cb(), rC = Nb(), { F_OK: iC, R_OK: nC, W_OK: oC, X_OK: sC } = Bb.constants;
    st.vol = new vl.Volume;
    function qh(t) {
        let e = {
            F_OK: iC,
            R_OK: nC,
            W_OK: oC,
            X_OK: sC,
            constants: Bb.constants,
            Stats: QD.default,
            Dirent: eC.default
        };
        for (let r of tC.fsSynchronousApiList)typeof t[r] == "function" && (e[r] = t[r].bind(t));
        for (let r of rC.fsCallbackApiList)typeof t[r] == "function" && (e[r] = t[r].bind(t));
        return e.StatWatcher = t.StatWatcher, e.FSWatcher = t.FSWatcher, e.WriteStream = t.WriteStream, e.ReadStream = t.ReadStream, e.promises = t.promises, typeof t.realpath == "function" && (e.realpath = t.realpath.bind(t), typeof t.realpath.native == "function" && (e.realpath.native = t.realpath.native.bind(t))), typeof t.realpathSync == "function" && (e.realpathSync = t.realpathSync.bind(t), typeof t.realpathSync.native == "function" && (e.realpathSync.native = t.realpathSync.native.bind(t))), e._toUnixTimestamp = vl.toUnixTimestamp, e.__vol = t, e;
    }
    a(qh, "createFsFromVolume");
    st.fs = qh(st.vol);
    var aC = a(function() {
        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "/";
        let r = vl.Volume.fromNestedJSON(t, e);
        return {
            fs: qh(r),
            vol: r
        };
    }, "memfs");
    st.memfs = aC;
    bl.exports = {
        ...bl.exports,
        ...st.fs
    };
    bl.exports.semantic = !0;
});
var id = T((k4, Ol)=>{
    function Ub(t) {
        return Array.isArray(t) ? t : [
            t
        ];
    }
    a(Ub, "makeArray");
    var lC = void 0, Zh = "", Mb = " ", Kh = "\\", cC = /^\s+$/, fC = /(?:[^\\]|^)\\$/, uC = /^\\!/, hC = /^\\#/, dC = /\r?\n/g, pC = /^\.{0,2}\/|^\.{1,2}$/, mC = /\/$/, vn = "/", qb = "node-ignore";
    typeof Symbol < "u" && (qb = Symbol.for("node-ignore"));
    var Hb = qb, _n = a((t, e, r)=>(Object.defineProperty(t, e, {
            value: r
        }), r), "define"), yC = /([0-z])-([0-z])/g, zb = a(()=>!1, "RETURN_FALSE"), wC = a((t)=>t.replace(yC, (e, r, i)=>r.charCodeAt(0) <= i.charCodeAt(0) ? e : Zh), "sanitizeRange"), gC = a((t)=>{
        let { length: e } = t;
        return t.slice(0, e - e % 2);
    }, "cleanRangeBackSlash"), bC = [
        [
            /^\uFEFF/,
            ()=>Zh
        ],
        [
            /((?:\\\\)*?)(\\?\s+)$/,
            (t, e, r)=>e + (r.indexOf("\\") === 0 ? Mb : Zh)
        ],
        [
            /(\\+?)\s/g,
            (t, e)=>{
                let { length: r } = e;
                return e.slice(0, r - r % 2) + Mb;
            }
        ],
        [
            /[\\$.|*+(){^]/g,
            (t)=>"\\".concat(t)
        ],
        [
            /(?!\\)\?/g,
            ()=>"[^/]"
        ],
        [
            /^\//,
            ()=>"^"
        ],
        [
            /\//g,
            ()=>"\\/"
        ],
        [
            /^\^*\\\*\\\*\\\//,
            ()=>"^(?:.*\\/)?"
        ],
        [
            /^(?=[^^])/,
            a(function() {
                return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
            }, "startingReplacer")
        ],
        [
            /\\\/\\\*\\\*(?=\\\/|$)/g,
            (t, e, r)=>e + 6 < r.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
        ],
        [
            /(^|[^\\]+)(\\\*)+(?=.+)/g,
            (t, e, r)=>{
                let i = r.replace(/\\\*/g, "[^\\/]*");
                return e + i;
            }
        ],
        [
            /\\\\\\(?=[$.|*+(){^])/g,
            ()=>Kh
        ],
        [
            /\\\\/g,
            ()=>Kh
        ],
        [
            /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
            (t, e, r, i, n)=>e === Kh ? "\\[".concat(r).concat(gC(i)).concat(n) : n === "]" && i.length % 2 === 0 ? "[".concat(wC(r)).concat(i, "]") : "[]"
        ],
        [
            /(?:[^*])$/,
            (t)=>/\/$/.test(t) ? "".concat(t, "$") : "".concat(t, "(?=$|\\/$)")
        ]
    ], vC = /(^|\\\/)?\\\*$/, zo = "regex", xl = "checkRegex", jb = "_", _C = {
        [zo] (t, e) {
            return "".concat(e ? "".concat(e, "[^/]+") : "[^/]*", "(?=$|\\/$)");
        },
        [xl] (t, e) {
            return "".concat(e ? "".concat(e, "[^/]*") : "[^/]*", "(?=$|\\/$)");
        }
    }, FC = a((t)=>bC.reduce((e, param)=>{
            let [r, i] = param;
            return e.replace(r, i.bind(t));
        }, t), "makeRegexPrefix"), Tl = a((t)=>typeof t == "string", "isString"), EC = a((t)=>t && Tl(t) && !cC.test(t) && !fC.test(t) && t.indexOf("#") !== 0, "checkPattern"), SC = a((t)=>t.split(dC).filter(Boolean), "splitPattern"), ed = class ed {
        get regex() {
            let e = jb + zo;
            return this[e] ? this[e] : this._make(zo, e);
        }
        get checkRegex() {
            let e = jb + xl;
            return this[e] ? this[e] : this._make(xl, e);
        }
        _make(e, r) {
            let i = this.regexPrefix.replace(vC, _C[e]), n = this.ignoreCase ? new RegExp(i, "i") : new RegExp(i);
            return _n(this, r, n);
        }
        constructor(e, r, i, n, o, s){
            this.pattern = e, this.mark = r, this.negative = o, _n(this, "body", i), _n(this, "ignoreCase", n), _n(this, "regexPrefix", s);
        }
    };
    a(ed, "IgnoreRule");
    var Xh = ed, xC = a((param, r)=>{
        let { pattern: t, mark: e } = param;
        let i = !1, n = t;
        n.indexOf("!") === 0 && (i = !0, n = n.substr(1)), n = n.replace(uC, "!").replace(hC, "#");
        let o = FC(n);
        return new Xh(t, e, n, r, i, o);
    }, "createRule"), td = class td {
        _add(e) {
            if (e && e[Hb]) {
                this._rules = this._rules.concat(e._rules._rules), this._added = !0;
                return;
            }
            if (Tl(e) && (e = {
                pattern: e
            }), EC(e.pattern)) {
                let r = xC(e, this._ignoreCase);
                this._added = !0, this._rules.push(r);
            }
        }
        add(e) {
            return this._added = !1, Ub(Tl(e) ? SC(e) : e).forEach(this._add, this), this._added;
        }
        test(e, r, i) {
            let n = !1, o = !1, s;
            this._rules.forEach((f)=>{
                let { negative: c } = f;
                o === c && n !== o || c && !n && !o && !r || !f[i].test(e) || (n = !c, o = c, s = c ? lC : f);
            });
            let l = {
                ignored: n,
                unignored: o
            };
            return s && (l.rule = s), l;
        }
        constructor(e){
            this._ignoreCase = e, this._rules = [];
        }
    };
    a(td, "RuleManager");
    var Yh = td, TC = a((t, e)=>{
        throw new e(t);
    }, "throwError"), ur = a((t, e, r)=>Tl(t) ? t ? ur.isNotRelative(t) ? r('path should be a `path.relative()`d string, but got "'.concat(e, '"'), RangeError) : !0 : r("path must not be empty", TypeError) : r("path must be a string, but got `".concat(e, "`"), TypeError), "checkPath"), Wb = a((t)=>pC.test(t), "isNotRelative");
    ur.isNotRelative = Wb;
    ur.convert = (t)=>t;
    var rd = class rd {
        _initCache() {
            this._ignoreCache = Object.create(null), this._testCache = Object.create(null);
        }
        add(e) {
            return this._rules.add(e) && this._initCache(), this;
        }
        addPattern(e) {
            return this.add(e);
        }
        _test(e, r, i, n) {
            let o = e && ur.convert(e);
            return ur(o, e, this._strictPathCheck ? TC : zb), this._t(o, r, i, n);
        }
        checkIgnore(e) {
            if (!mC.test(e)) return this.test(e);
            let r = e.split(vn).filter(Boolean);
            if (r.pop(), r.length) {
                let i = this._t(r.join(vn) + vn, this._testCache, !0, r);
                if (i.ignored) return i;
            }
            return this._rules.test(e, !1, xl);
        }
        _t(e, r, i, n) {
            if (e in r) return r[e];
            if (n || (n = e.split(vn).filter(Boolean)), n.pop(), !n.length) return r[e] = this._rules.test(e, i, zo);
            let o = this._t(n.join(vn) + vn, r, i, n);
            return r[e] = o.ignored ? o : this._rules.test(e, i, zo);
        }
        ignores(e) {
            return this._test(e, this._ignoreCache, !1).ignored;
        }
        createFilter() {
            return (e)=>!this.ignores(e);
        }
        filter(e) {
            return Ub(e).filter(this.createFilter());
        }
        test(e) {
            return this._test(e, this._testCache, !0);
        }
        constructor({ ignorecase: e = !0, ignoreCase: r = e, allowRelativePaths: i = !1 } = {}){
            _n(this, Hb, !0), this._rules = new Yh(r), this._strictPathCheck = !i, this._initCache();
        }
    };
    a(rd, "Ignore");
    var Jh = rd, Qh = a((t)=>new Jh(t), "factory"), OC = a((t)=>ur(t && ur.convert(t), t, zb), "isPathValid"), Vb = a(()=>{
        let t = a((r)=>/^\\\\\?\\/.test(r) || /["<>|\u0000-\u001F]+/u.test(r) ? r : r.replace(/\\/g, "/"), "makePosix");
        ur.convert = t;
        let e = /^[a-z]:\//i;
        ur.isNotRelative = (r)=>e.test(r) || Wb(r);
    }, "setupWindows");
    typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] < "u" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === "win32" && Vb();
    Ol.exports = Qh;
    Qh.default = Qh;
    Ol.exports.isPathValid = OC;
    _n(Ol.exports, Symbol.for("setupWindows"), Vb);
});
var Xb = T(_c128 = ($4, Zb)=>{
    "use strict";
    var at = a(function(t) {
        if (t = t || {}, this.Promise = t.Promise || Promise, this.queues = Object.create(null), this.domainReentrant = t.domainReentrant || !1, this.domainReentrant) {
            if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] > "u" || typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].domain > "u") throw new Error("Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill.");
            this.domains = Object.create(null);
        }
        this.timeout = t.timeout || at.DEFAULT_TIMEOUT, this.maxOccupationTime = t.maxOccupationTime || at.DEFAULT_MAX_OCCUPATION_TIME, this.maxExecutionTime = t.maxExecutionTime || at.DEFAULT_MAX_EXECUTION_TIME, t.maxPending === 1 / 0 || Number.isInteger(t.maxPending) && t.maxPending >= 0 ? this.maxPending = t.maxPending : this.maxPending = at.DEFAULT_MAX_PENDING;
    }, "AsyncLock");
    at.DEFAULT_TIMEOUT = 0;
    at.DEFAULT_MAX_OCCUPATION_TIME = 0;
    at.DEFAULT_MAX_EXECUTION_TIME = 0;
    at.DEFAULT_MAX_PENDING = 1e3;
    at.prototype.acquire = function(t, e, r, i) {
        if (Array.isArray(t)) return this._acquireBatch(t, e, r, i);
        if (typeof e != "function") throw new Error("You must pass a function to execute");
        var n = null, o = null, s = null;
        typeof r != "function" && (i = r, r = null, s = new this.Promise(function(g, F) {
            n = g, o = F;
        })), i = i || {};
        var l = !1, f = null, c = null, u = null, h = this, d = a(function(g, F, O) {
            c && (clearTimeout(c), c = null), u && (clearTimeout(u), u = null), g && (h.queues[t] && h.queues[t].length === 0 && delete h.queues[t], h.domainReentrant && delete h.domains[t]), l || (s ? F ? o(F) : n(O) : typeof r == "function" && r(F, O), l = !0), g && h.queues[t] && h.queues[t].length > 0 && h.queues[t].shift()();
        }, "done"), p = a(function(g) {
            if (l) return d(g);
            f && (clearTimeout(f), f = null), h.domainReentrant && g && (h.domains[t] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].domain);
            var F = i.maxExecutionTime || h.maxExecutionTime;
            if (F && (u = setTimeout(function() {
                h.queues[t] && d(g, new Error("Maximum execution time is exceeded " + t));
            }, F)), e.length === 1) {
                var O = !1;
                try {
                    e(function(S, R) {
                        O || (O = !0, d(g, S, R));
                    });
                } catch (S) {
                    O || (O = !0, d(g, S));
                }
            } else h._promiseTry(function() {
                return e();
            }).then(function(S) {
                d(g, void 0, S);
            }, function(S) {
                d(g, S);
            });
        }, "exec");
        h.domainReentrant && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].domain && (p = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].domain.bind(p));
        var m = i.maxPending || h.maxPending;
        if (!h.queues[t]) h.queues[t] = [], p(!0);
        else if (h.domainReentrant && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].domain && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].domain === h.domains[t]) p(!1);
        else if (h.queues[t].length >= m) d(!1, new Error("Too many pending tasks in queue " + t));
        else {
            var y = a(function() {
                p(!0);
            }, "taskFn");
            i.skipQueue ? h.queues[t].unshift(y) : h.queues[t].push(y);
            var w = i.timeout || h.timeout;
            w && (f = setTimeout(function() {
                f = null, d(!1, new Error("async-lock timed out in queue " + t));
            }, w));
        }
        var v = i.maxOccupationTime || h.maxOccupationTime;
        if (v && (c = setTimeout(function() {
            h.queues[t] && d(!1, new Error("Maximum occupation time is exceeded in queue " + t));
        }, v)), s) return s;
    };
    at.prototype._acquireBatch = function(t, e, r, i) {
        typeof r != "function" && (i = r, r = null);
        var n = this, o = a(function(l, f) {
            return function(c) {
                n.acquire(l, f, c, i);
            };
        }, "getFn"), s = t.reduceRight(function(l, f) {
            return o(f, l);
        }, e);
        if (typeof r == "function") s(r);
        else return new this.Promise(function(l, f) {
            s.length === 1 ? s(function(c, u) {
                c ? f(c) : l(u);
            }) : l(s());
        });
    };
    at.prototype.isBusy = function(t) {
        return t ? !!this.queues[t] : Object.keys(this.queues).length > 0;
    };
    at.prototype._promiseTry = function(t) {
        try {
            return this.Promise.resolve(t());
        } catch (e) {
            return this.Promise.reject(e);
        }
    };
    Zb.exports = at;
});
_c129 = Xb;
var Jb = T(_c130 = (j4, Yb)=>{
    "use strict";
    Yb.exports = Xb();
});
_c131 = Jb;
var ev = T((U4, Qb)=>{
    var RC = {}.toString;
    Qb.exports = Array.isArray || function(t) {
        return RC.call(t) == "[object Array]";
    };
});
var nv = T((q4, iv)=>{
    "use strict";
    var rv = Function.prototype.toString, Fn = typeof Reflect == "object" && Reflect !== null && Reflect.apply, ad, Pl;
    if (typeof Fn == "function" && typeof Object.defineProperty == "function") try {
        ad = Object.defineProperty({}, "length", {
            get: a(function() {
                throw Pl;
            }, "get")
        }), Pl = {}, Fn(function() {
            throw 42;
        }, null, ad);
    } catch (t) {
        t !== Pl && (Fn = null);
    }
    else Fn = null;
    var kC = /^\s*class\b/, ld = a(function(e) {
        try {
            var r = rv.call(e);
            return kC.test(r);
        } catch (e) {
            return !1;
        }
    }, "isES6ClassFunction"), sd = a(function(e) {
        try {
            return ld(e) ? !1 : (rv.call(e), !0);
        } catch (e) {
            return !1;
        }
    }, "tryFunctionToStr"), Al = Object.prototype.toString, PC = "[object Object]", AC = "[object Function]", IC = "[object GeneratorFunction]", DC = "[object HTMLAllCollection]", CC = "[object HTML document.all class]", NC = "[object HTMLCollection]", BC = typeof Symbol == "function" && !!Symbol.toStringTag, LC = !(0 in [
        , 
    ]), cd = a(function() {
        return !1;
    }, "isDocumentDotAll");
    typeof document == "object" && (tv = document.all, Al.call(tv) === Al.call(document.all) && (cd = a(function(e) {
        if ((LC || !e) && (typeof e > "u" || typeof e == "object")) try {
            var r = Al.call(e);
            return (r === DC || r === CC || r === NC || r === PC) && e("") == null;
        } catch (e) {}
        return !1;
    }, "isDocumentDotAll")));
    var tv;
    iv.exports = a(Fn ? function(e) {
        if (cd(e)) return !0;
        if (!e || typeof e != "function" && typeof e != "object") return !1;
        try {
            Fn(e, null, ad);
        } catch (r) {
            if (r !== Pl) return !1;
        }
        return !ld(e) && sd(e);
    } : function(e) {
        if (cd(e)) return !0;
        if (!e || typeof e != "function" && typeof e != "object") return !1;
        if (BC) return sd(e);
        if (ld(e)) return !1;
        var r = Al.call(e);
        return r !== AC && r !== IC && !/^\[object HTML/.test(r) ? !1 : sd(e);
    }, "isCallable");
});
var av = T((z4, sv)=>{
    "use strict";
    var $C = nv(), MC = Object.prototype.toString, ov = Object.prototype.hasOwnProperty, jC = a(function(e, r, i) {
        for(var n = 0, o = e.length; n < o; n++)ov.call(e, n) && (i == null ? r(e[n], n, e) : r.call(i, e[n], n, e));
    }, "forEachArray"), UC = a(function(e, r, i) {
        for(var n = 0, o = e.length; n < o; n++)i == null ? r(e.charAt(n), n, e) : r.call(i, e.charAt(n), n, e);
    }, "forEachString"), qC = a(function(e, r, i) {
        for(var n in e)ov.call(e, n) && (i == null ? r(e[n], n, e) : r.call(i, e[n], n, e));
    }, "forEachObject");
    function HC(t) {
        return MC.call(t) === "[object Array]";
    }
    a(HC, "isArray");
    sv.exports = a(function(e, r, i) {
        if (!$C(r)) throw new TypeError("iterator must be a function");
        var n;
        arguments.length >= 3 && (n = i), HC(e) ? jC(e, r, n) : typeof e == "string" ? UC(e, r, n) : qC(e, r, n);
    }, "forEach");
});
var cv = T((V4, lv)=>{
    "use strict";
    lv.exports = [
        "Float16Array",
        "Float32Array",
        "Float64Array",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "BigInt64Array",
        "BigUint64Array"
    ];
});
var uv = T((G4, fv)=>{
    "use strict";
    var fd = cv(), zC = globalThis;
    fv.exports = a(function() {
        for(var e = [], r = 0; r < fd.length; r++)typeof zC[fd[r]] == "function" && (e[e.length] = fd[r]);
        return e;
    }, "availableTypedArrays");
});
var mv = T((Z4, pv)=>{
    "use strict";
    var hv = go(), WC = _u(), En = qt(), dv = Qi();
    pv.exports = a(function(e, r, i) {
        if (!e || typeof e != "object" && typeof e != "function") throw new En("`obj` must be an object or a function`");
        if (typeof r != "string" && typeof r != "symbol") throw new En("`property` must be a string or a symbol`");
        if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new En("`nonEnumerable`, if provided, must be a boolean or null");
        if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new En("`nonWritable`, if provided, must be a boolean or null");
        if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new En("`nonConfigurable`, if provided, must be a boolean or null");
        if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new En("`loose`, if provided, must be a boolean");
        var n = arguments.length > 3 ? arguments[3] : null, o = arguments.length > 4 ? arguments[4] : null, s = arguments.length > 5 ? arguments[5] : null, l = arguments.length > 6 ? arguments[6] : !1, f = !!dv && dv(e, r);
        if (hv) hv(e, r, {
            configurable: s === null && f ? f.configurable : !s,
            enumerable: n === null && f ? f.enumerable : !n,
            value: i,
            writable: o === null && f ? f.writable : !o
        });
        else if (l || !n && !o && !s) e[r] = i;
        else throw new WC("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }, "defineDataProperty");
});
var gv = T((Y4, wv)=>{
    "use strict";
    var ud = go(), yv = a(function() {
        return !!ud;
    }, "hasPropertyDescriptors");
    yv.hasArrayLengthDefineBug = a(function() {
        if (!ud) return null;
        try {
            return ud([], "length", {
                value: 1
            }).length !== 1;
        } catch (e) {
            return !0;
        }
    }, "hasArrayLengthDefineBug");
    wv.exports = yv;
});
var Ev = T(_c132 = (Q4, Fv)=>{
    "use strict";
    var VC = Fo(), bv = mv(), GC = gv()(), vv = Qi(), _v = qt(), KC = VC("%Math.floor%");
    Fv.exports = a(function(e, r) {
        if (typeof e != "function") throw new _v("`fn` is not a function");
        if (typeof r != "number" || r < 0 || r > 4294967295 || KC(r) !== r) throw new _v("`length` must be a positive 32-bit integer");
        var i = arguments.length > 2 && !!arguments[2], n = !0, o = !0;
        if ("length" in e && vv) {
            var s = vv(e, "length");
            s && !s.configurable && (n = !1), s && !s.writable && (o = !1);
        }
        return (n || o || !i) && (GC ? bv(e, "length", r, !0, !0) : bv(e, "length", r)), e;
    }, "setFunctionLength");
});
_c133 = Ev;
var xv = T((tU, Sv)=>{
    "use strict";
    var ZC = en(), XC = Sa(), YC = xu();
    Sv.exports = a(function() {
        return YC(ZC, XC, arguments);
    }, "applyBind");
});
var Rv = T(_c134 = (iU, Il)=>{
    "use strict";
    var JC = Ev(), Tv = go(), QC = xa(), Ov = xv();
    Il.exports = a(function(e) {
        var r = QC(arguments), i = e.length - (arguments.length - 1);
        return JC(r, 1 + (i > 0 ? i : 0), !0);
    }, "callBind");
    Tv ? Tv(Il.exports, "apply", {
        value: Ov
    }) : Il.exports.apply = Ov;
});
_c135 = Rv;
var Pv = T(_c136 = (oU, kv)=>{
    "use strict";
    var e2 = Fu();
    kv.exports = a(function() {
        return e2() && !!Symbol.toStringTag;
    }, "hasToStringTagShams");
});
_c137 = Pv;
var Nv = T(_c138 = (aU, Cv)=>{
    "use strict";
    var Nl = av(), t2 = uv(), Av = Rv(), dd = Eo(), Cl = Qi(), Dl = Ou(), r2 = dd("Object.prototype.toString"), Dv = Pv()(), Iv = globalThis, hd = t2(), pd = dd("String.prototype.slice"), i2 = dd("Array.prototype.indexOf", !0) || a(function(e, r) {
        for(var i = 0; i < e.length; i += 1)if (e[i] === r) return i;
        return -1;
    }, "indexOf"), Bl = {
        __proto__: null
    };
    Dv && Cl && Dl ? Nl(hd, function(t) {
        var e = new Iv[t];
        if (Symbol.toStringTag in e && Dl) {
            var r = Dl(e), i = Cl(r, Symbol.toStringTag);
            if (!i && r) {
                var n = Dl(r);
                i = Cl(n, Symbol.toStringTag);
            }
            Bl["$" + t] = Av(i.get);
        }
    }) : Nl(hd, function(t) {
        var e = new Iv[t], r = e.slice || e.set;
        r && (Bl["$" + t] = Av(r));
    });
    var n2 = a(function(e) {
        var r = !1;
        return Nl(Bl, function(i, n) {
            if (!r) try {
                "$" + i(e) === n && (r = pd(n, 1));
            } catch (e) {}
        }), r;
    }, "tryAllTypedArrays"), o2 = a(function(e) {
        var r = !1;
        return Nl(Bl, function(i, n) {
            if (!r) try {
                i(e), r = pd(n, 1);
            } catch (e) {}
        }), r;
    }, "tryAllSlices");
    Cv.exports = a(function(e) {
        if (!e || typeof e != "object") return !1;
        if (!Dv) {
            var r = pd(r2(e), 8, -1);
            return i2(hd, r) > -1 ? r : r !== "Object" ? !1 : o2(e);
        }
        return Cl ? n2(e) : null;
    }, "whichTypedArray");
});
_c139 = Nv;
var Lv = T(_c140 = (cU, Bv)=>{
    "use strict";
    var s2 = Nv();
    Bv.exports = a(function(e) {
        return !!s2(e);
    }, "isTypedArray");
});
_c141 = Lv;
var Mv = T(_c142 = (uU, $v)=>{
    "use strict";
    var a2 = qt(), l2 = Eo(), c2 = l2("TypedArray.prototype.buffer", !0), f2 = Lv();
    $v.exports = c2 || a(function(e) {
        if (!f2(e)) throw new a2("Not a Typed Array");
        return e.buffer;
    }, "typedArrayBuffer");
});
_c143 = Mv;
var qv = T((dU, Uv)=>{
    "use strict";
    var At = Do().Buffer, u2 = ev(), h2 = Mv(), d2 = ArrayBuffer.isView || a(function(e) {
        try {
            return h2(e), !0;
        } catch (e) {
            return !1;
        }
    }, "isView"), p2 = typeof Uint8Array < "u", jv = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", m2 = jv && (At.prototype instanceof Uint8Array || At.TYPED_ARRAY_SUPPORT);
    Uv.exports = a(function(e, r) {
        if (At.isBuffer(e)) return e.constructor && !("isBuffer" in e) ? At.from(e) : e;
        if (typeof e == "string") return At.from(e, r);
        if (jv && d2(e)) {
            if (e.byteLength === 0) return At.alloc(0);
            if (m2) {
                var i = At.from(e.buffer, e.byteOffset, e.byteLength);
                if (i.byteLength === e.byteLength) return i;
            }
            var n = e instanceof Uint8Array ? e : new Uint8Array(e.buffer, e.byteOffset, e.byteLength), o = At.from(n);
            if (o.length === e.byteLength) return o;
        }
        if (p2 && e instanceof Uint8Array) return At.from(e);
        var s = u2(e);
        if (s) for(var l = 0; l < e.length; l += 1){
            var f = e[l];
            if (typeof f != "number" || f < 0 || f > 255 || ~~f !== f) throw new RangeError("Array items must be numbers in the range 0-255.");
        }
        if (s || At.isBuffer(e) && e.constructor && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e)) return At.from(e);
        throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
    }, "toBuffer");
});
var zv = T((mU, Hv)=>{
    "use strict";
    var y2 = Do().Buffer, w2 = qv();
    function Ll(t, e) {
        this._block = y2.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
    }
    a(Ll, "Hash");
    Ll.prototype.update = function(t, e) {
        t = w2(t, e || "utf8");
        for(var r = this._block, i = this._blockSize, n = t.length, o = this._len, s = 0; s < n;){
            for(var l = o % i, f = Math.min(n - s, i - l), c = 0; c < f; c++)r[l + c] = t[s + c];
            o += f, s += f, o % i === 0 && this._update(r);
        }
        return this._len += n, this;
    };
    Ll.prototype.digest = function(t) {
        var e = this._len % this._blockSize;
        this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
        var r = this._len * 8;
        if (r <= 4294967295) this._block.writeUInt32BE(r, this._blockSize - 4);
        else {
            var i = (r & 4294967295) >>> 0, n = (r - i) / 4294967296;
            this._block.writeUInt32BE(n, this._blockSize - 8), this._block.writeUInt32BE(i, this._blockSize - 4);
        }
        this._update(this._block);
        var o = this._hash();
        return t ? o.toString(t) : o;
    };
    Ll.prototype._update = function() {
        throw new Error("_update must be implemented by subclass");
    };
    Hv.exports = Ll;
});
var Gv = T(_c144 = (wU, Vv)=>{
    "use strict";
    var g2 = Gt(), Wv = zv(), b2 = Do().Buffer, v2 = [
        1518500249,
        1859775393,
        -1894007588,
        -899497514
    ], _2 = new Array(80);
    function Go() {
        this.init(), this._w = _2, Wv.call(this, 64, 56);
    }
    a(Go, "Sha1");
    g2(Go, Wv);
    Go.prototype.init = function() {
        return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function F2(t) {
        return t << 1 | t >>> 31;
    }
    a(F2, "rotl1");
    function E2(t) {
        return t << 5 | t >>> 27;
    }
    a(E2, "rotl5");
    function S2(t) {
        return t << 30 | t >>> 2;
    }
    a(S2, "rotl30");
    function x2(t, e, r, i) {
        return t === 0 ? e & r | ~e & i : t === 2 ? e & r | e & i | r & i : e ^ r ^ i;
    }
    a(x2, "ft");
    Go.prototype._update = function(t) {
        for(var e = this._w, r = this._a | 0, i = this._b | 0, n = this._c | 0, o = this._d | 0, s = this._e | 0, l = 0; l < 16; ++l)e[l] = t.readInt32BE(l * 4);
        for(; l < 80; ++l)e[l] = F2(e[l - 3] ^ e[l - 8] ^ e[l - 14] ^ e[l - 16]);
        for(var f = 0; f < 80; ++f){
            var c = ~~(f / 20), u = E2(r) + x2(c, i, n, o) + s + e[f] + v2[c] | 0;
            s = o, o = n, n = S2(i), i = r, r = u;
        }
        this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = n + this._c | 0, this._d = o + this._d | 0, this._e = s + this._e | 0;
    };
    Go.prototype._hash = function() {
        var t = b2.allocUnsafe(20);
        return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Vv.exports = Go;
});
_c145 = Gv;
var Zv = T(_c146 = (md)=>{
    var Kv;
    (function(t) {
        typeof DO_NOT_EXPORT_CRC > "u" ? typeof md == "object" ? t(md) : typeof define == "function" && define.amd ? ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            var e = {};
            return t(e), e;
        }(__turbopack_context__.r, exports, module)) : t(Kv = {}) : t(Kv = {});
    })(function(t) {
        t.version = "1.2.2";
        function e() {
            for(var b = 0, x = new Array(256), _ = 0; _ != 256; ++_)b = _, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, x[_] = b;
            return typeof Int32Array < "u" ? new Int32Array(x) : x;
        }
        a(e, "signed_crc_table");
        var r = e();
        function i(b) {
            var x = 0, _ = 0, P = 0, k = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
            for(P = 0; P != 256; ++P)k[P] = b[P];
            for(P = 0; P != 256; ++P)for(_ = b[P], x = 256 + P; x < 4096; x += 256)_ = k[x] = _ >>> 8 ^ b[_ & 255];
            var C = [];
            for(P = 1; P != 16; ++P)C[P - 1] = typeof Int32Array < "u" ? k.subarray(P * 256, P * 256 + 256) : k.slice(P * 256, P * 256 + 256);
            return C;
        }
        a(i, "slice_by_16_tables");
        var n = i(r), o = n[0], s = n[1], l = n[2], f = n[3], c = n[4], u = n[5], h = n[6], d = n[7], p = n[8], m = n[9], y = n[10], w = n[11], v = n[12], g = n[13], F = n[14];
        function O(b, x) {
            for(var _ = x ^ -1, P = 0, k = b.length; P < k;)_ = _ >>> 8 ^ r[(_ ^ b.charCodeAt(P++)) & 255];
            return ~_;
        }
        a(O, "crc32_bstr");
        function S(b, x) {
            for(var _ = x ^ -1, P = b.length - 15, k = 0; k < P;)_ = F[b[k++] ^ _ & 255] ^ g[b[k++] ^ _ >> 8 & 255] ^ v[b[k++] ^ _ >> 16 & 255] ^ w[b[k++] ^ _ >>> 24] ^ y[b[k++]] ^ m[b[k++]] ^ p[b[k++]] ^ d[b[k++]] ^ h[b[k++]] ^ u[b[k++]] ^ c[b[k++]] ^ f[b[k++]] ^ l[b[k++]] ^ s[b[k++]] ^ o[b[k++]] ^ r[b[k++]];
            for(P += 15; k < P;)_ = _ >>> 8 ^ r[(_ ^ b[k++]) & 255];
            return ~_;
        }
        a(S, "crc32_buf");
        function R(b, x) {
            for(var _ = x ^ -1, P = 0, k = b.length, C = 0, N = 0; P < k;)C = b.charCodeAt(P++), C < 128 ? _ = _ >>> 8 ^ r[(_ ^ C) & 255] : C < 2048 ? (_ = _ >>> 8 ^ r[(_ ^ (192 | C >> 6 & 31)) & 255], _ = _ >>> 8 ^ r[(_ ^ (128 | C & 63)) & 255]) : C >= 55296 && C < 57344 ? (C = (C & 1023) + 64, N = b.charCodeAt(P++) & 1023, _ = _ >>> 8 ^ r[(_ ^ (240 | C >> 8 & 7)) & 255], _ = _ >>> 8 ^ r[(_ ^ (128 | C >> 2 & 63)) & 255], _ = _ >>> 8 ^ r[(_ ^ (128 | N >> 6 & 15 | (C & 3) << 4)) & 255], _ = _ >>> 8 ^ r[(_ ^ (128 | N & 63)) & 255]) : (_ = _ >>> 8 ^ r[(_ ^ (224 | C >> 12 & 15)) & 255], _ = _ >>> 8 ^ r[(_ ^ (128 | C >> 6 & 63)) & 255], _ = _ >>> 8 ^ r[(_ ^ (128 | C & 63)) & 255]);
            return ~_;
        }
        a(R, "crc32_str"), t.table = r, t.bstr = O, t.buf = S, t.str = R;
    });
});
_c147 = Zv;
var hr = T((Ge)=>{
    "use strict";
    var T2 = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
    function O2(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e);
    }
    a(O2, "_has");
    Ge.assign = function(t) {
        for(var e = Array.prototype.slice.call(arguments, 1); e.length;){
            var r = e.shift();
            if (r) {
                if (typeof r != "object") throw new TypeError(r + "must be non-object");
                for(var i in r)O2(r, i) && (t[i] = r[i]);
            }
        }
        return t;
    };
    Ge.shrinkBuf = function(t, e) {
        return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t);
    };
    var R2 = {
        arraySet: a(function(t, e, r, i, n) {
            if (e.subarray && t.subarray) {
                t.set(e.subarray(r, r + i), n);
                return;
            }
            for(var o = 0; o < i; o++)t[n + o] = e[r + o];
        }, "arraySet"),
        flattenChunks: a(function(t) {
            var e, r, i, n, o, s;
            for(i = 0, e = 0, r = t.length; e < r; e++)i += t[e].length;
            for(s = new Uint8Array(i), n = 0, e = 0, r = t.length; e < r; e++)o = t[e], s.set(o, n), n += o.length;
            return s;
        }, "flattenChunks")
    }, k2 = {
        arraySet: a(function(t, e, r, i, n) {
            for(var o = 0; o < i; o++)t[n + o] = e[r + o];
        }, "arraySet"),
        flattenChunks: a(function(t) {
            return [].concat.apply([], t);
        }, "flattenChunks")
    };
    Ge.setTyped = function(t) {
        t ? (Ge.Buf8 = Uint8Array, Ge.Buf16 = Uint16Array, Ge.Buf32 = Int32Array, Ge.assign(Ge, R2)) : (Ge.Buf8 = Array, Ge.Buf16 = Array, Ge.Buf32 = Array, Ge.assign(Ge, k2));
    };
    Ge.setTyped(T2);
});
var g_ = T((Tn)=>{
    "use strict";
    var P2 = hr(), A2 = 4, Xv = 0, Yv = 1, I2 = 2;
    function xn(t) {
        for(var e = t.length; --e >= 0;)t[e] = 0;
    }
    a(xn, "zero");
    var D2 = 0, i_ = 1, C2 = 2, N2 = 3, B2 = 258, Fd = 29, Qo = 256, Zo = Qo + 1 + Fd, Sn = 30, Ed = 19, n_ = 2 * Zo + 1, gi = 15, yd = 16, L2 = 7, Sd = 256, o_ = 16, s_ = 17, a_ = 18, vd = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0
    ], $l = [
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13
    ], $2 = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        3,
        7
    ], l_ = [
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
    ], M2 = 512, dr = new Array((Zo + 2) * 2);
    xn(dr);
    var Ko = new Array(Sn * 2);
    xn(Ko);
    var Xo = new Array(M2);
    xn(Xo);
    var Yo = new Array(B2 - N2 + 1);
    xn(Yo);
    var xd = new Array(Fd);
    xn(xd);
    var Ml = new Array(Sn);
    xn(Ml);
    function wd(t, e, r, i, n) {
        this.static_tree = t, this.extra_bits = e, this.extra_base = r, this.elems = i, this.max_length = n, this.has_stree = t && t.length;
    }
    a(wd, "StaticTreeDesc");
    var c_, f_, u_;
    function gd(t, e) {
        this.dyn_tree = t, this.max_code = 0, this.stat_desc = e;
    }
    a(gd, "TreeDesc");
    function h_(t) {
        return t < 256 ? Xo[t] : Xo[256 + (t >>> 7)];
    }
    a(h_, "d_code");
    function Jo(t, e) {
        t.pending_buf[t.pending++] = e & 255, t.pending_buf[t.pending++] = e >>> 8 & 255;
    }
    a(Jo, "put_short");
    function Ye(t, e, r) {
        t.bi_valid > yd - r ? (t.bi_buf |= e << t.bi_valid & 65535, Jo(t, t.bi_buf), t.bi_buf = e >> yd - t.bi_valid, t.bi_valid += r - yd) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += r);
    }
    a(Ye, "send_bits");
    function Yt(t, e, r) {
        Ye(t, r[e * 2], r[e * 2 + 1]);
    }
    a(Yt, "send_code");
    function d_(t, e) {
        var r = 0;
        do r |= t & 1, t >>>= 1, r <<= 1;
        while (--e > 0)
        return r >>> 1;
    }
    a(d_, "bi_reverse");
    function j2(t) {
        t.bi_valid === 16 ? (Jo(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = t.bi_buf & 255, t.bi_buf >>= 8, t.bi_valid -= 8);
    }
    a(j2, "bi_flush");
    function U2(t, e) {
        var r = e.dyn_tree, i = e.max_code, n = e.stat_desc.static_tree, o = e.stat_desc.has_stree, s = e.stat_desc.extra_bits, l = e.stat_desc.extra_base, f = e.stat_desc.max_length, c, u, h, d, p, m, y = 0;
        for(d = 0; d <= gi; d++)t.bl_count[d] = 0;
        for(r[t.heap[t.heap_max] * 2 + 1] = 0, c = t.heap_max + 1; c < n_; c++)u = t.heap[c], d = r[r[u * 2 + 1] * 2 + 1] + 1, d > f && (d = f, y++), r[u * 2 + 1] = d, !(u > i) && (t.bl_count[d]++, p = 0, u >= l && (p = s[u - l]), m = r[u * 2], t.opt_len += m * (d + p), o && (t.static_len += m * (n[u * 2 + 1] + p)));
        if (y !== 0) {
            do {
                for(d = f - 1; t.bl_count[d] === 0;)d--;
                t.bl_count[d]--, t.bl_count[d + 1] += 2, t.bl_count[f]--, y -= 2;
            }while (y > 0)
            for(d = f; d !== 0; d--)for(u = t.bl_count[d]; u !== 0;)h = t.heap[--c], !(h > i) && (r[h * 2 + 1] !== d && (t.opt_len += (d - r[h * 2 + 1]) * r[h * 2], r[h * 2 + 1] = d), u--);
        }
    }
    a(U2, "gen_bitlen");
    function p_(t, e, r) {
        var i = new Array(gi + 1), n = 0, o, s;
        for(o = 1; o <= gi; o++)i[o] = n = n + r[o - 1] << 1;
        for(s = 0; s <= e; s++){
            var l = t[s * 2 + 1];
            l !== 0 && (t[s * 2] = d_(i[l]++, l));
        }
    }
    a(p_, "gen_codes");
    function q2() {
        var t, e, r, i, n, o = new Array(gi + 1);
        for(r = 0, i = 0; i < Fd - 1; i++)for(xd[i] = r, t = 0; t < 1 << vd[i]; t++)Yo[r++] = i;
        for(Yo[r - 1] = i, n = 0, i = 0; i < 16; i++)for(Ml[i] = n, t = 0; t < 1 << $l[i]; t++)Xo[n++] = i;
        for(n >>= 7; i < Sn; i++)for(Ml[i] = n << 7, t = 0; t < 1 << $l[i] - 7; t++)Xo[256 + n++] = i;
        for(e = 0; e <= gi; e++)o[e] = 0;
        for(t = 0; t <= 143;)dr[t * 2 + 1] = 8, t++, o[8]++;
        for(; t <= 255;)dr[t * 2 + 1] = 9, t++, o[9]++;
        for(; t <= 279;)dr[t * 2 + 1] = 7, t++, o[7]++;
        for(; t <= 287;)dr[t * 2 + 1] = 8, t++, o[8]++;
        for(p_(dr, Zo + 1, o), t = 0; t < Sn; t++)Ko[t * 2 + 1] = 5, Ko[t * 2] = d_(t, 5);
        c_ = new wd(dr, vd, Qo + 1, Zo, gi), f_ = new wd(Ko, $l, 0, Sn, gi), u_ = new wd(new Array(0), $2, 0, Ed, L2);
    }
    a(q2, "tr_static_init");
    function m_(t) {
        var e;
        for(e = 0; e < Zo; e++)t.dyn_ltree[e * 2] = 0;
        for(e = 0; e < Sn; e++)t.dyn_dtree[e * 2] = 0;
        for(e = 0; e < Ed; e++)t.bl_tree[e * 2] = 0;
        t.dyn_ltree[Sd * 2] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0;
    }
    a(m_, "init_block");
    function y_(t) {
        t.bi_valid > 8 ? Jo(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0;
    }
    a(y_, "bi_windup");
    function H2(t, e, r, i) {
        y_(t), i && (Jo(t, r), Jo(t, ~r)), P2.arraySet(t.pending_buf, t.window, e, r, t.pending), t.pending += r;
    }
    a(H2, "copy_block");
    function Jv(t, e, r, i) {
        var n = e * 2, o = r * 2;
        return t[n] < t[o] || t[n] === t[o] && i[e] <= i[r];
    }
    a(Jv, "smaller");
    function bd(t, e, r) {
        for(var i = t.heap[r], n = r << 1; n <= t.heap_len && (n < t.heap_len && Jv(e, t.heap[n + 1], t.heap[n], t.depth) && n++, !Jv(e, i, t.heap[n], t.depth));)t.heap[r] = t.heap[n], r = n, n <<= 1;
        t.heap[r] = i;
    }
    a(bd, "pqdownheap");
    function Qv(t, e, r) {
        var i, n, o = 0, s, l;
        if (t.last_lit !== 0) do i = t.pending_buf[t.d_buf + o * 2] << 8 | t.pending_buf[t.d_buf + o * 2 + 1], n = t.pending_buf[t.l_buf + o], o++, i === 0 ? Yt(t, n, e) : (s = Yo[n], Yt(t, s + Qo + 1, e), l = vd[s], l !== 0 && (n -= xd[s], Ye(t, n, l)), i--, s = h_(i), Yt(t, s, r), l = $l[s], l !== 0 && (i -= Ml[s], Ye(t, i, l)));
        while (o < t.last_lit)
        Yt(t, Sd, e);
    }
    a(Qv, "compress_block");
    function _d(t, e) {
        var r = e.dyn_tree, i = e.stat_desc.static_tree, n = e.stat_desc.has_stree, o = e.stat_desc.elems, s, l, f = -1, c;
        for(t.heap_len = 0, t.heap_max = n_, s = 0; s < o; s++)r[s * 2] !== 0 ? (t.heap[++t.heap_len] = f = s, t.depth[s] = 0) : r[s * 2 + 1] = 0;
        for(; t.heap_len < 2;)c = t.heap[++t.heap_len] = f < 2 ? ++f : 0, r[c * 2] = 1, t.depth[c] = 0, t.opt_len--, n && (t.static_len -= i[c * 2 + 1]);
        for(e.max_code = f, s = t.heap_len >> 1; s >= 1; s--)bd(t, r, s);
        c = o;
        do s = t.heap[1], t.heap[1] = t.heap[t.heap_len--], bd(t, r, 1), l = t.heap[1], t.heap[--t.heap_max] = s, t.heap[--t.heap_max] = l, r[c * 2] = r[s * 2] + r[l * 2], t.depth[c] = (t.depth[s] >= t.depth[l] ? t.depth[s] : t.depth[l]) + 1, r[s * 2 + 1] = r[l * 2 + 1] = c, t.heap[1] = c++, bd(t, r, 1);
        while (t.heap_len >= 2)
        t.heap[--t.heap_max] = t.heap[1], U2(t, e), p_(r, f, t.bl_count);
    }
    a(_d, "build_tree");
    function e_(t, e, r) {
        var i, n = -1, o, s = e[0 * 2 + 1], l = 0, f = 7, c = 4;
        for(s === 0 && (f = 138, c = 3), e[(r + 1) * 2 + 1] = 65535, i = 0; i <= r; i++)o = s, s = e[(i + 1) * 2 + 1], !(++l < f && o === s) && (l < c ? t.bl_tree[o * 2] += l : o !== 0 ? (o !== n && t.bl_tree[o * 2]++, t.bl_tree[o_ * 2]++) : l <= 10 ? t.bl_tree[s_ * 2]++ : t.bl_tree[a_ * 2]++, l = 0, n = o, s === 0 ? (f = 138, c = 3) : o === s ? (f = 6, c = 3) : (f = 7, c = 4));
    }
    a(e_, "scan_tree");
    function t_(t, e, r) {
        var i, n = -1, o, s = e[0 * 2 + 1], l = 0, f = 7, c = 4;
        for(s === 0 && (f = 138, c = 3), i = 0; i <= r; i++)if (o = s, s = e[(i + 1) * 2 + 1], !(++l < f && o === s)) {
            if (l < c) do Yt(t, o, t.bl_tree);
            while (--l !== 0)
            else o !== 0 ? (o !== n && (Yt(t, o, t.bl_tree), l--), Yt(t, o_, t.bl_tree), Ye(t, l - 3, 2)) : l <= 10 ? (Yt(t, s_, t.bl_tree), Ye(t, l - 3, 3)) : (Yt(t, a_, t.bl_tree), Ye(t, l - 11, 7));
            l = 0, n = o, s === 0 ? (f = 138, c = 3) : o === s ? (f = 6, c = 3) : (f = 7, c = 4);
        }
    }
    a(t_, "send_tree");
    function z2(t) {
        var e;
        for(e_(t, t.dyn_ltree, t.l_desc.max_code), e_(t, t.dyn_dtree, t.d_desc.max_code), _d(t, t.bl_desc), e = Ed - 1; e >= 3 && t.bl_tree[l_[e] * 2 + 1] === 0; e--);
        return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e;
    }
    a(z2, "build_bl_tree");
    function W2(t, e, r, i) {
        var n;
        for(Ye(t, e - 257, 5), Ye(t, r - 1, 5), Ye(t, i - 4, 4), n = 0; n < i; n++)Ye(t, t.bl_tree[l_[n] * 2 + 1], 3);
        t_(t, t.dyn_ltree, e - 1), t_(t, t.dyn_dtree, r - 1);
    }
    a(W2, "send_all_trees");
    function V2(t) {
        var e = 4093624447, r;
        for(r = 0; r <= 31; r++, e >>>= 1)if (e & 1 && t.dyn_ltree[r * 2] !== 0) return Xv;
        if (t.dyn_ltree[9 * 2] !== 0 || t.dyn_ltree[10 * 2] !== 0 || t.dyn_ltree[13 * 2] !== 0) return Yv;
        for(r = 32; r < Qo; r++)if (t.dyn_ltree[r * 2] !== 0) return Yv;
        return Xv;
    }
    a(V2, "detect_data_type");
    var r_ = !1;
    function G2(t) {
        r_ || (q2(), r_ = !0), t.l_desc = new gd(t.dyn_ltree, c_), t.d_desc = new gd(t.dyn_dtree, f_), t.bl_desc = new gd(t.bl_tree, u_), t.bi_buf = 0, t.bi_valid = 0, m_(t);
    }
    a(G2, "_tr_init");
    function w_(t, e, r, i) {
        Ye(t, (D2 << 1) + (i ? 1 : 0), 3), H2(t, e, r, !0);
    }
    a(w_, "_tr_stored_block");
    function K2(t) {
        Ye(t, i_ << 1, 3), Yt(t, Sd, dr), j2(t);
    }
    a(K2, "_tr_align");
    function Z2(t, e, r, i) {
        var n, o, s = 0;
        t.level > 0 ? (t.strm.data_type === I2 && (t.strm.data_type = V2(t)), _d(t, t.l_desc), _d(t, t.d_desc), s = z2(t), n = t.opt_len + 3 + 7 >>> 3, o = t.static_len + 3 + 7 >>> 3, o <= n && (n = o)) : n = o = r + 5, r + 4 <= n && e !== -1 ? w_(t, e, r, i) : t.strategy === A2 || o === n ? (Ye(t, (i_ << 1) + (i ? 1 : 0), 3), Qv(t, dr, Ko)) : (Ye(t, (C2 << 1) + (i ? 1 : 0), 3), W2(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, s + 1), Qv(t, t.dyn_ltree, t.dyn_dtree)), m_(t), i && y_(t);
    }
    a(Z2, "_tr_flush_block");
    function X2(t, e, r) {
        return t.pending_buf[t.d_buf + t.last_lit * 2] = e >>> 8 & 255, t.pending_buf[t.d_buf + t.last_lit * 2 + 1] = e & 255, t.pending_buf[t.l_buf + t.last_lit] = r & 255, t.last_lit++, e === 0 ? t.dyn_ltree[r * 2]++ : (t.matches++, e--, t.dyn_ltree[(Yo[r] + Qo + 1) * 2]++, t.dyn_dtree[h_(e) * 2]++), t.last_lit === t.lit_bufsize - 1;
    }
    a(X2, "_tr_tally");
    Tn._tr_init = G2;
    Tn._tr_stored_block = w_;
    Tn._tr_flush_block = Z2;
    Tn._tr_tally = X2;
    Tn._tr_align = K2;
});
var Td = T(_c148 = (xU, b_)=>{
    "use strict";
    function Y2(t, e, r, i) {
        for(var n = t & 65535 | 0, o = t >>> 16 & 65535 | 0, s = 0; r !== 0;){
            s = r > 2e3 ? 2e3 : r, r -= s;
            do n = n + e[i++] | 0, o = o + n | 0;
            while (--s)
            n %= 65521, o %= 65521;
        }
        return n | o << 16 | 0;
    }
    a(Y2, "adler32");
    b_.exports = Y2;
});
_c149 = Td;
var Od = T(_c150 = (OU, v_)=>{
    "use strict";
    function J2() {
        for(var t, e = [], r = 0; r < 256; r++){
            t = r;
            for(var i = 0; i < 8; i++)t = t & 1 ? 3988292384 ^ t >>> 1 : t >>> 1;
            e[r] = t;
        }
        return e;
    }
    a(J2, "makeTable");
    var Q2 = J2();
    function eN(t, e, r, i) {
        var n = Q2, o = i + r;
        t ^= -1;
        for(var s = i; s < o; s++)t = t >>> 8 ^ n[(t ^ e[s]) & 255];
        return t ^ -1;
    }
    a(eN, "crc32");
    v_.exports = eN;
});
_c151 = Od;
var jl = T((kU, __)=>{
    "use strict";
    __.exports = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
    };
});
var P_ = T(_c152 = (er)=>{
    "use strict";
    var Ke = hr(), vt = g_(), x_ = Td(), Lr = Od(), tN = jl(), Fi = 0, rN = 1, iN = 3, qr = 4, F_ = 5, Qt = 0, E_ = 1, _t = -2, nN = -3, Rd = -5, oN = -1, sN = 1, Ul = 2, aN = 3, lN = 4, cN = 0, fN = 2, Wl = 8, uN = 9, hN = 15, dN = 8, pN = 29, mN = 256, Pd = mN + 1 + pN, yN = 30, wN = 19, gN = 2 * Pd + 1, bN = 15, Q = 3, jr = 258, It = jr + Q + 1, vN = 32, Vl = 42, Ad = 69, ql = 73, Hl = 91, zl = 103, bi = 113, ts = 666, Ae = 1, rs = 2, vi = 3, kn = 4, _N = 3;
    function Ur(t, e) {
        return t.msg = tN[e], e;
    }
    a(Ur, "err");
    function S_(t) {
        return (t << 1) - (t > 4 ? 9 : 0);
    }
    a(S_, "rank");
    function Mr(t) {
        for(var e = t.length; --e >= 0;)t[e] = 0;
    }
    a(Mr, "zero");
    function $r(t) {
        var e = t.state, r = e.pending;
        r > t.avail_out && (r = t.avail_out), r !== 0 && (Ke.arraySet(t.output, e.pending_buf, e.pending_out, r, t.next_out), t.next_out += r, e.pending_out += r, t.total_out += r, t.avail_out -= r, e.pending -= r, e.pending === 0 && (e.pending_out = 0));
    }
    a($r, "flush_pending");
    function $e(t, e) {
        vt._tr_flush_block(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, $r(t.strm);
    }
    a($e, "flush_block_only");
    function oe(t, e) {
        t.pending_buf[t.pending++] = e;
    }
    a(oe, "put_byte");
    function es(t, e) {
        t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = e & 255;
    }
    a(es, "putShortMSB");
    function FN(t, e, r, i) {
        var n = t.avail_in;
        return n > i && (n = i), n === 0 ? 0 : (t.avail_in -= n, Ke.arraySet(e, t.input, t.next_in, n, r), t.state.wrap === 1 ? t.adler = x_(t.adler, e, n, r) : t.state.wrap === 2 && (t.adler = Lr(t.adler, e, n, r)), t.next_in += n, t.total_in += n, n);
    }
    a(FN, "read_buf");
    function T_(t, e) {
        var r = t.max_chain_length, i = t.strstart, n, o, s = t.prev_length, l = t.nice_match, f = t.strstart > t.w_size - It ? t.strstart - (t.w_size - It) : 0, c = t.window, u = t.w_mask, h = t.prev, d = t.strstart + jr, p = c[i + s - 1], m = c[i + s];
        t.prev_length >= t.good_match && (r >>= 2), l > t.lookahead && (l = t.lookahead);
        do if (n = e, !(c[n + s] !== m || c[n + s - 1] !== p || c[n] !== c[i] || c[++n] !== c[i + 1])) {
            i += 2, n++;
            do ;
            while (c[++i] === c[++n] && c[++i] === c[++n] && c[++i] === c[++n] && c[++i] === c[++n] && c[++i] === c[++n] && c[++i] === c[++n] && c[++i] === c[++n] && c[++i] === c[++n] && i < d)
            if (o = jr - (d - i), i = d - jr, o > s) {
                if (t.match_start = e, s = o, o >= l) break;
                p = c[i + s - 1], m = c[i + s];
            }
        }
        while ((e = h[e & u]) > f && --r !== 0)
        return s <= t.lookahead ? s : t.lookahead;
    }
    a(T_, "longest_match");
    function _i(t) {
        var e = t.w_size, r, i, n, o, s;
        do {
            if (o = t.window_size - t.lookahead - t.strstart, t.strstart >= e + (e - It)) {
                Ke.arraySet(t.window, t.window, e, e, 0), t.match_start -= e, t.strstart -= e, t.block_start -= e, i = t.hash_size, r = i;
                do n = t.head[--r], t.head[r] = n >= e ? n - e : 0;
                while (--i)
                i = e, r = i;
                do n = t.prev[--r], t.prev[r] = n >= e ? n - e : 0;
                while (--i)
                o += e;
            }
            if (t.strm.avail_in === 0) break;
            if (i = FN(t.strm, t.window, t.strstart + t.lookahead, o), t.lookahead += i, t.lookahead + t.insert >= Q) for(s = t.strstart - t.insert, t.ins_h = t.window[s], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[s + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[s + Q - 1]) & t.hash_mask, t.prev[s & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = s, s++, t.insert--, !(t.lookahead + t.insert < Q)););
        }while (t.lookahead < It && t.strm.avail_in !== 0)
    }
    a(_i, "fill_window");
    function EN(t, e) {
        var r = 65535;
        for(r > t.pending_buf_size - 5 && (r = t.pending_buf_size - 5);;){
            if (t.lookahead <= 1) {
                if (_i(t), t.lookahead === 0 && e === Fi) return Ae;
                if (t.lookahead === 0) break;
            }
            t.strstart += t.lookahead, t.lookahead = 0;
            var i = t.block_start + r;
            if ((t.strstart === 0 || t.strstart >= i) && (t.lookahead = t.strstart - i, t.strstart = i, $e(t, !1), t.strm.avail_out === 0) || t.strstart - t.block_start >= t.w_size - It && ($e(t, !1), t.strm.avail_out === 0)) return Ae;
        }
        return t.insert = 0, e === qr ? ($e(t, !0), t.strm.avail_out === 0 ? vi : kn) : (t.strstart > t.block_start && ($e(t, !1), t.strm.avail_out === 0), Ae);
    }
    a(EN, "deflate_stored");
    function kd(t, e) {
        for(var r, i;;){
            if (t.lookahead < It) {
                if (_i(t), t.lookahead < It && e === Fi) return Ae;
                if (t.lookahead === 0) break;
            }
            if (r = 0, t.lookahead >= Q && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + Q - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), r !== 0 && t.strstart - r <= t.w_size - It && (t.match_length = T_(t, r)), t.match_length >= Q) if (i = vt._tr_tally(t, t.strstart - t.match_start, t.match_length - Q), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= Q) {
                t.match_length--;
                do t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + Q - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart;
                while (--t.match_length !== 0)
                t.strstart++;
            } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask;
            else i = vt._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
            if (i && ($e(t, !1), t.strm.avail_out === 0)) return Ae;
        }
        return t.insert = t.strstart < Q - 1 ? t.strstart : Q - 1, e === qr ? ($e(t, !0), t.strm.avail_out === 0 ? vi : kn) : t.last_lit && ($e(t, !1), t.strm.avail_out === 0) ? Ae : rs;
    }
    a(kd, "deflate_fast");
    function On(t, e) {
        for(var r, i, n;;){
            if (t.lookahead < It) {
                if (_i(t), t.lookahead < It && e === Fi) return Ae;
                if (t.lookahead === 0) break;
            }
            if (r = 0, t.lookahead >= Q && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + Q - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = Q - 1, r !== 0 && t.prev_length < t.max_lazy_match && t.strstart - r <= t.w_size - It && (t.match_length = T_(t, r), t.match_length <= 5 && (t.strategy === sN || t.match_length === Q && t.strstart - t.match_start > 4096) && (t.match_length = Q - 1)), t.prev_length >= Q && t.match_length <= t.prev_length) {
                n = t.strstart + t.lookahead - Q, i = vt._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - Q), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;
                do ++t.strstart <= n && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + Q - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart);
                while (--t.prev_length !== 0)
                if (t.match_available = 0, t.match_length = Q - 1, t.strstart++, i && ($e(t, !1), t.strm.avail_out === 0)) return Ae;
            } else if (t.match_available) {
                if (i = vt._tr_tally(t, 0, t.window[t.strstart - 1]), i && $e(t, !1), t.strstart++, t.lookahead--, t.strm.avail_out === 0) return Ae;
            } else t.match_available = 1, t.strstart++, t.lookahead--;
        }
        return t.match_available && (i = vt._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < Q - 1 ? t.strstart : Q - 1, e === qr ? ($e(t, !0), t.strm.avail_out === 0 ? vi : kn) : t.last_lit && ($e(t, !1), t.strm.avail_out === 0) ? Ae : rs;
    }
    a(On, "deflate_slow");
    function SN(t, e) {
        for(var r, i, n, o, s = t.window;;){
            if (t.lookahead <= jr) {
                if (_i(t), t.lookahead <= jr && e === Fi) return Ae;
                if (t.lookahead === 0) break;
            }
            if (t.match_length = 0, t.lookahead >= Q && t.strstart > 0 && (n = t.strstart - 1, i = s[n], i === s[++n] && i === s[++n] && i === s[++n])) {
                o = t.strstart + jr;
                do ;
                while (i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && n < o)
                t.match_length = jr - (o - n), t.match_length > t.lookahead && (t.match_length = t.lookahead);
            }
            if (t.match_length >= Q ? (r = vt._tr_tally(t, 1, t.match_length - Q), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (r = vt._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), r && ($e(t, !1), t.strm.avail_out === 0)) return Ae;
        }
        return t.insert = 0, e === qr ? ($e(t, !0), t.strm.avail_out === 0 ? vi : kn) : t.last_lit && ($e(t, !1), t.strm.avail_out === 0) ? Ae : rs;
    }
    a(SN, "deflate_rle");
    function xN(t, e) {
        for(var r;;){
            if (t.lookahead === 0 && (_i(t), t.lookahead === 0)) {
                if (e === Fi) return Ae;
                break;
            }
            if (t.match_length = 0, r = vt._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, r && ($e(t, !1), t.strm.avail_out === 0)) return Ae;
        }
        return t.insert = 0, e === qr ? ($e(t, !0), t.strm.avail_out === 0 ? vi : kn) : t.last_lit && ($e(t, !1), t.strm.avail_out === 0) ? Ae : rs;
    }
    a(xN, "deflate_huff");
    function Jt(t, e, r, i, n) {
        this.good_length = t, this.max_lazy = e, this.nice_length = r, this.max_chain = i, this.func = n;
    }
    a(Jt, "Config");
    var Rn;
    Rn = [
        new Jt(0, 0, 0, 0, EN),
        new Jt(4, 4, 8, 4, kd),
        new Jt(4, 5, 16, 8, kd),
        new Jt(4, 6, 32, 32, kd),
        new Jt(4, 4, 16, 16, On),
        new Jt(8, 16, 32, 32, On),
        new Jt(8, 16, 128, 128, On),
        new Jt(8, 32, 128, 256, On),
        new Jt(32, 128, 258, 1024, On),
        new Jt(32, 258, 258, 4096, On)
    ];
    function TN(t) {
        t.window_size = 2 * t.w_size, Mr(t.head), t.max_lazy_match = Rn[t.level].max_lazy, t.good_match = Rn[t.level].good_length, t.nice_match = Rn[t.level].nice_length, t.max_chain_length = Rn[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = Q - 1, t.match_available = 0, t.ins_h = 0;
    }
    a(TN, "lm_init");
    function ON() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Wl, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Ke.Buf16(gN * 2), this.dyn_dtree = new Ke.Buf16((2 * yN + 1) * 2), this.bl_tree = new Ke.Buf16((2 * wN + 1) * 2), Mr(this.dyn_ltree), Mr(this.dyn_dtree), Mr(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Ke.Buf16(bN + 1), this.heap = new Ke.Buf16(2 * Pd + 1), Mr(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Ke.Buf16(2 * Pd + 1), Mr(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
    }
    a(ON, "DeflateState");
    function O_(t) {
        var e;
        return !t || !t.state ? Ur(t, _t) : (t.total_in = t.total_out = 0, t.data_type = fN, e = t.state, e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? Vl : bi, t.adler = e.wrap === 2 ? 0 : 1, e.last_flush = Fi, vt._tr_init(e), Qt);
    }
    a(O_, "deflateResetKeep");
    function R_(t) {
        var e = O_(t);
        return e === Qt && TN(t.state), e;
    }
    a(R_, "deflateReset");
    function RN(t, e) {
        return !t || !t.state || t.state.wrap !== 2 ? _t : (t.state.gzhead = e, Qt);
    }
    a(RN, "deflateSetHeader");
    function k_(t, e, r, i, n, o) {
        if (!t) return _t;
        var s = 1;
        if (e === oN && (e = 6), i < 0 ? (s = 0, i = -i) : i > 15 && (s = 2, i -= 16), n < 1 || n > uN || r !== Wl || i < 8 || i > 15 || e < 0 || e > 9 || o < 0 || o > lN) return Ur(t, _t);
        i === 8 && (i = 9);
        var l = new ON;
        return t.state = l, l.strm = t, l.wrap = s, l.gzhead = null, l.w_bits = i, l.w_size = 1 << l.w_bits, l.w_mask = l.w_size - 1, l.hash_bits = n + 7, l.hash_size = 1 << l.hash_bits, l.hash_mask = l.hash_size - 1, l.hash_shift = ~~((l.hash_bits + Q - 1) / Q), l.window = new Ke.Buf8(l.w_size * 2), l.head = new Ke.Buf16(l.hash_size), l.prev = new Ke.Buf16(l.w_size), l.lit_bufsize = 1 << n + 6, l.pending_buf_size = l.lit_bufsize * 4, l.pending_buf = new Ke.Buf8(l.pending_buf_size), l.d_buf = 1 * l.lit_bufsize, l.l_buf = 3 * l.lit_bufsize, l.level = e, l.strategy = o, l.method = r, R_(t);
    }
    a(k_, "deflateInit2");
    function kN(t, e) {
        return k_(t, e, Wl, hN, dN, cN);
    }
    a(kN, "deflateInit");
    function PN(t, e) {
        var r, i, n, o;
        if (!t || !t.state || e > F_ || e < 0) return t ? Ur(t, _t) : _t;
        if (i = t.state, !t.output || !t.input && t.avail_in !== 0 || i.status === ts && e !== qr) return Ur(t, t.avail_out === 0 ? Rd : _t);
        if (i.strm = t, r = i.last_flush, i.last_flush = e, i.status === Vl) if (i.wrap === 2) t.adler = 0, oe(i, 31), oe(i, 139), oe(i, 8), i.gzhead ? (oe(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)), oe(i, i.gzhead.time & 255), oe(i, i.gzhead.time >> 8 & 255), oe(i, i.gzhead.time >> 16 & 255), oe(i, i.gzhead.time >> 24 & 255), oe(i, i.level === 9 ? 2 : i.strategy >= Ul || i.level < 2 ? 4 : 0), oe(i, i.gzhead.os & 255), i.gzhead.extra && i.gzhead.extra.length && (oe(i, i.gzhead.extra.length & 255), oe(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (t.adler = Lr(t.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = Ad) : (oe(i, 0), oe(i, 0), oe(i, 0), oe(i, 0), oe(i, 0), oe(i, i.level === 9 ? 2 : i.strategy >= Ul || i.level < 2 ? 4 : 0), oe(i, _N), i.status = bi);
        else {
            var s = Wl + (i.w_bits - 8 << 4) << 8, l = -1;
            i.strategy >= Ul || i.level < 2 ? l = 0 : i.level < 6 ? l = 1 : i.level === 6 ? l = 2 : l = 3, s |= l << 6, i.strstart !== 0 && (s |= vN), s += 31 - s % 31, i.status = bi, es(i, s), i.strstart !== 0 && (es(i, t.adler >>> 16), es(i, t.adler & 65535)), t.adler = 1;
        }
        if (i.status === Ad) if (i.gzhead.extra) {
            for(n = i.pending; i.gzindex < (i.gzhead.extra.length & 65535) && !(i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > n && (t.adler = Lr(t.adler, i.pending_buf, i.pending - n, n)), $r(t), n = i.pending, i.pending === i.pending_buf_size));)oe(i, i.gzhead.extra[i.gzindex] & 255), i.gzindex++;
            i.gzhead.hcrc && i.pending > n && (t.adler = Lr(t.adler, i.pending_buf, i.pending - n, n)), i.gzindex === i.gzhead.extra.length && (i.gzindex = 0, i.status = ql);
        } else i.status = ql;
        if (i.status === ql) if (i.gzhead.name) {
            n = i.pending;
            do {
                if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > n && (t.adler = Lr(t.adler, i.pending_buf, i.pending - n, n)), $r(t), n = i.pending, i.pending === i.pending_buf_size)) {
                    o = 1;
                    break;
                }
                i.gzindex < i.gzhead.name.length ? o = i.gzhead.name.charCodeAt(i.gzindex++) & 255 : o = 0, oe(i, o);
            }while (o !== 0)
            i.gzhead.hcrc && i.pending > n && (t.adler = Lr(t.adler, i.pending_buf, i.pending - n, n)), o === 0 && (i.gzindex = 0, i.status = Hl);
        } else i.status = Hl;
        if (i.status === Hl) if (i.gzhead.comment) {
            n = i.pending;
            do {
                if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > n && (t.adler = Lr(t.adler, i.pending_buf, i.pending - n, n)), $r(t), n = i.pending, i.pending === i.pending_buf_size)) {
                    o = 1;
                    break;
                }
                i.gzindex < i.gzhead.comment.length ? o = i.gzhead.comment.charCodeAt(i.gzindex++) & 255 : o = 0, oe(i, o);
            }while (o !== 0)
            i.gzhead.hcrc && i.pending > n && (t.adler = Lr(t.adler, i.pending_buf, i.pending - n, n)), o === 0 && (i.status = zl);
        } else i.status = zl;
        if (i.status === zl && (i.gzhead.hcrc ? (i.pending + 2 > i.pending_buf_size && $r(t), i.pending + 2 <= i.pending_buf_size && (oe(i, t.adler & 255), oe(i, t.adler >> 8 & 255), t.adler = 0, i.status = bi)) : i.status = bi), i.pending !== 0) {
            if ($r(t), t.avail_out === 0) return i.last_flush = -1, Qt;
        } else if (t.avail_in === 0 && S_(e) <= S_(r) && e !== qr) return Ur(t, Rd);
        if (i.status === ts && t.avail_in !== 0) return Ur(t, Rd);
        if (t.avail_in !== 0 || i.lookahead !== 0 || e !== Fi && i.status !== ts) {
            var f = i.strategy === Ul ? xN(i, e) : i.strategy === aN ? SN(i, e) : Rn[i.level].func(i, e);
            if ((f === vi || f === kn) && (i.status = ts), f === Ae || f === vi) return t.avail_out === 0 && (i.last_flush = -1), Qt;
            if (f === rs && (e === rN ? vt._tr_align(i) : e !== F_ && (vt._tr_stored_block(i, 0, 0, !1), e === iN && (Mr(i.head), i.lookahead === 0 && (i.strstart = 0, i.block_start = 0, i.insert = 0))), $r(t), t.avail_out === 0)) return i.last_flush = -1, Qt;
        }
        return e !== qr ? Qt : i.wrap <= 0 ? E_ : (i.wrap === 2 ? (oe(i, t.adler & 255), oe(i, t.adler >> 8 & 255), oe(i, t.adler >> 16 & 255), oe(i, t.adler >> 24 & 255), oe(i, t.total_in & 255), oe(i, t.total_in >> 8 & 255), oe(i, t.total_in >> 16 & 255), oe(i, t.total_in >> 24 & 255)) : (es(i, t.adler >>> 16), es(i, t.adler & 65535)), $r(t), i.wrap > 0 && (i.wrap = -i.wrap), i.pending !== 0 ? Qt : E_);
    }
    a(PN, "deflate");
    function AN(t) {
        var e;
        return !t || !t.state ? _t : (e = t.state.status, e !== Vl && e !== Ad && e !== ql && e !== Hl && e !== zl && e !== bi && e !== ts ? Ur(t, _t) : (t.state = null, e === bi ? Ur(t, nN) : Qt));
    }
    a(AN, "deflateEnd");
    function IN(t, e) {
        var r = e.length, i, n, o, s, l, f, c, u;
        if (!t || !t.state || (i = t.state, s = i.wrap, s === 2 || s === 1 && i.status !== Vl || i.lookahead)) return _t;
        for(s === 1 && (t.adler = x_(t.adler, e, r, 0)), i.wrap = 0, r >= i.w_size && (s === 0 && (Mr(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0), u = new Ke.Buf8(i.w_size), Ke.arraySet(u, e, r - i.w_size, i.w_size, 0), e = u, r = i.w_size), l = t.avail_in, f = t.next_in, c = t.input, t.avail_in = r, t.next_in = 0, t.input = e, _i(i); i.lookahead >= Q;){
            n = i.strstart, o = i.lookahead - (Q - 1);
            do i.ins_h = (i.ins_h << i.hash_shift ^ i.window[n + Q - 1]) & i.hash_mask, i.prev[n & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = n, n++;
            while (--o)
            i.strstart = n, i.lookahead = Q - 1, _i(i);
        }
        return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = Q - 1, i.match_available = 0, t.next_in = f, t.input = c, t.avail_in = l, i.wrap = s, Qt;
    }
    a(IN, "deflateSetDictionary");
    er.deflateInit = kN;
    er.deflateInit2 = k_;
    er.deflateReset = R_;
    er.deflateResetKeep = O_;
    er.deflateSetHeader = RN;
    er.deflate = PN;
    er.deflateEnd = AN;
    er.deflateSetDictionary = IN;
    er.deflateInfo = "pako deflate (from Nodeca project)";
});
_c153 = P_;
var Id = T(_c154 = (Pn)=>{
    "use strict";
    var Gl = hr(), A_ = !0, I_ = !0;
    try {
        String.fromCharCode.apply(null, [
            0
        ]);
    } catch (e) {
        A_ = !1;
    }
    try {
        String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (e) {
        I_ = !1;
    }
    var is = new Gl.Buf8(256);
    for(pr = 0; pr < 256; pr++)is[pr] = pr >= 252 ? 6 : pr >= 248 ? 5 : pr >= 240 ? 4 : pr >= 224 ? 3 : pr >= 192 ? 2 : 1;
    var pr;
    is[254] = is[254] = 1;
    Pn.string2buf = function(t) {
        var e, r, i, n, o, s = t.length, l = 0;
        for(n = 0; n < s; n++)r = t.charCodeAt(n), (r & 64512) === 55296 && n + 1 < s && (i = t.charCodeAt(n + 1), (i & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (i - 56320), n++)), l += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
        for(e = new Gl.Buf8(l), o = 0, n = 0; o < l; n++)r = t.charCodeAt(n), (r & 64512) === 55296 && n + 1 < s && (i = t.charCodeAt(n + 1), (i & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (i - 56320), n++)), r < 128 ? e[o++] = r : r < 2048 ? (e[o++] = 192 | r >>> 6, e[o++] = 128 | r & 63) : r < 65536 ? (e[o++] = 224 | r >>> 12, e[o++] = 128 | r >>> 6 & 63, e[o++] = 128 | r & 63) : (e[o++] = 240 | r >>> 18, e[o++] = 128 | r >>> 12 & 63, e[o++] = 128 | r >>> 6 & 63, e[o++] = 128 | r & 63);
        return e;
    };
    function D_(t, e) {
        if (e < 65534 && (t.subarray && I_ || !t.subarray && A_)) return String.fromCharCode.apply(null, Gl.shrinkBuf(t, e));
        for(var r = "", i = 0; i < e; i++)r += String.fromCharCode(t[i]);
        return r;
    }
    a(D_, "buf2binstring");
    Pn.buf2binstring = function(t) {
        return D_(t, t.length);
    };
    Pn.binstring2buf = function(t) {
        for(var e = new Gl.Buf8(t.length), r = 0, i = e.length; r < i; r++)e[r] = t.charCodeAt(r);
        return e;
    };
    Pn.buf2string = function(t, e) {
        var r, i, n, o, s = e || t.length, l = new Array(s * 2);
        for(i = 0, r = 0; r < s;){
            if (n = t[r++], n < 128) {
                l[i++] = n;
                continue;
            }
            if (o = is[n], o > 4) {
                l[i++] = 65533, r += o - 1;
                continue;
            }
            for(n &= o === 2 ? 31 : o === 3 ? 15 : 7; o > 1 && r < s;)n = n << 6 | t[r++] & 63, o--;
            if (o > 1) {
                l[i++] = 65533;
                continue;
            }
            n < 65536 ? l[i++] = n : (n -= 65536, l[i++] = 55296 | n >> 10 & 1023, l[i++] = 56320 | n & 1023);
        }
        return D_(l, i);
    };
    Pn.utf8border = function(t, e) {
        var r;
        for(e = e || t.length, e > t.length && (e = t.length), r = e - 1; r >= 0 && (t[r] & 192) === 128;)r--;
        return r < 0 || r === 0 ? e : r + is[t[r]] > e ? r : e;
    };
});
_c155 = Id;
var Dd = T(_c156 = (CU, C_)=>{
    "use strict";
    function DN() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
    }
    a(DN, "ZStream");
    C_.exports = DN;
});
_c157 = Dd;
var $_ = T((ss)=>{
    "use strict";
    var ns = P_(), os = hr(), Nd = Id(), Bd = jl(), CN = Dd(), L_ = Object.prototype.toString, NN = 0, Cd = 4, An = 0, N_ = 1, B_ = 2, BN = -1, LN = 0, $N = 8;
    function Ei(t) {
        if (!(this instanceof Ei)) return new Ei(t);
        this.options = os.assign({
            level: BN,
            method: $N,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: LN,
            to: ""
        }, t || {});
        var e = this.options;
        e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new CN, this.strm.avail_out = 0;
        var r = ns.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
        if (r !== An) throw new Error(Bd[r]);
        if (e.header && ns.deflateSetHeader(this.strm, e.header), e.dictionary) {
            var i;
            if (typeof e.dictionary == "string" ? i = Nd.string2buf(e.dictionary) : L_.call(e.dictionary) === "[object ArrayBuffer]" ? i = new Uint8Array(e.dictionary) : i = e.dictionary, r = ns.deflateSetDictionary(this.strm, i), r !== An) throw new Error(Bd[r]);
            this._dict_set = !0;
        }
    }
    a(Ei, "Deflate");
    Ei.prototype.push = function(t, e) {
        var r = this.strm, i = this.options.chunkSize, n, o;
        if (this.ended) return !1;
        o = e === ~~e ? e : e === !0 ? Cd : NN, typeof t == "string" ? r.input = Nd.string2buf(t) : L_.call(t) === "[object ArrayBuffer]" ? r.input = new Uint8Array(t) : r.input = t, r.next_in = 0, r.avail_in = r.input.length;
        do {
            if (r.avail_out === 0 && (r.output = new os.Buf8(i), r.next_out = 0, r.avail_out = i), n = ns.deflate(r, o), n !== N_ && n !== An) return this.onEnd(n), this.ended = !0, !1;
            (r.avail_out === 0 || r.avail_in === 0 && (o === Cd || o === B_)) && (this.options.to === "string" ? this.onData(Nd.buf2binstring(os.shrinkBuf(r.output, r.next_out))) : this.onData(os.shrinkBuf(r.output, r.next_out)));
        }while ((r.avail_in > 0 || r.avail_out === 0) && n !== N_)
        return o === Cd ? (n = ns.deflateEnd(this.strm), this.onEnd(n), this.ended = !0, n === An) : (o === B_ && (this.onEnd(An), r.avail_out = 0), !0);
    };
    Ei.prototype.onData = function(t) {
        this.chunks.push(t);
    };
    Ei.prototype.onEnd = function(t) {
        t === An && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = os.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
    };
    function Ld(t, e) {
        var r = new Ei(e);
        if (r.push(t, !0), r.err) throw r.msg || Bd[r.err];
        return r.result;
    }
    a(Ld, "deflate");
    function MN(t, e) {
        return e = e || {}, e.raw = !0, Ld(t, e);
    }
    a(MN, "deflateRaw");
    function jN(t, e) {
        return e = e || {}, e.gzip = !0, Ld(t, e);
    }
    a(jN, "gzip");
    ss.Deflate = Ei;
    ss.deflate = Ld;
    ss.deflateRaw = MN;
    ss.gzip = jN;
});
var j_ = T(($U, M_)=>{
    "use strict";
    var Kl = 30, UN = 12;
    M_.exports = a(function(e, r) {
        var i, n, o, s, l, f, c, u, h, d, p, m, y, w, v, g, F, O, S, R, b, x, _, P, k;
        i = e.state, n = e.next_in, P = e.input, o = n + (e.avail_in - 5), s = e.next_out, k = e.output, l = s - (r - e.avail_out), f = s + (e.avail_out - 257), c = i.dmax, u = i.wsize, h = i.whave, d = i.wnext, p = i.window, m = i.hold, y = i.bits, w = i.lencode, v = i.distcode, g = (1 << i.lenbits) - 1, F = (1 << i.distbits) - 1;
        e: do {
            y < 15 && (m += P[n++] << y, y += 8, m += P[n++] << y, y += 8), O = w[m & g];
            t: for(;;){
                if (S = O >>> 24, m >>>= S, y -= S, S = O >>> 16 & 255, S === 0) k[s++] = O & 65535;
                else if (S & 16) {
                    R = O & 65535, S &= 15, S && (y < S && (m += P[n++] << y, y += 8), R += m & (1 << S) - 1, m >>>= S, y -= S), y < 15 && (m += P[n++] << y, y += 8, m += P[n++] << y, y += 8), O = v[m & F];
                    r: for(;;){
                        if (S = O >>> 24, m >>>= S, y -= S, S = O >>> 16 & 255, S & 16) {
                            if (b = O & 65535, S &= 15, y < S && (m += P[n++] << y, y += 8, y < S && (m += P[n++] << y, y += 8)), b += m & (1 << S) - 1, b > c) {
                                e.msg = "invalid distance too far back", i.mode = Kl;
                                break e;
                            }
                            if (m >>>= S, y -= S, S = s - l, b > S) {
                                if (S = b - S, S > h && i.sane) {
                                    e.msg = "invalid distance too far back", i.mode = Kl;
                                    break e;
                                }
                                if (x = 0, _ = p, d === 0) {
                                    if (x += u - S, S < R) {
                                        R -= S;
                                        do k[s++] = p[x++];
                                        while (--S)
                                        x = s - b, _ = k;
                                    }
                                } else if (d < S) {
                                    if (x += u + d - S, S -= d, S < R) {
                                        R -= S;
                                        do k[s++] = p[x++];
                                        while (--S)
                                        if (x = 0, d < R) {
                                            S = d, R -= S;
                                            do k[s++] = p[x++];
                                            while (--S)
                                            x = s - b, _ = k;
                                        }
                                    }
                                } else if (x += d - S, S < R) {
                                    R -= S;
                                    do k[s++] = p[x++];
                                    while (--S)
                                    x = s - b, _ = k;
                                }
                                for(; R > 2;)k[s++] = _[x++], k[s++] = _[x++], k[s++] = _[x++], R -= 3;
                                R && (k[s++] = _[x++], R > 1 && (k[s++] = _[x++]));
                            } else {
                                x = s - b;
                                do k[s++] = k[x++], k[s++] = k[x++], k[s++] = k[x++], R -= 3;
                                while (R > 2)
                                R && (k[s++] = k[x++], R > 1 && (k[s++] = k[x++]));
                            }
                        } else if (S & 64) {
                            e.msg = "invalid distance code", i.mode = Kl;
                            break e;
                        } else {
                            O = v[(O & 65535) + (m & (1 << S) - 1)];
                            continue r;
                        }
                        break;
                    }
                } else if (S & 64) if (S & 32) {
                    i.mode = UN;
                    break e;
                } else {
                    e.msg = "invalid literal/length code", i.mode = Kl;
                    break e;
                }
                else {
                    O = w[(O & 65535) + (m & (1 << S) - 1)];
                    continue t;
                }
                break;
            }
        }while (n < o && s < f)
        R = y >> 3, n -= R, y -= R << 3, m &= (1 << y) - 1, e.next_in = n, e.next_out = s, e.avail_in = n < o ? 5 + (o - n) : 5 - (n - o), e.avail_out = s < f ? 257 + (f - s) : 257 - (s - f), i.hold = m, i.bits = y;
    }, "inflate_fast");
});
var G_ = T(_c158 = (jU, V_)=>{
    "use strict";
    var U_ = hr(), In = 15, q_ = 852, H_ = 592, z_ = 0, $d = 1, W_ = 2, qN = [
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
    ], HN = [
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
    ], zN = [
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
    ], WN = [
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
    ];
    V_.exports = a(function(e, r, i, n, o, s, l, f) {
        var c = f.bits, u = 0, h = 0, d = 0, p = 0, m = 0, y = 0, w = 0, v = 0, g = 0, F = 0, O, S, R, b, x, _ = null, P = 0, k, C = new U_.Buf16(In + 1), N = new U_.Buf16(In + 1), U = null, Z = 0, me, Ee, $;
        for(u = 0; u <= In; u++)C[u] = 0;
        for(h = 0; h < n; h++)C[r[i + h]]++;
        for(m = c, p = In; p >= 1 && C[p] === 0; p--);
        if (m > p && (m = p), p === 0) return o[s++] = 1 << 24 | 64 << 16 | 0, o[s++] = 1 << 24 | 64 << 16 | 0, f.bits = 1, 0;
        for(d = 1; d < p && C[d] === 0; d++);
        for(m < d && (m = d), v = 1, u = 1; u <= In; u++)if (v <<= 1, v -= C[u], v < 0) return -1;
        if (v > 0 && (e === z_ || p !== 1)) return -1;
        for(N[1] = 0, u = 1; u < In; u++)N[u + 1] = N[u] + C[u];
        for(h = 0; h < n; h++)r[i + h] !== 0 && (l[N[r[i + h]]++] = h);
        if (e === z_ ? (_ = U = l, k = 19) : e === $d ? (_ = qN, P -= 257, U = HN, Z -= 257, k = 256) : (_ = zN, U = WN, k = -1), F = 0, h = 0, u = d, x = s, y = m, w = 0, R = -1, g = 1 << m, b = g - 1, e === $d && g > q_ || e === W_ && g > H_) return 1;
        for(;;){
            me = u - w, l[h] < k ? (Ee = 0, $ = l[h]) : l[h] > k ? (Ee = U[Z + l[h]], $ = _[P + l[h]]) : (Ee = 96, $ = 0), O = 1 << u - w, S = 1 << y, d = S;
            do S -= O, o[x + (F >> w) + S] = me << 24 | Ee << 16 | $ | 0;
            while (S !== 0)
            for(O = 1 << u - 1; F & O;)O >>= 1;
            if (O !== 0 ? (F &= O - 1, F += O) : F = 0, h++, --C[u] === 0) {
                if (u === p) break;
                u = r[i + l[h]];
            }
            if (u > m && (F & b) !== R) {
                for(w === 0 && (w = m), x += d, y = u - w, v = 1 << y; y + w < p && (v -= C[y + w], !(v <= 0));)y++, v <<= 1;
                if (g += 1 << y, e === $d && g > q_ || e === W_ && g > H_) return 1;
                R = F & b, o[R] = m << 24 | y << 16 | x - s | 0;
            }
        }
        return F !== 0 && (o[x + F] = u - w << 24 | 64 << 16 | 0), f.bits = m, 0;
    }, "inflate_table");
});
_c159 = G_;
var RF = T(_c160 = (Dt)=>{
    "use strict";
    var lt = hr(), zd = Td(), tr = Od(), VN = j_(), as = G_(), GN = 0, bF = 1, vF = 2, K_ = 4, KN = 5, Zl = 6, Si = 0, ZN = 1, XN = 2, Ft = -2, _F = -3, Wd = -4, YN = -5, Z_ = 8, FF = 1, X_ = 2, Y_ = 3, J_ = 4, Q_ = 5, eF = 6, tF = 7, rF = 8, iF = 9, nF = 10, Jl = 11, mr = 12, Md = 13, oF = 14, jd = 15, sF = 16, aF = 17, lF = 18, cF = 19, Xl = 20, Yl = 21, fF = 22, uF = 23, hF = 24, dF = 25, pF = 26, Ud = 27, mF = 28, yF = 29, pe = 30, Vd = 31, JN = 32, QN = 852, eB = 592, tB = 15, rB = tB;
    function wF(t) {
        return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((t & 65280) << 8) + ((t & 255) << 24);
    }
    a(wF, "zswap32");
    function iB() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new lt.Buf16(320), this.work = new lt.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
    }
    a(iB, "InflateState");
    function EF(t) {
        var e;
        return !t || !t.state ? Ft : (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = e.wrap & 1), e.mode = FF, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new lt.Buf32(QN), e.distcode = e.distdyn = new lt.Buf32(eB), e.sane = 1, e.back = -1, Si);
    }
    a(EF, "inflateResetKeep");
    function SF(t) {
        var e;
        return !t || !t.state ? Ft : (e = t.state, e.wsize = 0, e.whave = 0, e.wnext = 0, EF(t));
    }
    a(SF, "inflateReset");
    function xF(t, e) {
        var r, i;
        return !t || !t.state || (i = t.state, e < 0 ? (r = 0, e = -e) : (r = (e >> 4) + 1, e < 48 && (e &= 15)), e && (e < 8 || e > 15)) ? Ft : (i.window !== null && i.wbits !== e && (i.window = null), i.wrap = r, i.wbits = e, SF(t));
    }
    a(xF, "inflateReset2");
    function TF(t, e) {
        var r, i;
        return t ? (i = new iB, t.state = i, i.window = null, r = xF(t, e), r !== Si && (t.state = null), r) : Ft;
    }
    a(TF, "inflateInit2");
    function nB(t) {
        return TF(t, rB);
    }
    a(nB, "inflateInit");
    var gF = !0, qd, Hd;
    function oB(t) {
        if (gF) {
            var e;
            for(qd = new lt.Buf32(512), Hd = new lt.Buf32(32), e = 0; e < 144;)t.lens[e++] = 8;
            for(; e < 256;)t.lens[e++] = 9;
            for(; e < 280;)t.lens[e++] = 7;
            for(; e < 288;)t.lens[e++] = 8;
            for(as(bF, t.lens, 0, 288, qd, 0, t.work, {
                bits: 9
            }), e = 0; e < 32;)t.lens[e++] = 5;
            as(vF, t.lens, 0, 32, Hd, 0, t.work, {
                bits: 5
            }), gF = !1;
        }
        t.lencode = qd, t.lenbits = 9, t.distcode = Hd, t.distbits = 5;
    }
    a(oB, "fixedtables");
    function OF(t, e, r, i) {
        var n, o = t.state;
        return o.window === null && (o.wsize = 1 << o.wbits, o.wnext = 0, o.whave = 0, o.window = new lt.Buf8(o.wsize)), i >= o.wsize ? (lt.arraySet(o.window, e, r - o.wsize, o.wsize, 0), o.wnext = 0, o.whave = o.wsize) : (n = o.wsize - o.wnext, n > i && (n = i), lt.arraySet(o.window, e, r - i, n, o.wnext), i -= n, i ? (lt.arraySet(o.window, e, r - i, i, 0), o.wnext = i, o.whave = o.wsize) : (o.wnext += n, o.wnext === o.wsize && (o.wnext = 0), o.whave < o.wsize && (o.whave += n))), 0;
    }
    a(OF, "updatewindow");
    function sB(t, e) {
        var r, i, n, o, s, l, f, c, u, h, d, p, m, y, w = 0, v, g, F, O, S, R, b, x, _ = new lt.Buf8(4), P, k, C = [
            16,
            17,
            18,
            0,
            8,
            7,
            9,
            6,
            10,
            5,
            11,
            4,
            12,
            3,
            13,
            2,
            14,
            1,
            15
        ];
        if (!t || !t.state || !t.output || !t.input && t.avail_in !== 0) return Ft;
        r = t.state, r.mode === mr && (r.mode = Md), s = t.next_out, n = t.output, f = t.avail_out, o = t.next_in, i = t.input, l = t.avail_in, c = r.hold, u = r.bits, h = l, d = f, x = Si;
        e: for(;;)switch(r.mode){
            case FF:
                if (r.wrap === 0) {
                    r.mode = Md;
                    break;
                }
                for(; u < 16;){
                    if (l === 0) break e;
                    l--, c += i[o++] << u, u += 8;
                }
                if (r.wrap & 2 && c === 35615) {
                    r.check = 0, _[0] = c & 255, _[1] = c >>> 8 & 255, r.check = tr(r.check, _, 2, 0), c = 0, u = 0, r.mode = X_;
                    break;
                }
                if (r.flags = 0, r.head && (r.head.done = !1), !(r.wrap & 1) || (((c & 255) << 8) + (c >> 8)) % 31) {
                    t.msg = "incorrect header check", r.mode = pe;
                    break;
                }
                if ((c & 15) !== Z_) {
                    t.msg = "unknown compression method", r.mode = pe;
                    break;
                }
                if (c >>>= 4, u -= 4, b = (c & 15) + 8, r.wbits === 0) r.wbits = b;
                else if (b > r.wbits) {
                    t.msg = "invalid window size", r.mode = pe;
                    break;
                }
                r.dmax = 1 << b, t.adler = r.check = 1, r.mode = c & 512 ? nF : mr, c = 0, u = 0;
                break;
            case X_:
                for(; u < 16;){
                    if (l === 0) break e;
                    l--, c += i[o++] << u, u += 8;
                }
                if (r.flags = c, (r.flags & 255) !== Z_) {
                    t.msg = "unknown compression method", r.mode = pe;
                    break;
                }
                if (r.flags & 57344) {
                    t.msg = "unknown header flags set", r.mode = pe;
                    break;
                }
                r.head && (r.head.text = c >> 8 & 1), r.flags & 512 && (_[0] = c & 255, _[1] = c >>> 8 & 255, r.check = tr(r.check, _, 2, 0)), c = 0, u = 0, r.mode = Y_;
            case Y_:
                for(; u < 32;){
                    if (l === 0) break e;
                    l--, c += i[o++] << u, u += 8;
                }
                r.head && (r.head.time = c), r.flags & 512 && (_[0] = c & 255, _[1] = c >>> 8 & 255, _[2] = c >>> 16 & 255, _[3] = c >>> 24 & 255, r.check = tr(r.check, _, 4, 0)), c = 0, u = 0, r.mode = J_;
            case J_:
                for(; u < 16;){
                    if (l === 0) break e;
                    l--, c += i[o++] << u, u += 8;
                }
                r.head && (r.head.xflags = c & 255, r.head.os = c >> 8), r.flags & 512 && (_[0] = c & 255, _[1] = c >>> 8 & 255, r.check = tr(r.check, _, 2, 0)), c = 0, u = 0, r.mode = Q_;
            case Q_:
                if (r.flags & 1024) {
                    for(; u < 16;){
                        if (l === 0) break e;
                        l--, c += i[o++] << u, u += 8;
                    }
                    r.length = c, r.head && (r.head.extra_len = c), r.flags & 512 && (_[0] = c & 255, _[1] = c >>> 8 & 255, r.check = tr(r.check, _, 2, 0)), c = 0, u = 0;
                } else r.head && (r.head.extra = null);
                r.mode = eF;
            case eF:
                if (r.flags & 1024 && (p = r.length, p > l && (p = l), p && (r.head && (b = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Array(r.head.extra_len)), lt.arraySet(r.head.extra, i, o, p, b)), r.flags & 512 && (r.check = tr(r.check, i, p, o)), l -= p, o += p, r.length -= p), r.length)) break e;
                r.length = 0, r.mode = tF;
            case tF:
                if (r.flags & 2048) {
                    if (l === 0) break e;
                    p = 0;
                    do b = i[o + p++], r.head && b && r.length < 65536 && (r.head.name += String.fromCharCode(b));
                    while (b && p < l)
                    if (r.flags & 512 && (r.check = tr(r.check, i, p, o)), l -= p, o += p, b) break e;
                } else r.head && (r.head.name = null);
                r.length = 0, r.mode = rF;
            case rF:
                if (r.flags & 4096) {
                    if (l === 0) break e;
                    p = 0;
                    do b = i[o + p++], r.head && b && r.length < 65536 && (r.head.comment += String.fromCharCode(b));
                    while (b && p < l)
                    if (r.flags & 512 && (r.check = tr(r.check, i, p, o)), l -= p, o += p, b) break e;
                } else r.head && (r.head.comment = null);
                r.mode = iF;
            case iF:
                if (r.flags & 512) {
                    for(; u < 16;){
                        if (l === 0) break e;
                        l--, c += i[o++] << u, u += 8;
                    }
                    if (c !== (r.check & 65535)) {
                        t.msg = "header crc mismatch", r.mode = pe;
                        break;
                    }
                    c = 0, u = 0;
                }
                r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), t.adler = r.check = 0, r.mode = mr;
                break;
            case nF:
                for(; u < 32;){
                    if (l === 0) break e;
                    l--, c += i[o++] << u, u += 8;
                }
                t.adler = r.check = wF(c), c = 0, u = 0, r.mode = Jl;
            case Jl:
                if (r.havedict === 0) return t.next_out = s, t.avail_out = f, t.next_in = o, t.avail_in = l, r.hold = c, r.bits = u, XN;
                t.adler = r.check = 1, r.mode = mr;
            case mr:
                if (e === KN || e === Zl) break e;
            case Md:
                if (r.last) {
                    c >>>= u & 7, u -= u & 7, r.mode = Ud;
                    break;
                }
                for(; u < 3;){
                    if (l === 0) break e;
                    l--, c += i[o++] << u, u += 8;
                }
                switch(r.last = c & 1, c >>>= 1, u -= 1, c & 3){
                    case 0:
                        r.mode = oF;
                        break;
                    case 1:
                        if (oB(r), r.mode = Xl, e === Zl) {
                            c >>>= 2, u -= 2;
                            break e;
                        }
                        break;
                    case 2:
                        r.mode = aF;
                        break;
                    case 3:
                        t.msg = "invalid block type", r.mode = pe;
                }
                c >>>= 2, u -= 2;
                break;
            case oF:
                for(c >>>= u & 7, u -= u & 7; u < 32;){
                    if (l === 0) break e;
                    l--, c += i[o++] << u, u += 8;
                }
                if ((c & 65535) !== (c >>> 16 ^ 65535)) {
                    t.msg = "invalid stored block lengths", r.mode = pe;
                    break;
                }
                if (r.length = c & 65535, c = 0, u = 0, r.mode = jd, e === Zl) break e;
            case jd:
                r.mode = sF;
            case sF:
                if (p = r.length, p) {
                    if (p > l && (p = l), p > f && (p = f), p === 0) break e;
                    lt.arraySet(n, i, o, p, s), l -= p, o += p, f -= p, s += p, r.length -= p;
                    break;
                }
                r.mode = mr;
                break;
            case aF:
                for(; u < 14;){
                    if (l === 0) break e;
                    l--, c += i[o++] << u, u += 8;
                }
                if (r.nlen = (c & 31) + 257, c >>>= 5, u -= 5, r.ndist = (c & 31) + 1, c >>>= 5, u -= 5, r.ncode = (c & 15) + 4, c >>>= 4, u -= 4, r.nlen > 286 || r.ndist > 30) {
                    t.msg = "too many length or distance symbols", r.mode = pe;
                    break;
                }
                r.have = 0, r.mode = lF;
            case lF:
                for(; r.have < r.ncode;){
                    for(; u < 3;){
                        if (l === 0) break e;
                        l--, c += i[o++] << u, u += 8;
                    }
                    r.lens[C[r.have++]] = c & 7, c >>>= 3, u -= 3;
                }
                for(; r.have < 19;)r.lens[C[r.have++]] = 0;
                if (r.lencode = r.lendyn, r.lenbits = 7, P = {
                    bits: r.lenbits
                }, x = as(GN, r.lens, 0, 19, r.lencode, 0, r.work, P), r.lenbits = P.bits, x) {
                    t.msg = "invalid code lengths set", r.mode = pe;
                    break;
                }
                r.have = 0, r.mode = cF;
            case cF:
                for(; r.have < r.nlen + r.ndist;){
                    for(; w = r.lencode[c & (1 << r.lenbits) - 1], v = w >>> 24, g = w >>> 16 & 255, F = w & 65535, !(v <= u);){
                        if (l === 0) break e;
                        l--, c += i[o++] << u, u += 8;
                    }
                    if (F < 16) c >>>= v, u -= v, r.lens[r.have++] = F;
                    else {
                        if (F === 16) {
                            for(k = v + 2; u < k;){
                                if (l === 0) break e;
                                l--, c += i[o++] << u, u += 8;
                            }
                            if (c >>>= v, u -= v, r.have === 0) {
                                t.msg = "invalid bit length repeat", r.mode = pe;
                                break;
                            }
                            b = r.lens[r.have - 1], p = 3 + (c & 3), c >>>= 2, u -= 2;
                        } else if (F === 17) {
                            for(k = v + 3; u < k;){
                                if (l === 0) break e;
                                l--, c += i[o++] << u, u += 8;
                            }
                            c >>>= v, u -= v, b = 0, p = 3 + (c & 7), c >>>= 3, u -= 3;
                        } else {
                            for(k = v + 7; u < k;){
                                if (l === 0) break e;
                                l--, c += i[o++] << u, u += 8;
                            }
                            c >>>= v, u -= v, b = 0, p = 11 + (c & 127), c >>>= 7, u -= 7;
                        }
                        if (r.have + p > r.nlen + r.ndist) {
                            t.msg = "invalid bit length repeat", r.mode = pe;
                            break;
                        }
                        for(; p--;)r.lens[r.have++] = b;
                    }
                }
                if (r.mode === pe) break;
                if (r.lens[256] === 0) {
                    t.msg = "invalid code -- missing end-of-block", r.mode = pe;
                    break;
                }
                if (r.lenbits = 9, P = {
                    bits: r.lenbits
                }, x = as(bF, r.lens, 0, r.nlen, r.lencode, 0, r.work, P), r.lenbits = P.bits, x) {
                    t.msg = "invalid literal/lengths set", r.mode = pe;
                    break;
                }
                if (r.distbits = 6, r.distcode = r.distdyn, P = {
                    bits: r.distbits
                }, x = as(vF, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, P), r.distbits = P.bits, x) {
                    t.msg = "invalid distances set", r.mode = pe;
                    break;
                }
                if (r.mode = Xl, e === Zl) break e;
            case Xl:
                r.mode = Yl;
            case Yl:
                if (l >= 6 && f >= 258) {
                    t.next_out = s, t.avail_out = f, t.next_in = o, t.avail_in = l, r.hold = c, r.bits = u, VN(t, d), s = t.next_out, n = t.output, f = t.avail_out, o = t.next_in, i = t.input, l = t.avail_in, c = r.hold, u = r.bits, r.mode === mr && (r.back = -1);
                    break;
                }
                for(r.back = 0; w = r.lencode[c & (1 << r.lenbits) - 1], v = w >>> 24, g = w >>> 16 & 255, F = w & 65535, !(v <= u);){
                    if (l === 0) break e;
                    l--, c += i[o++] << u, u += 8;
                }
                if (g && !(g & 240)) {
                    for(O = v, S = g, R = F; w = r.lencode[R + ((c & (1 << O + S) - 1) >> O)], v = w >>> 24, g = w >>> 16 & 255, F = w & 65535, !(O + v <= u);){
                        if (l === 0) break e;
                        l--, c += i[o++] << u, u += 8;
                    }
                    c >>>= O, u -= O, r.back += O;
                }
                if (c >>>= v, u -= v, r.back += v, r.length = F, g === 0) {
                    r.mode = pF;
                    break;
                }
                if (g & 32) {
                    r.back = -1, r.mode = mr;
                    break;
                }
                if (g & 64) {
                    t.msg = "invalid literal/length code", r.mode = pe;
                    break;
                }
                r.extra = g & 15, r.mode = fF;
            case fF:
                if (r.extra) {
                    for(k = r.extra; u < k;){
                        if (l === 0) break e;
                        l--, c += i[o++] << u, u += 8;
                    }
                    r.length += c & (1 << r.extra) - 1, c >>>= r.extra, u -= r.extra, r.back += r.extra;
                }
                r.was = r.length, r.mode = uF;
            case uF:
                for(; w = r.distcode[c & (1 << r.distbits) - 1], v = w >>> 24, g = w >>> 16 & 255, F = w & 65535, !(v <= u);){
                    if (l === 0) break e;
                    l--, c += i[o++] << u, u += 8;
                }
                if (!(g & 240)) {
                    for(O = v, S = g, R = F; w = r.distcode[R + ((c & (1 << O + S) - 1) >> O)], v = w >>> 24, g = w >>> 16 & 255, F = w & 65535, !(O + v <= u);){
                        if (l === 0) break e;
                        l--, c += i[o++] << u, u += 8;
                    }
                    c >>>= O, u -= O, r.back += O;
                }
                if (c >>>= v, u -= v, r.back += v, g & 64) {
                    t.msg = "invalid distance code", r.mode = pe;
                    break;
                }
                r.offset = F, r.extra = g & 15, r.mode = hF;
            case hF:
                if (r.extra) {
                    for(k = r.extra; u < k;){
                        if (l === 0) break e;
                        l--, c += i[o++] << u, u += 8;
                    }
                    r.offset += c & (1 << r.extra) - 1, c >>>= r.extra, u -= r.extra, r.back += r.extra;
                }
                if (r.offset > r.dmax) {
                    t.msg = "invalid distance too far back", r.mode = pe;
                    break;
                }
                r.mode = dF;
            case dF:
                if (f === 0) break e;
                if (p = d - f, r.offset > p) {
                    if (p = r.offset - p, p > r.whave && r.sane) {
                        t.msg = "invalid distance too far back", r.mode = pe;
                        break;
                    }
                    p > r.wnext ? (p -= r.wnext, m = r.wsize - p) : m = r.wnext - p, p > r.length && (p = r.length), y = r.window;
                } else y = n, m = s - r.offset, p = r.length;
                p > f && (p = f), f -= p, r.length -= p;
                do n[s++] = y[m++];
                while (--p)
                r.length === 0 && (r.mode = Yl);
                break;
            case pF:
                if (f === 0) break e;
                n[s++] = r.length, f--, r.mode = Yl;
                break;
            case Ud:
                if (r.wrap) {
                    for(; u < 32;){
                        if (l === 0) break e;
                        l--, c |= i[o++] << u, u += 8;
                    }
                    if (d -= f, t.total_out += d, r.total += d, d && (t.adler = r.check = r.flags ? tr(r.check, n, d, s - d) : zd(r.check, n, d, s - d)), d = f, (r.flags ? c : wF(c)) !== r.check) {
                        t.msg = "incorrect data check", r.mode = pe;
                        break;
                    }
                    c = 0, u = 0;
                }
                r.mode = mF;
            case mF:
                if (r.wrap && r.flags) {
                    for(; u < 32;){
                        if (l === 0) break e;
                        l--, c += i[o++] << u, u += 8;
                    }
                    if (c !== (r.total & 4294967295)) {
                        t.msg = "incorrect length check", r.mode = pe;
                        break;
                    }
                    c = 0, u = 0;
                }
                r.mode = yF;
            case yF:
                x = ZN;
                break e;
            case pe:
                x = _F;
                break e;
            case Vd:
                return Wd;
            case JN:
            default:
                return Ft;
        }
        return t.next_out = s, t.avail_out = f, t.next_in = o, t.avail_in = l, r.hold = c, r.bits = u, (r.wsize || d !== t.avail_out && r.mode < pe && (r.mode < Ud || e !== K_)) && OF(t, t.output, t.next_out, d - t.avail_out) ? (r.mode = Vd, Wd) : (h -= t.avail_in, d -= t.avail_out, t.total_in += h, t.total_out += d, r.total += d, r.wrap && d && (t.adler = r.check = r.flags ? tr(r.check, n, d, t.next_out - d) : zd(r.check, n, d, t.next_out - d)), t.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === mr ? 128 : 0) + (r.mode === Xl || r.mode === jd ? 256 : 0), (h === 0 && d === 0 || e === K_) && x === Si && (x = YN), x);
    }
    a(sB, "inflate");
    function aB(t) {
        if (!t || !t.state) return Ft;
        var e = t.state;
        return e.window && (e.window = null), t.state = null, Si;
    }
    a(aB, "inflateEnd");
    function lB(t, e) {
        var r;
        return !t || !t.state || (r = t.state, !(r.wrap & 2)) ? Ft : (r.head = e, e.done = !1, Si);
    }
    a(lB, "inflateGetHeader");
    function cB(t, e) {
        var r = e.length, i, n, o;
        return !t || !t.state || (i = t.state, i.wrap !== 0 && i.mode !== Jl) ? Ft : i.mode === Jl && (n = 1, n = zd(n, e, r, 0), n !== i.check) ? _F : (o = OF(t, e, r, r), o ? (i.mode = Vd, Wd) : (i.havedict = 1, Si));
    }
    a(cB, "inflateSetDictionary");
    Dt.inflateReset = SF;
    Dt.inflateReset2 = xF;
    Dt.inflateResetKeep = EF;
    Dt.inflateInit = nB;
    Dt.inflateInit2 = TF;
    Dt.inflate = sB;
    Dt.inflateEnd = aB;
    Dt.inflateGetHeader = lB;
    Dt.inflateSetDictionary = cB;
    Dt.inflateInfo = "pako inflate (from Nodeca project)";
});
_c161 = RF;
var Gd = T(_c162 = (zU, kF)=>{
    "use strict";
    kF.exports = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
    };
});
_c163 = Gd;
var AF = T(_c164 = (WU, PF)=>{
    "use strict";
    function fB() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
    }
    a(fB, "GZheader");
    PF.exports = fB;
});
_c165 = AF;
var DF = T(_c166 = (cs)=>{
    "use strict";
    var Dn = RF(), ls = hr(), Ql = Id(), _e = Gd(), Kd = jl(), uB = Dd(), hB = AF(), IF = Object.prototype.toString;
    function xi(t) {
        if (!(this instanceof xi)) return new xi(t);
        this.options = ls.assign({
            chunkSize: 16384,
            windowBits: 0,
            to: ""
        }, t || {});
        var e = this.options;
        e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, e.windowBits === 0 && (e.windowBits = -15)), e.windowBits >= 0 && e.windowBits < 16 && !(t && t.windowBits) && (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && (e.windowBits & 15 || (e.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new uB, this.strm.avail_out = 0;
        var r = Dn.inflateInit2(this.strm, e.windowBits);
        if (r !== _e.Z_OK) throw new Error(Kd[r]);
        if (this.header = new hB, Dn.inflateGetHeader(this.strm, this.header), e.dictionary && (typeof e.dictionary == "string" ? e.dictionary = Ql.string2buf(e.dictionary) : IF.call(e.dictionary) === "[object ArrayBuffer]" && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (r = Dn.inflateSetDictionary(this.strm, e.dictionary), r !== _e.Z_OK))) throw new Error(Kd[r]);
    }
    a(xi, "Inflate");
    xi.prototype.push = function(t, e) {
        var r = this.strm, i = this.options.chunkSize, n = this.options.dictionary, o, s, l, f, c, u = !1;
        if (this.ended) return !1;
        s = e === ~~e ? e : e === !0 ? _e.Z_FINISH : _e.Z_NO_FLUSH, typeof t == "string" ? r.input = Ql.binstring2buf(t) : IF.call(t) === "[object ArrayBuffer]" ? r.input = new Uint8Array(t) : r.input = t, r.next_in = 0, r.avail_in = r.input.length;
        do {
            if (r.avail_out === 0 && (r.output = new ls.Buf8(i), r.next_out = 0, r.avail_out = i), o = Dn.inflate(r, _e.Z_NO_FLUSH), o === _e.Z_NEED_DICT && n && (o = Dn.inflateSetDictionary(this.strm, n)), o === _e.Z_BUF_ERROR && u === !0 && (o = _e.Z_OK, u = !1), o !== _e.Z_STREAM_END && o !== _e.Z_OK) return this.onEnd(o), this.ended = !0, !1;
            r.next_out && (r.avail_out === 0 || o === _e.Z_STREAM_END || r.avail_in === 0 && (s === _e.Z_FINISH || s === _e.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (l = Ql.utf8border(r.output, r.next_out), f = r.next_out - l, c = Ql.buf2string(r.output, l), r.next_out = f, r.avail_out = i - f, f && ls.arraySet(r.output, r.output, l, f, 0), this.onData(c)) : this.onData(ls.shrinkBuf(r.output, r.next_out))), r.avail_in === 0 && r.avail_out === 0 && (u = !0);
        }while ((r.avail_in > 0 || r.avail_out === 0) && o !== _e.Z_STREAM_END)
        return o === _e.Z_STREAM_END && (s = _e.Z_FINISH), s === _e.Z_FINISH ? (o = Dn.inflateEnd(this.strm), this.onEnd(o), this.ended = !0, o === _e.Z_OK) : (s === _e.Z_SYNC_FLUSH && (this.onEnd(_e.Z_OK), r.avail_out = 0), !0);
    };
    xi.prototype.onData = function(t) {
        this.chunks.push(t);
    };
    xi.prototype.onEnd = function(t) {
        t === _e.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = ls.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
    };
    function Zd(t, e) {
        var r = new xi(e);
        if (r.push(t, !0), r.err) throw r.msg || Kd[r.err];
        return r.result;
    }
    a(Zd, "inflate");
    function dB(t, e) {
        return e = e || {}, e.raw = !0, Zd(t, e);
    }
    a(dB, "inflateRaw");
    cs.Inflate = xi;
    cs.inflate = Zd;
    cs.inflateRaw = dB;
    cs.ungzip = Zd;
});
_c167 = DF;
var BF = T(_c168 = (ZU, NF)=>{
    "use strict";
    var pB = hr().assign, mB = $_(), yB = DF(), wB = Gd(), CF = {};
    pB(CF, mB, yB, wB);
    NF.exports = CF;
});
_c169 = BF;
var MF = T(_c170 = (XU, $F)=>{
    "use strict";
    var LF = a((t, e)=>function() {
            for(var _len = arguments.length, r = new Array(_len), _key = 0; _key < _len; _key++){
                r[_key] = arguments[_key];
            }
            let i = e.promiseModule;
            return new i((n, o)=>{
                e.multiArgs ? r.push(function() {
                    for(var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++){
                        s[_key] = arguments[_key];
                    }
                    e.errorFirst ? s[0] ? o(s) : (s.shift(), n(s)) : n(s);
                }) : e.errorFirst ? r.push((s, l)=>{
                    s ? o(s) : n(l);
                }) : r.push(n), t.apply(this, r);
            });
        }, "processFn");
    $F.exports = (t, e)=>{
        e = Object.assign({
            exclude: [
                /.+(Sync|Stream)$/
            ],
            errorFirst: !0,
            promiseModule: Promise
        }, e);
        let r = typeof t;
        if (!(t !== null && (r === "object" || r === "function"))) throw new TypeError("Expected `input` to be a `Function` or `Object`, got `".concat(t === null ? "null" : r, "`"));
        let i = a((o)=>{
            let s = a((l)=>typeof l == "string" ? o === l : l.test(o), "match");
            return e.include ? e.include.some(s) : !e.exclude.some(s);
        }, "filter"), n;
        r === "function" ? n = a(function() {
            for(var _len = arguments.length, o = new Array(_len), _key = 0; _key < _len; _key++){
                o[_key] = arguments[_key];
            }
            return e.excludeMain ? t(...o) : LF(t, e).apply(this, o);
        }, "ret") : n = Object.create(Object.getPrototypeOf(t));
        for(let o in t){
            let s = t[o];
            n[o] = typeof s == "function" && i(o) ? LF(s, e) : s;
        }
        return n;
    };
});
_c171 = MF;
var KF = T(_c172 = (JU, GF)=>{
    function jF(t) {
        return Array.isArray(t) ? t : [
            t
        ];
    }
    a(jF, "makeArray");
    var Jd = "", UF = " ", Xd = "\\", gB = /^\s+$/, bB = /(?:[^\\]|^)\\$/, vB = /^\\!/, _B = /^\\#/, FB = /\r?\n/g, EB = /^\.*\/|^\.+$/, Yd = "/", zF = "node-ignore";
    typeof Symbol < "u" && (zF = Symbol.for("node-ignore"));
    var qF = zF, SB = a((t, e, r)=>Object.defineProperty(t, e, {
            value: r
        }), "define"), xB = /([0-z])-([0-z])/g, WF = a(()=>!1, "RETURN_FALSE"), TB = a((t)=>t.replace(xB, (e, r, i)=>r.charCodeAt(0) <= i.charCodeAt(0) ? e : Jd), "sanitizeRange"), OB = a((t)=>{
        let { length: e } = t;
        return t.slice(0, e - e % 2);
    }, "cleanRangeBackSlash"), RB = [
        [
            /^\uFEFF/,
            ()=>Jd
        ],
        [
            /((?:\\\\)*?)(\\?\s+)$/,
            (t, e, r)=>e + (r.indexOf("\\") === 0 ? UF : Jd)
        ],
        [
            /(\\+?)\s/g,
            (t, e)=>{
                let { length: r } = e;
                return e.slice(0, r - r % 2) + UF;
            }
        ],
        [
            /[\\$.|*+(){^]/g,
            (t)=>"\\".concat(t)
        ],
        [
            /(?!\\)\?/g,
            ()=>"[^/]"
        ],
        [
            /^\//,
            ()=>"^"
        ],
        [
            /\//g,
            ()=>"\\/"
        ],
        [
            /^\^*\\\*\\\*\\\//,
            ()=>"^(?:.*\\/)?"
        ],
        [
            /^(?=[^^])/,
            a(function() {
                return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
            }, "startingReplacer")
        ],
        [
            /\\\/\\\*\\\*(?=\\\/|$)/g,
            (t, e, r)=>e + 6 < r.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
        ],
        [
            /(^|[^\\]+)(\\\*)+(?=.+)/g,
            (t, e, r)=>{
                let i = r.replace(/\\\*/g, "[^\\/]*");
                return e + i;
            }
        ],
        [
            /\\\\\\(?=[$.|*+(){^])/g,
            ()=>Xd
        ],
        [
            /\\\\/g,
            ()=>Xd
        ],
        [
            /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
            (t, e, r, i, n)=>e === Xd ? "\\[".concat(r).concat(OB(i)).concat(n) : n === "]" && i.length % 2 === 0 ? "[".concat(TB(r)).concat(i, "]") : "[]"
        ],
        [
            /(?:[^*])$/,
            (t)=>/\/$/.test(t) ? "".concat(t, "$") : "".concat(t, "(?=$|\\/$)")
        ],
        [
            /(\^|\\\/)?\\\*$/,
            (t, e)=>"".concat(e ? "".concat(e, "[^/]+") : "[^/]*", "(?=$|\\/$)")
        ]
    ], HF = Object.create(null), kB = a((t, e)=>{
        let r = HF[t];
        return r || (r = RB.reduce((i, param)=>{
            let [n, o] = param;
            return i.replace(n, o.bind(t));
        }, t), HF[t] = r), e ? new RegExp(r, "i") : new RegExp(r);
    }, "makeRegex"), tp = a((t)=>typeof t == "string", "isString"), PB = a((t)=>t && tp(t) && !gB.test(t) && !bB.test(t) && t.indexOf("#") !== 0, "checkPattern"), AB = a((t)=>t.split(FB), "splitPattern"), rp = class rp {
        constructor(e, r, i, n){
            this.origin = e, this.pattern = r, this.negative = i, this.regex = n;
        }
    };
    a(rp, "IgnoreRule");
    var Qd = rp, IB = a((t, e)=>{
        let r = t, i = !1;
        t.indexOf("!") === 0 && (i = !0, t = t.substr(1)), t = t.replace(vB, "!").replace(_B, "#");
        let n = kB(t, e);
        return new Qd(r, t, i, n);
    }, "createRule"), DB = a((t, e)=>{
        throw new e(t);
    }, "throwError"), yr = a((t, e, r)=>tp(t) ? t ? yr.isNotRelative(t) ? r('path should be a `path.relative()`d string, but got "'.concat(e, '"'), RangeError) : !0 : r("path must not be empty", TypeError) : r("path must be a string, but got `".concat(e, "`"), TypeError), "checkPath"), VF = a((t)=>EB.test(t), "isNotRelative");
    yr.isNotRelative = VF;
    yr.convert = (t)=>t;
    var ip = class ip {
        _initCache() {
            this._ignoreCache = Object.create(null), this._testCache = Object.create(null);
        }
        _addPattern(e) {
            if (e && e[qF]) {
                this._rules = this._rules.concat(e._rules), this._added = !0;
                return;
            }
            if (PB(e)) {
                let r = IB(e, this._ignoreCase);
                this._added = !0, this._rules.push(r);
            }
        }
        add(e) {
            return this._added = !1, jF(tp(e) ? AB(e) : e).forEach(this._addPattern, this), this._added && this._initCache(), this;
        }
        addPattern(e) {
            return this.add(e);
        }
        _testOne(e, r) {
            let i = !1, n = !1;
            return this._rules.forEach((o)=>{
                let { negative: s } = o;
                if (n === s && i !== n || s && !i && !n && !r) return;
                o.regex.test(e) && (i = !s, n = s);
            }), {
                ignored: i,
                unignored: n
            };
        }
        _test(e, r, i, n) {
            let o = e && yr.convert(e);
            return yr(o, e, this._allowRelativePaths ? WF : DB), this._t(o, r, i, n);
        }
        _t(e, r, i, n) {
            if (e in r) return r[e];
            if (n || (n = e.split(Yd)), n.pop(), !n.length) return r[e] = this._testOne(e, i);
            let o = this._t(n.join(Yd) + Yd, r, i, n);
            return r[e] = o.ignored ? o : this._testOne(e, i);
        }
        ignores(e) {
            return this._test(e, this._ignoreCache, !1).ignored;
        }
        createFilter() {
            return (e)=>!this.ignores(e);
        }
        filter(e) {
            return jF(e).filter(this.createFilter());
        }
        test(e) {
            return this._test(e, this._testCache, !0);
        }
        constructor({ ignorecase: e = !0, ignoreCase: r = e, allowRelativePaths: i = !1 } = {}){
            SB(this, qF, !0), this._rules = [], this._ignoreCase = r, this._allowRelativePaths = i, this._initCache();
        }
    };
    a(ip, "Ignore");
    var ep = ip, ec = a((t)=>new ep(t), "factory"), CB = a((t)=>yr(t && yr.convert(t), t, WF), "isPathValid");
    ec.isPathValid = CB;
    ec.default = ec;
    GF.exports = ec;
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] < "u" && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.IGNORE_TEST_WIN32 || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === "win32")) {
        let t = a((r)=>/^\\\\\?\\/.test(r) || /["<>|\u0000-\u001F]+/u.test(r) ? r : r.replace(/\\/g, "/"), "makePosix");
        yr.convert = t;
        let e = /^[a-z]:\//i;
        yr.isNotRelative = (r)=>e.test(r) || VF(r);
    }
});
_c173 = KF;
var XF = T(_c174 = (eq, ZF)=>{
    "use strict";
    function NB(t) {
        return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    a(NB, "escapeRegExp");
    function rr(t, e, r) {
        return e = e instanceof RegExp ? e : new RegExp(NB(e), "g"), t.replace(e, r);
    }
    a(rr, "replaceAll");
    var BB = {
        clean: a(function(e) {
            if (typeof e != "string") throw new Error("Expected a string, received: " + e);
            return e = rr(e, "./", "/"), e = rr(e, "..", "."), e = rr(e, " ", "-"), e = rr(e, /^[~^:?*\\\-]/g, ""), e = rr(e, /[~^:?*\\]/g, "-"), e = rr(e, /[~^:?*\\\-]$/g, ""), e = rr(e, "@{", "-"), e = rr(e, /\.$/g, ""), e = rr(e, /\/$/g, ""), e = rr(e, /\.lock$/g, ""), e;
        }, "clean")
    };
    ZF.exports = BB;
});
_c175 = XF;
var JF = T(_c176 = (rq, YF)=>{
    "use strict";
    var LB = /(^|[/.])([/.]|$)|^@$|@{|[\x00-\x20\x7f~^:?*[\\]|\.lock(\/|$)/;
    YF.exports = a(function(e, r) {
        if (typeof e != "string") throw new TypeError("Reference name must be a string");
        return !LB.test(e) && (!!r || e.includes("/"));
    }, "validRef");
});
_c177 = JF;
var eE = T((nq, QF)=>{
    QF.exports = function(t, e) {
        var r = t, i = e, n = r.length, o = i.length, s = !1, l = null, f = n + 1, c = [], u = [], h = [], d = "", p = -1, m = 0, y = 1, w, v, g = a(function() {
            n >= o && (w = r, v = n, r = i, i = w, n = o, o = v, s = !0, f = n + 1);
        }, "init"), F = a(function(b, x, _) {
            return {
                x: b,
                y: x,
                k: _
            };
        }, "P"), O = a(function(b, x) {
            return {
                elem: b,
                t: x
            };
        }, "seselem"), S = a(function(b, x, _) {
            var P, k, C;
            for(x > _ ? P = c[b - 1 + f] : P = c[b + 1 + f], C = Math.max(x, _), k = C - b; k < n && C < o && r[k] === i[C];)++k, ++C;
            return c[b + f] = u.length, u[u.length] = new F(k, C, P), C;
        }, "snake"), R = a(function(b) {
            var x, _, P, k, C;
            for(x = _ = 1, P = k = 0, C = b.length - 1; C >= 0; --C)for(; P < b[C].x || k < b[C].y;)b[C].y - b[C].x > k - P ? (s ? h[h.length] = new O(i[k], p) : h[h.length] = new O(i[k], y), ++_, ++k) : b[C].y - b[C].x < k - P ? (s ? h[h.length] = new O(r[P], y) : h[h.length] = new O(r[P], p), ++x, ++P) : (h[h.length] = new O(r[P], m), d += r[P], ++x, ++_, ++P, ++k);
        }, "recordseq");
        return g(), {
            SES_DELETE: -1,
            SES_COMMON: 0,
            SES_ADD: 1,
            editdistance: a(function() {
                return l;
            }, "editdistance"),
            getlcs: a(function() {
                return d;
            }, "getlcs"),
            getses: a(function() {
                return h;
            }, "getses"),
            compose: a(function() {
                var b, x, _, P, k, C, N, U;
                for(b = o - n, x = n + o + 3, _ = {}, N = 0; N < x; ++N)_[N] = -1, c[N] = -1;
                P = -1;
                do {
                    for(++P, U = -P; U <= b - 1; ++U)_[U + f] = S(U, _[U - 1 + f] + 1, _[U + 1 + f]);
                    for(U = b + P; U >= b + 1; --U)_[U + f] = S(U, _[U - 1 + f] + 1, _[U + 1 + f]);
                    _[b + f] = S(b, _[b - 1 + f] + 1, _[b + 1 + f]);
                }while (_[b + f] !== o)
                for(l = b + 2 * P, k = c[b + f], C = []; k !== -1;)C[C.length] = new F(u[k].x, u[k].y, null), k = u[k].k;
                R(C);
            }, "compose")
        };
    };
});
var iE = T((sq, rE)=>{
    var $B = eE();
    function MB(t, e) {
        var r = new $B(t, e);
        r.compose();
        for(var i = r.getses(), n, o, s = t.length - 1, l = e.length - 1, f = i.length - 1; f >= 0; --f)i[f].t === r.SES_COMMON ? (o ? (o.chain = {
            file1index: s,
            file2index: l,
            chain: null
        }, o = o.chain) : (n = {
            file1index: s,
            file2index: l,
            chain: null
        }, o = n), s--, l--) : i[f].t === r.SES_DELETE ? s-- : i[f].t === r.SES_ADD && l--;
        var c = {
            file1index: -1,
            file2index: -1,
            chain: null
        };
        return o ? (o.chain = c, n) : c;
    }
    a(MB, "longestCommonSubsequence");
    function tE(t, e) {
        for(var r = [], i = t.length, n = e.length, o = MB(t, e); o !== null; o = o.chain){
            var s = i - o.file1index - 1, l = n - o.file2index - 1;
            i = o.file1index, n = o.file2index, (s || l) && r.push({
                file1: [
                    i + 1,
                    s
                ],
                file2: [
                    n + 1,
                    l
                ]
            });
        }
        return r.reverse(), r;
    }
    a(tE, "diffIndices");
    function jB(t, e, r) {
        var i, n = tE(e, t), o = tE(e, r), s = [];
        function l(N, U) {
            s.push([
                N.file1[0],
                U,
                N.file1[1],
                N.file2[0],
                N.file2[1]
            ]);
        }
        for(a(l, "addHunk"), i = 0; i < n.length; i++)l(n[i], 0);
        for(i = 0; i < o.length; i++)l(o[i], 2);
        s.sort(function(N, U) {
            return N[0] - U[0];
        });
        var f = [], c = 0;
        function u(N) {
            N > c && (f.push([
                1,
                c,
                N - c
            ]), c = N);
        }
        a(u, "copyCommon");
        for(var h = 0; h < s.length; h++){
            for(var d = h, p = s[h], m = p[0], y = m + p[2]; h < s.length - 1;){
                var w = s[h + 1], v = w[0];
                if (v > y) break;
                y = Math.max(y, v + w[2]), h++;
            }
            if (u(m), d == h) p[4] > 0 && f.push([
                p[1],
                p[3],
                p[4]
            ]);
            else {
                var g = {
                    0: [
                        t.length,
                        -1,
                        e.length,
                        -1
                    ],
                    2: [
                        r.length,
                        -1,
                        e.length,
                        -1
                    ]
                };
                for(i = d; i <= h; i++){
                    p = s[i];
                    var F = p[1], O = g[F], S = p[0], R = S + p[2], b = p[3], x = b + p[4];
                    O[0] = Math.min(b, O[0]), O[1] = Math.max(x, O[1]), O[2] = Math.min(S, O[2]), O[3] = Math.max(R, O[3]);
                }
                var _ = g[0][0] + (m - g[0][2]), P = g[0][1] + (y - g[0][3]), k = g[2][0] + (m - g[2][2]), C = g[2][1] + (y - g[2][3]);
                f.push([
                    -1,
                    _,
                    P - _,
                    m,
                    y - m,
                    k,
                    C - k
                ]);
            }
            c = y;
        }
        return u(e.length), f;
    }
    a(jB, "diff3MergeIndices");
    function UB(t, e, r) {
        var i = [], n = [
            t,
            e,
            r
        ], o = jB(t, e, r), s = [];
        function l() {
            s.length && i.push({
                ok: s
            }), s = [];
        }
        a(l, "flushOk");
        function f(p) {
            for(var m = 0; m < p.length; m++)s.push(p[m]);
        }
        a(f, "pushOk");
        function c(p) {
            if (p[2] != p[6]) return !0;
            for(var m = p[1], y = p[5], w = 0; w < p[2]; w++)if (t[w + m] != r[w + y]) return !0;
            return !1;
        }
        a(c, "isTrueConflict");
        for(var u = 0; u < o.length; u++){
            var h = o[u], d = h[0];
            d == -1 ? c(h) ? (l(), i.push({
                conflict: {
                    a: t.slice(h[1], h[1] + h[2]),
                    aIndex: h[1],
                    o: e.slice(h[3], h[3] + h[4]),
                    oIndex: h[3],
                    b: r.slice(h[5], h[5] + h[6]),
                    bIndex: h[5]
                }
            })) : f(n[0].slice(h[1], h[1] + h[2])) : f(n[d].slice(h[1], h[1] + h[2]));
        }
        return l(), i;
    }
    a(UB, "diff3Merge");
    rE.exports = UB;
});
var ze = T((L)=>{
    "use strict";
    Object.defineProperty(L, "__esModule", {
        value: !0
    });
    function br(t) {
        return t && typeof t == "object" && "default" in t ? t.default : t;
    }
    a(br, "_interopDefault");
    var hs = br(Jb()), TE = br(Gv()), D = Er(), qB = br(Zv()), kp = br(BF()), np = br(MF()), HB = br(KF()), ds = br(XF()), ps = br(JF()), zB = br(iE()), dc = class dc extends Error {
        toJSON() {
            return {
                code: this.code,
                data: this.data,
                caller: this.caller,
                message: this.message,
                stack: this.stack
            };
        }
        fromJSON(e) {
            let r = new dc(e.message);
            return r.code = e.code, r.data = e.data, r.caller = e.caller, r.stack = e.stack, r;
        }
        get isIsomorphicGitError() {
            return !0;
        }
        constructor(e){
            super(e), this.caller = "";
        }
    };
    a(dc, "BaseError");
    var re = dc, pc = class pc extends re {
        constructor(e){
            super("Modifying the index is not possible because you have unmerged files: ".concat(e.toString, ". Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.")), this.code = this.name = pc.code, this.data = {
                filepaths: e
            };
        }
    };
    a(pc, "UnmergedPathsError");
    var ms = pc;
    ms.code = "UnmergedPathsError";
    var mc = class mc extends re {
        constructor(e){
            super("An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ".concat(e)), this.code = this.name = mc.code, this.data = {
                message: e
            };
        }
    };
    a(mc, "InternalError");
    var W = mc;
    W.code = "InternalError";
    var yc = class yc extends re {
        constructor(e){
            super('The filepath "'.concat(e, '" contains unsafe character sequences')), this.code = this.name = yc.code, this.data = {
                filepath: e
            };
        }
    };
    a(yc, "UnsafeFilepathError");
    var Ln = yc;
    Ln.code = "UnsafeFilepathError";
    var Bp = class Bp {
        eof() {
            return this._start >= this.buffer.length;
        }
        tell() {
            return this._start;
        }
        seek(e) {
            this._start = e;
        }
        slice(e) {
            let r = this.buffer.slice(this._start, this._start + e);
            return this._start += e, r;
        }
        toString(e, r) {
            let i = this.buffer.toString(e, this._start, this._start + r);
            return this._start += r, i;
        }
        write(e, r, i) {
            let n = this.buffer.write(e, this._start, r, i);
            return this._start += r, n;
        }
        copy(e, r, i) {
            let n = e.copy(this.buffer, this._start, r, i);
            return this._start += n, n;
        }
        readUInt8() {
            let e = this.buffer.readUInt8(this._start);
            return this._start += 1, e;
        }
        writeUInt8(e) {
            let r = this.buffer.writeUInt8(e, this._start);
            return this._start += 1, r;
        }
        readUInt16BE() {
            let e = this.buffer.readUInt16BE(this._start);
            return this._start += 2, e;
        }
        writeUInt16BE(e) {
            let r = this.buffer.writeUInt16BE(e, this._start);
            return this._start += 2, r;
        }
        readUInt32BE() {
            let e = this.buffer.readUInt32BE(this._start);
            return this._start += 4, e;
        }
        writeUInt32BE(e) {
            let r = this.buffer.writeUInt32BE(e, this._start);
            return this._start += 4, r;
        }
        constructor(e){
            this.buffer = e, this._start = 0;
        }
    };
    a(Bp, "BufferCursor");
    var Et = Bp;
    function Jc(t, e) {
        return -(t < e) || +(t > e);
    }
    a(Jc, "compareStrings");
    function OE(t, e) {
        return Jc(t.path, e.path);
    }
    a(OE, "comparePath");
    function RE(t) {
        let e = t > 0 ? t >> 12 : 0;
        e !== 4 && e !== 8 && e !== 10 && e !== 14 && (e = 8);
        let r = t & 511;
        return r & 73 ? r = 493 : r = 420, e !== 8 && (r = 0), (e << 12) + r;
    }
    a(RE, "normalizeMode");
    var ir = 2 ** 32;
    function nE(t, e, r, i) {
        if (t !== void 0 && e !== void 0) return [
            t,
            e
        ];
        r === void 0 && (r = i.valueOf());
        let n = Math.floor(r / 1e3), o = (r - n * 1e3) * 1e6;
        return [
            n,
            o
        ];
    }
    a(nE, "SecondsNanoseconds");
    function $n(t) {
        let [e, r] = nE(t.ctimeSeconds, t.ctimeNanoseconds, t.ctimeMs, t.ctime), [i, n] = nE(t.mtimeSeconds, t.mtimeNanoseconds, t.mtimeMs, t.mtime);
        return {
            ctimeSeconds: e % ir,
            ctimeNanoseconds: r % ir,
            mtimeSeconds: i % ir,
            mtimeNanoseconds: n % ir,
            dev: t.dev % ir,
            ino: t.ino % ir,
            mode: RE(t.mode % ir),
            uid: t.uid % ir,
            gid: t.gid % ir,
            size: t.size > -1 ? t.size % ir : 0
        };
    }
    a($n, "normalizeStats");
    function WB(t) {
        let e = "";
        for (let r of new Uint8Array(t))r < 16 && (e += "0"), e += r.toString(16);
        return e;
    }
    a(WB, "toHex");
    var op = null;
    async function gr(t) {
        return op === null && (op = await GB()), op ? kE(t) : VB(t);
    }
    a(gr, "shasum");
    function VB(t) {
        return new TE().update(t).digest("hex");
    }
    a(VB, "shasumSync");
    async function kE(t) {
        let e = await crypto.subtle.digest("SHA-1", t);
        return WB(e);
    }
    a(kE, "subtleSHA1");
    async function GB() {
        try {
            return await kE(new Uint8Array([])) === "da39a3ee5e6b4b0d3255bfef95601890afd80709";
        } catch (e) {}
        return !1;
    }
    a(GB, "testSubtleSHA1");
    function KB(t) {
        return {
            assumeValid: !!(t & 32768),
            extended: !!(t & 16384),
            stage: (t & 12288) >> 12,
            nameLength: t & 4095
        };
    }
    a(KB, "parseCacheEntryFlags");
    function ZB(t) {
        let e = t.flags;
        return e.extended = !1, e.nameLength = Math.min(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(t.path).length, 4095), (e.assumeValid ? 32768 : 0) + (e.extended ? 16384 : 0) + ((e.stage & 3) << 12) + (e.nameLength & 4095);
    }
    a(ZB, "renderCacheEntryFlags");
    var zr = class zr {
        _addEntry(e) {
            if (e.flags.stage === 0) e.stages = [
                e
            ], this._entries.set(e.path, e), this._unmergedPaths.delete(e.path);
            else {
                let r = this._entries.get(e.path);
                r || (this._entries.set(e.path, e), r = e), r.stages[e.flags.stage] = e, this._unmergedPaths.add(e.path);
            }
        }
        static async from(e) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(e)) return zr.fromBuffer(e);
            if (e === null) return new zr(null);
            throw new W("invalid type passed to GitIndex.from");
        }
        static async fromBuffer(e) {
            if (e.length === 0) throw new W("Index file is empty (.git/index)");
            let r = new zr, i = new Et(e), n = i.toString("utf8", 4);
            if (n !== "DIRC") throw new W("Invalid dircache magic file number: ".concat(n));
            let o = await gr(e.slice(0, -20)), s = e.slice(-20).toString("hex");
            if (s !== o) throw new W("Invalid checksum in GitIndex buffer: expected ".concat(s, " but saw ").concat(o));
            let l = i.readUInt32BE();
            if (l !== 2) throw new W("Unsupported dircache version: ".concat(l));
            let f = i.readUInt32BE(), c = 0;
            for(; !i.eof() && c < f;){
                let u = {};
                u.ctimeSeconds = i.readUInt32BE(), u.ctimeNanoseconds = i.readUInt32BE(), u.mtimeSeconds = i.readUInt32BE(), u.mtimeNanoseconds = i.readUInt32BE(), u.dev = i.readUInt32BE(), u.ino = i.readUInt32BE(), u.mode = i.readUInt32BE(), u.uid = i.readUInt32BE(), u.gid = i.readUInt32BE(), u.size = i.readUInt32BE(), u.oid = i.slice(20).toString("hex");
                let h = i.readUInt16BE();
                u.flags = KB(h);
                let d = e.indexOf(0, i.tell() + 1) - i.tell();
                if (d < 1) throw new W("Got a path length of: ".concat(d));
                if (u.path = i.toString("utf8", d), u.path.includes("..\\") || u.path.includes("../")) throw new Ln(u.path);
                let p = 8 - (i.tell() - 12) % 8;
                for(p === 0 && (p = 8); p--;){
                    let m = i.readUInt8();
                    if (m !== 0) throw new W("Expected 1-8 null characters but got '".concat(m, "' after ").concat(u.path));
                    if (i.eof()) throw new W("Unexpected end of file");
                }
                u.stages = [], r._addEntry(u), c++;
            }
            return r;
        }
        get unmergedPaths() {
            return [
                ...this._unmergedPaths
            ];
        }
        get entries() {
            return [
                ...this._entries.values()
            ].sort(OE);
        }
        get entriesMap() {
            return this._entries;
        }
        get entriesFlat() {
            return [
                ...this.entries
            ].flatMap((e)=>e.stages.length > 1 ? e.stages.filter((r)=>r) : e);
        }
        *[Symbol.iterator]() {
            for (let e of this.entries)yield e;
        }
        insert(param) {
            let { filepath: e, stats: r, oid: i, stage: n = 0 } = param;
            r || (r = {
                ctimeSeconds: 0,
                ctimeNanoseconds: 0,
                mtimeSeconds: 0,
                mtimeNanoseconds: 0,
                dev: 0,
                ino: 0,
                mode: 0,
                uid: 0,
                gid: 0,
                size: 0
            }), r = $n(r);
            let o = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e), s = {
                ctimeSeconds: r.ctimeSeconds,
                ctimeNanoseconds: r.ctimeNanoseconds,
                mtimeSeconds: r.mtimeSeconds,
                mtimeNanoseconds: r.mtimeNanoseconds,
                dev: r.dev,
                ino: r.ino,
                mode: r.mode || 33188,
                uid: r.uid,
                gid: r.gid,
                size: r.size,
                path: e,
                oid: i,
                flags: {
                    assumeValid: !1,
                    extended: !1,
                    stage: n,
                    nameLength: o.length < 4095 ? o.length : 4095
                },
                stages: []
            };
            this._addEntry(s), this._dirty = !0;
        }
        delete(param) {
            let { filepath: e } = param;
            if (this._entries.has(e)) this._entries.delete(e);
            else for (let r of this._entries.keys())r.startsWith(e + "/") && this._entries.delete(r);
            this._unmergedPaths.has(e) && this._unmergedPaths.delete(e), this._dirty = !0;
        }
        clear() {
            this._entries.clear(), this._dirty = !0;
        }
        has(param) {
            let { filepath: e } = param;
            return this._entries.has(e);
        }
        render() {
            return this.entries.map((e)=>"".concat(e.mode.toString(8), " ").concat(e.oid, "    ").concat(e.path)).join("\n");
        }
        static async _entryToBuffer(e) {
            let r = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e.path), i = Math.ceil((62 + r.length + 1) / 8) * 8, n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(i), o = new Et(n), s = $n(e);
            return o.writeUInt32BE(s.ctimeSeconds), o.writeUInt32BE(s.ctimeNanoseconds), o.writeUInt32BE(s.mtimeSeconds), o.writeUInt32BE(s.mtimeNanoseconds), o.writeUInt32BE(s.dev), o.writeUInt32BE(s.ino), o.writeUInt32BE(s.mode), o.writeUInt32BE(s.uid), o.writeUInt32BE(s.gid), o.writeUInt32BE(s.size), o.write(e.oid, 20, "hex"), o.writeUInt16BE(ZB(e)), o.write(e.path, r.length, "utf8"), n;
        }
        async toObject() {
            let e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(12), r = new Et(e);
            r.write("DIRC", 4, "utf8"), r.writeUInt32BE(2), r.writeUInt32BE(this.entriesFlat.length);
            let i = [];
            for (let l of this.entries)if (i.push(zr._entryToBuffer(l)), l.stages.length > 1) for (let f of l.stages)f && f !== l && i.push(zr._entryToBuffer(f));
            i = await Promise.all(i);
            let n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(i), o = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
                e,
                n
            ]), s = await gr(o);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
                o,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(s, "hex")
            ]);
        }
        constructor(e, r){
            this._dirty = !1, this._unmergedPaths = r || new Set, this._entries = e || new Map;
        }
    };
    a(zr, "GitIndex");
    var wp = zr;
    function ic(t, e) {
        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0;
        let n = $n(t), o = $n(e);
        return r && n.mode !== o.mode || n.mtimeSeconds !== o.mtimeSeconds || n.ctimeSeconds !== o.ctimeSeconds || n.uid !== o.uid || n.gid !== o.gid || i && n.ino !== o.ino || n.size !== o.size;
    }
    a(ic, "compareStats");
    var sp = null, ap = Symbol("IndexCache");
    function XB() {
        return {
            map: new Map,
            stats: new Map
        };
    }
    a(XB, "createCache");
    async function YB(t, e, r) {
        let [i, n] = await Promise.all([
            t.lstat(e),
            t.read(e)
        ]), o = await wp.from(n);
        r.map.set(e, o), r.stats.set(e, i);
    }
    a(YB, "updateCachedIndexFile");
    async function JB(t, e, r) {
        let i = r.stats.get(e);
        if (i === void 0) return !0;
        if (i === null) return !1;
        let n = await t.lstat(e);
        return n === null ? !1 : ic(i, n);
    }
    a(JB, "isIndexStale");
    var Lp = class Lp {
        static async acquire(param, o) {
            let { fs: e, gitdir: r, cache: i, allowUnmerged: n = !0 } = param;
            i[ap] || (i[ap] = XB());
            let s = "".concat(r, "/index");
            sp === null && (sp = new hs({
                maxPending: 1 / 0
            }));
            let l, f = [];
            return await sp.acquire(s, async ()=>{
                let c = i[ap];
                await JB(e, s, c) && await YB(e, s, c);
                let u = c.map.get(s);
                if (f = u.unmergedPaths, f.length && !n) throw new ms(f);
                if (l = await o(u), u._dirty) {
                    let h = await u.toObject();
                    await e.write(s, h), c.stats.set(s, await e.lstat(s)), u._dirty = !1;
                }
            }), l;
        }
    };
    a(Lp, "GitIndexManager");
    var Fe = Lp;
    function nc(t) {
        let e = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
        return e > -1 && (t = t.slice(e + 1)), t;
    }
    a(nc, "basename");
    function Mn(t) {
        let e = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
        return e === -1 ? "." : e === 0 ? "/" : t.slice(0, e);
    }
    a(Mn, "dirname");
    function PE(t) {
        let e = new Map, r = a(function(n) {
            if (!e.has(n)) {
                let o = {
                    type: "tree",
                    fullpath: n,
                    basename: nc(n),
                    metadata: {},
                    children: []
                };
                e.set(n, o), o.parent = r(Mn(n)), o.parent && o.parent !== o && o.parent.children.push(o);
            }
            return e.get(n);
        }, "mkdir"), i = a(function(n, o) {
            if (!e.has(n)) {
                let s = {
                    type: "blob",
                    fullpath: n,
                    basename: nc(n),
                    metadata: o,
                    parent: r(Mn(n)),
                    children: []
                };
                s.parent && s.parent.children.push(s), e.set(n, s);
            }
            return e.get(n);
        }, "mkfile");
        r(".");
        for (let n of t)i(n.path, n);
        return e;
    }
    a(PE, "flatFileListToDirectoryStructure");
    function QB(t) {
        switch(t){
            case 16384:
                return "tree";
            case 33188:
                return "blob";
            case 33261:
                return "blob";
            case 40960:
                return "blob";
            case 57344:
                return "commit";
        }
        throw new W("Unexpected GitTree entry mode: ".concat(t.toString(8)));
    }
    a(QB, "mode2type");
    var $p = class $p {
        async readdir(e) {
            let r = e._fullpath, n = (await this.treePromise).get(r);
            if (!n || n.type === "blob") return null;
            if (n.type !== "tree") throw new Error("ENOTDIR: not a directory, scandir '".concat(r, "'"));
            let o = n.children.map((s)=>s.fullpath);
            return o.sort(Jc), o;
        }
        async type(e) {
            return e._type === !1 && await e.stat(), e._type;
        }
        async mode(e) {
            return e._mode === !1 && await e.stat(), e._mode;
        }
        async stat(e) {
            if (e._stat === !1) {
                let i = (await this.treePromise).get(e._fullpath);
                if (!i) throw new Error("ENOENT: no such file or directory, lstat '".concat(e._fullpath, "'"));
                let n = i.type === "tree" ? {} : $n(i.metadata);
                e._type = i.type === "tree" ? "tree" : QB(n.mode), e._mode = n.mode, i.type === "tree" ? e._stat = void 0 : e._stat = n;
            }
            return e._stat;
        }
        async content(e) {}
        async oid(e) {
            if (e._oid === !1) {
                let i = (await this.treePromise).get(e._fullpath);
                e._oid = i.metadata.oid;
            }
            return e._oid;
        }
        constructor({ fs: e, gitdir: r, cache: i }){
            var o;
            this.treePromise = Fe.acquire({
                fs: e,
                gitdir: r,
                cache: i
            }, async function(s) {
                return PE(s.entries);
            });
            let n = this;
            this.ConstructEntry = (o = class {
                async type() {
                    return n.type(this);
                }
                async mode() {
                    return n.mode(this);
                }
                async stat() {
                    return n.stat(this);
                }
                async content() {
                    return n.content(this);
                }
                async oid() {
                    return n.oid(this);
                }
                constructor(l){
                    this._fullpath = l, this._type = !1, this._mode = !1, this._stat = !1, this._oid = !1;
                }
            }, a(o, "StageEntry"), o);
        }
    };
    a($p, "GitWalkerIndex");
    var gp = $p, Qc = Symbol("GitWalkSymbol");
    function Ai() {
        let t = Object.create(null);
        return Object.defineProperty(t, Qc, {
            value: a(function(param) {
                let { fs: e, gitdir: r, cache: i } = param;
                return new gp({
                    fs: e,
                    gitdir: r,
                    cache: i
                });
            }, "value")
        }), Object.freeze(t), t;
    }
    a(Ai, "STAGE");
    var wc = class wc extends re {
        constructor(e){
            super("Could not find ".concat(e, ".")), this.code = this.name = wc.code, this.data = {
                what: e
            };
        }
    };
    a(wc, "NotFoundError");
    var ce = wc;
    ce.code = "NotFoundError";
    var gc = class gc extends re {
        constructor(e, r, i, n){
            super("Object ".concat(e, " ").concat(n ? "at ".concat(n) : "", "was anticipated to be a ").concat(i, " but it is a ").concat(r, ".")), this.code = this.name = gc.code, this.data = {
                oid: e,
                actual: r,
                expected: i,
                filepath: n
            };
        }
    };
    a(gc, "ObjectTypeError");
    var Ze = gc;
    Ze.code = "ObjectTypeError";
    var bc = class bc extends re {
        constructor(e){
            super('Expected a 40-char hex object id but saw "'.concat(e, '".')), this.code = this.name = bc.code, this.data = {
                value: e
            };
        }
    };
    a(bc, "InvalidOidError");
    var Vr = bc;
    Vr.code = "InvalidOidError";
    var vc = class vc extends re {
        constructor(e){
            super('Could not find a fetch refspec for remote "'.concat(e, '". Make sure the config file has an entry like the following:\n[remote "').concat(e, '"]\n	fetch = +refs/heads/*:refs/remotes/origin/*\n')), this.code = this.name = vc.code, this.data = {
                remote: e
            };
        }
    };
    a(vc, "NoRefspecError");
    var ys = vc;
    ys.code = "NoRefspecError";
    var _c = class _c {
        static from(e) {
            return new _c(e);
        }
        delete(e) {
            this.parsedConfig = this.parsedConfig.filter((r)=>r.ref !== e), this.refs.delete(e);
        }
        toString() {
            return this.parsedConfig.map((param)=>{
                let { line: e } = param;
                return e;
            }).join("\n") + "\n";
        }
        constructor(e){
            if (this.refs = new Map, this.parsedConfig = [], e) {
                let r = null;
                this.parsedConfig = e.trim().split("\n").map((i)=>{
                    if (/^\s*#/.test(i)) return {
                        line: i,
                        comment: !0
                    };
                    let n = i.indexOf(" ");
                    if (i.startsWith("^")) {
                        let o = i.slice(1);
                        return this.refs.set(r + "^{}", o), {
                            line: i,
                            ref: r,
                            peeled: o
                        };
                    } else {
                        let o = i.slice(0, n);
                        return r = i.slice(n + 1), this.refs.set(r, o), {
                            line: i,
                            ref: r,
                            oid: o
                        };
                    }
                });
            }
            return this;
        }
    };
    a(_c, "GitPackedRefs");
    var oc = _c, Fc = class Fc {
        static from(e) {
            let [r, i, n, o, s] = e.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1), l = r === "+", f = n === "*";
            if (f !== (s === "*")) throw new W("Invalid refspec");
            return new Fc({
                remotePath: i,
                localPath: o,
                force: l,
                matchPrefix: f
            });
        }
        translate(e) {
            if (this.matchPrefix) {
                if (e.startsWith(this.remotePath)) return this.localPath + e.replace(this.remotePath, "");
            } else if (e === this.remotePath) return this.localPath;
            return null;
        }
        reverseTranslate(e) {
            if (this.matchPrefix) {
                if (e.startsWith(this.localPath)) return this.remotePath + e.replace(this.localPath, "");
            } else if (e === this.localPath) return this.remotePath;
            return null;
        }
        constructor({ remotePath: e, localPath: r, force: i, matchPrefix: n }){
            Object.assign(this, {
                remotePath: e,
                localPath: r,
                force: i,
                matchPrefix: n
            });
        }
    };
    a(Fc, "GitRefSpec");
    var sc = Fc, Ec = class Ec {
        static from(e) {
            let r = [];
            for (let i of e)r.push(sc.from(i));
            return new Ec(r);
        }
        add(e) {
            let r = sc.from(e);
            this.rules.push(r);
        }
        translate(e) {
            let r = [];
            for (let i of this.rules)for (let n of e){
                let o = i.translate(n);
                o && r.push([
                    n,
                    o
                ]);
            }
            return r;
        }
        translateOne(e) {
            let r = null;
            for (let i of this.rules){
                let n = i.translate(e);
                n && (r = n);
            }
            return r;
        }
        localNamespaces() {
            return this.rules.filter((e)=>e.matchPrefix).map((e)=>e.localPath.replace(/\/$/, ""));
        }
        constructor(e = []){
            this.rules = e;
        }
    };
    a(Ec, "GitRefSpecSet");
    var bp = Ec;
    function eL(t, e) {
        let r = t.replace(/\^\{\}$/, ""), i = e.replace(/\^\{\}$/, ""), n = -(r < i) || +(r > i);
        return n === 0 ? t.endsWith("^{}") ? 1 : -1 : n;
    }
    a(eL, "compareRefNames");
    var tL = a((t)=>{
        if (typeof t == "number") return t;
        t = t.toLowerCase();
        let e = parseInt(t);
        return t.endsWith("k") && (e *= 1024), t.endsWith("m") && (e *= 1024 * 1024), t.endsWith("g") && (e *= 1024 * 1024 * 1024), e;
    }, "num"), fs = a((t)=>{
        if (typeof t == "boolean") return t;
        if (t = t.trim().toLowerCase(), t === "true" || t === "yes" || t === "on") return !0;
        if (t === "false" || t === "no" || t === "off") return !1;
        throw Error("Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ".concat(t));
    }, "bool"), oE = {
        core: {
            filemode: fs,
            bare: fs,
            logallrefupdates: fs,
            symlinks: fs,
            ignorecase: fs,
            bigFileThreshold: tL
        }
    }, rL = /^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/, iL = /^[A-Za-z0-9-.]+$/, nL = /^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/, oL = /^[A-Za-z][A-Za-z-]*$/, sL = /^(.*?)( *[#;].*)$/, aL = a((t)=>{
        let e = rL.exec(t);
        if (e != null) {
            let [r, i] = e.slice(1);
            return [
                r,
                i
            ];
        }
        return null;
    }, "extractSectionLine"), lL = a((t)=>{
        let e = nL.exec(t);
        if (e != null) {
            let [r, i = "true"] = e.slice(1), n = cL(i), o = fL(n);
            return [
                r,
                o
            ];
        }
        return null;
    }, "extractVariableLine"), cL = a((t)=>{
        let e = sL.exec(t);
        if (e == null) return t;
        let [r, i] = e.slice(1);
        return sE(r) && sE(i) ? "".concat(r).concat(i) : r;
    }, "removeComments"), sE = a((t)=>(t.match(/(?:^|[^\\])"/g) || []).length % 2 !== 0, "hasOddNumberOfQuotes"), fL = a((t)=>t.split("").reduce((e, r, i, n)=>{
            let o = r === '"' && n[i - 1] !== "\\", s = r === "\\" && n[i + 1] === '"';
            return o || s ? e : e + r;
        }, ""), "removeQuotes"), aE = a((t)=>t != null ? t.toLowerCase() : null, "lower"), vp = a((t, e, r)=>[
            aE(t),
            e,
            aE(r)
        ].filter((i)=>i != null).join("."), "getPath"), lE = a((t)=>{
        let e = t.split("."), r = e.shift(), i = e.pop(), n = e.length ? e.join(".") : void 0;
        return {
            section: r,
            subsection: n,
            name: i,
            path: vp(r, n, i),
            sectionPath: vp(r, n, null),
            isSection: !!r
        };
    }, "normalizePath"), uL = a((t, e)=>t.reduce((r, i, n)=>e(i) ? n : r, -1), "findLastIndex"), Sc = class Sc {
        static from(e) {
            return new Sc(e);
        }
        async get(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            let i = lE(e).path, n = this.parsedConfig.filter((o)=>o.path === i).map((param)=>{
                let { section: o, name: s, value: l } = param;
                let f = oE[o] && oE[o][s];
                return f ? f(l) : l;
            });
            return r ? n : n.pop();
        }
        async getall(e) {
            return this.get(e, !0);
        }
        async getSubsections(e) {
            return this.parsedConfig.filter((r)=>r.isSection && r.section === e).map((r)=>r.subsection);
        }
        async deleteSection(e, r) {
            this.parsedConfig = this.parsedConfig.filter((i)=>!(i.section === e && i.subsection === r));
        }
        async append(e, r) {
            return this.set(e, r, !0);
        }
        async set(e, r) {
            let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
            let { section: n, subsection: o, name: s, path: l, sectionPath: f, isSection: c } = lE(e), u = uL(this.parsedConfig, (h)=>h.path === l);
            if (r == null) u !== -1 && this.parsedConfig.splice(u, 1);
            else if (u !== -1) {
                let h = this.parsedConfig[u], d = Object.assign({}, h, {
                    name: s,
                    value: r,
                    modified: !0
                });
                i ? this.parsedConfig.splice(u + 1, 0, d) : this.parsedConfig[u] = d;
            } else {
                let h = this.parsedConfig.findIndex((p)=>p.path === f), d = {
                    section: n,
                    subsection: o,
                    name: s,
                    value: r,
                    modified: !0,
                    path: l
                };
                if (iL.test(n) && oL.test(s)) if (h >= 0) this.parsedConfig.splice(h + 1, 0, d);
                else {
                    let p = {
                        isSection: c,
                        section: n,
                        subsection: o,
                        modified: !0,
                        path: f
                    };
                    this.parsedConfig.push(p, d);
                }
            }
        }
        toString() {
            return this.parsedConfig.map((param)=>{
                let { line: e, section: r, subsection: i, name: n, value: o, modified: s = !1 } = param;
                return s ? n != null && o != null ? typeof o == "string" && /[#;]/.test(o) ? "	".concat(n, ' = "').concat(o, '"') : "	".concat(n, " = ").concat(o) : i != null ? "[".concat(r, ' "').concat(i, '"]') : "[".concat(r, "]") : e;
            }).join("\n");
        }
        constructor(e){
            let r = null, i = null;
            this.parsedConfig = e ? e.split("\n").map((n)=>{
                let o = null, s = null, l = n.trim(), f = aL(l), c = f != null;
                if (c) [r, i] = f;
                else {
                    let h = lL(l);
                    h != null && ([o, s] = h);
                }
                let u = vp(r, i, o);
                return {
                    line: n,
                    isSection: c,
                    section: r,
                    subsection: i,
                    name: o,
                    value: s,
                    path: u
                };
            }) : [];
        }
    };
    a(Sc, "GitConfig");
    var _p = Sc, Mp = class Mp {
        static async get(param) {
            let { fs: e, gitdir: r } = param;
            let i = await e.read("".concat(r, "/config"), {
                encoding: "utf8"
            });
            return _p.from(i);
        }
        static async save(param) {
            let { fs: e, gitdir: r, config: i } = param;
            await e.write("".concat(r, "/config"), i.toString(), {
                encoding: "utf8"
            });
        }
    };
    a(Mp, "GitConfigManager");
    var be = Mp, tc = a((t)=>[
            "".concat(t),
            "refs/".concat(t),
            "refs/tags/".concat(t),
            "refs/heads/".concat(t),
            "refs/remotes/".concat(t),
            "refs/remotes/".concat(t, "/HEAD")
        ], "refpaths"), hL = [
        "config",
        "description",
        "index",
        "shallow",
        "commondir"
    ], lp;
    async function Hr(t, e) {
        return lp === void 0 && (lp = new hs), lp.acquire(t, e);
    }
    a(Hr, "acquireLock");
    var Te = class Te {
        static async updateRemoteRefs(param) {
            let { fs: e, gitdir: r, remote: i, refs: n, symrefs: o, tags: s, refspecs: l = void 0, prune: f = !1, pruneTags: c = !1 } = param;
            for (let w of n.values())if (!w.match(/[0-9a-f]{40}/)) throw new Vr(w);
            let u = await be.get({
                fs: e,
                gitdir: r
            });
            if (!l) {
                if (l = await u.getall("remote.".concat(i, ".fetch")), l.length === 0) throw new ys(i);
                l.unshift("+HEAD:refs/remotes/".concat(i, "/HEAD"));
            }
            let h = bp.from(l), d = new Map;
            if (c) {
                let w = await Te.listRefs({
                    fs: e,
                    gitdir: r,
                    filepath: "refs/tags"
                });
                await Te.deleteRefs({
                    fs: e,
                    gitdir: r,
                    refs: w.map((v)=>"refs/tags/".concat(v))
                });
            }
            if (s) {
                for (let w of n.keys())if (w.startsWith("refs/tags") && !w.endsWith("^{}") && !await Te.exists({
                    fs: e,
                    gitdir: r,
                    ref: w
                })) {
                    let v = n.get(w);
                    d.set(w, v);
                }
            }
            let p = h.translate([
                ...n.keys()
            ]);
            for (let [w, v] of p){
                let g = n.get(w);
                d.set(v, g);
            }
            let m = h.translate([
                ...o.keys()
            ]);
            for (let [w, v] of m){
                let g = o.get(w), F = h.translateOne(g);
                F && d.set(v, "ref: ".concat(F));
            }
            let y = [];
            if (f) {
                for (let w of h.localNamespaces()){
                    let v = (await Te.listRefs({
                        fs: e,
                        gitdir: r,
                        filepath: w
                    })).map((g)=>"".concat(w, "/").concat(g));
                    for (let g of v)d.has(g) || y.push(g);
                }
                y.length > 0 && await Te.deleteRefs({
                    fs: e,
                    gitdir: r,
                    refs: y
                });
            }
            for (let [w, v] of d)await Hr(w, async ()=>e.write(D.join(r, w), "".concat(v.trim(), "\n"), "utf8"));
            return {
                pruned: y
            };
        }
        static async writeRef(param) {
            let { fs: e, gitdir: r, ref: i, value: n } = param;
            if (!n.match(/[0-9a-f]{40}/)) throw new Vr(n);
            await Hr(i, async ()=>e.write(D.join(r, i), "".concat(n.trim(), "\n"), "utf8"));
        }
        static async writeSymbolicRef(param) {
            let { fs: e, gitdir: r, ref: i, value: n } = param;
            await Hr(i, async ()=>e.write(D.join(r, i), "ref: ".concat(n.trim(), "\n"), "utf8"));
        }
        static async deleteRef(param) {
            let { fs: e, gitdir: r, ref: i } = param;
            return Te.deleteRefs({
                fs: e,
                gitdir: r,
                refs: [
                    i
                ]
            });
        }
        static async deleteRefs(param) {
            let { fs: e, gitdir: r, refs: i } = param;
            await Promise.all(i.map((l)=>e.rm(D.join(r, l))));
            let n = await Hr("packed-refs", async ()=>e.read("".concat(r, "/packed-refs"), {
                    encoding: "utf8"
                })), o = oc.from(n), s = o.refs.size;
            for (let l of i)o.refs.has(l) && o.delete(l);
            o.refs.size < s && (n = o.toString(), await Hr("packed-refs", async ()=>e.write("".concat(r, "/packed-refs"), n, {
                    encoding: "utf8"
                })));
        }
        static async resolve(param) {
            let { fs: e, gitdir: r, ref: i, depth: n = void 0 } = param;
            if (n !== void 0 && (n--, n === -1)) return i;
            if (i.startsWith("ref: ")) return i = i.slice(5), Te.resolve({
                fs: e,
                gitdir: r,
                ref: i,
                depth: n
            });
            if (i.length === 40 && /[0-9a-f]{40}/.test(i)) return i;
            let o = await Te.packedRefs({
                fs: e,
                gitdir: r
            }), s = tc(i).filter((l)=>!hL.includes(l));
            for (let l of s){
                let f = await Hr(l, async ()=>await e.read("".concat(r, "/").concat(l), {
                        encoding: "utf8"
                    }) || o.get(l));
                if (f) return Te.resolve({
                    fs: e,
                    gitdir: r,
                    ref: f.trim(),
                    depth: n
                });
            }
            throw new ce(i);
        }
        static async exists(param) {
            let { fs: e, gitdir: r, ref: i } = param;
            try {
                return await Te.expand({
                    fs: e,
                    gitdir: r,
                    ref: i
                }), !0;
            } catch (e) {
                return !1;
            }
        }
        static async expand(param) {
            let { fs: e, gitdir: r, ref: i } = param;
            if (i.length === 40 && /[0-9a-f]{40}/.test(i)) return i;
            let n = await Te.packedRefs({
                fs: e,
                gitdir: r
            }), o = tc(i);
            for (let s of o)if (await Hr(s, async ()=>e.exists("".concat(r, "/").concat(s))) || n.has(s)) return s;
            throw new ce(i);
        }
        static async expandAgainstMap(param) {
            let { ref: e, map: r } = param;
            let i = tc(e);
            for (let n of i)if (await r.has(n)) return n;
            throw new ce(e);
        }
        static resolveAgainstMap(param) {
            let { ref: e, fullref: r = e, depth: i = void 0, map: n } = param;
            if (i !== void 0 && (i--, i === -1)) return {
                fullref: r,
                oid: e
            };
            if (e.startsWith("ref: ")) return e = e.slice(5), Te.resolveAgainstMap({
                ref: e,
                fullref: r,
                depth: i,
                map: n
            });
            if (e.length === 40 && /[0-9a-f]{40}/.test(e)) return {
                fullref: r,
                oid: e
            };
            let o = tc(e);
            for (let s of o){
                let l = n.get(s);
                if (l) return Te.resolveAgainstMap({
                    ref: l.trim(),
                    fullref: s,
                    depth: i,
                    map: n
                });
            }
            throw new ce(e);
        }
        static async packedRefs(param) {
            let { fs: e, gitdir: r } = param;
            let i = await Hr("packed-refs", async ()=>e.read("".concat(r, "/packed-refs"), {
                    encoding: "utf8"
                }));
            return oc.from(i).refs;
        }
        static async listRefs(param) {
            let { fs: e, gitdir: r, filepath: i } = param;
            let n = Te.packedRefs({
                fs: e,
                gitdir: r
            }), o = null;
            try {
                o = await e.readdirDeep("".concat(r, "/").concat(i)), o = o.map((s)=>s.replace("".concat(r, "/").concat(i, "/"), ""));
            } catch (e) {
                o = [];
            }
            for (let s of (await n).keys())s.startsWith(i) && (s = s.replace(i + "/", ""), o.includes(s) || o.push(s));
            return o.sort(eL), o;
        }
        static async listBranches(param) {
            let { fs: e, gitdir: r, remote: i } = param;
            return i ? Te.listRefs({
                fs: e,
                gitdir: r,
                filepath: "refs/remotes/".concat(i)
            }) : Te.listRefs({
                fs: e,
                gitdir: r,
                filepath: "refs/heads"
            });
        }
        static async listTags(param) {
            let { fs: e, gitdir: r } = param;
            return (await Te.listRefs({
                fs: e,
                gitdir: r,
                filepath: "refs/tags"
            })).filter((n)=>!n.endsWith("^{}"));
        }
    };
    a(Te, "GitRefManager");
    var B = Te;
    function dL(t, e) {
        return Jc(cE(t), cE(e));
    }
    a(dL, "compareTreeEntryPath");
    function cE(t) {
        return t.mode === "040000" ? t.path + "/" : t.path;
    }
    a(cE, "appendSlashIfDir");
    function AE(t) {
        switch(t){
            case "040000":
                return "tree";
            case "100644":
                return "blob";
            case "100755":
                return "blob";
            case "120000":
                return "blob";
            case "160000":
                return "commit";
        }
        throw new W("Unexpected GitTree entry mode: ".concat(t));
    }
    a(AE, "mode2type$1");
    function pL(t) {
        let e = [], r = 0;
        for(; r < t.length;){
            let i = t.indexOf(32, r);
            if (i === -1) throw new W("GitTree: Error parsing buffer at byte location ".concat(r, ": Could not find the next space character."));
            let n = t.indexOf(0, r);
            if (n === -1) throw new W("GitTree: Error parsing buffer at byte location ".concat(r, ": Could not find the next null character."));
            let o = t.slice(r, i).toString("utf8");
            o === "40000" && (o = "040000");
            let s = AE(o), l = t.slice(i + 1, n).toString("utf8");
            if (l.includes("\\") || l.includes("/")) throw new Ln(l);
            let f = t.slice(n + 1, n + 21).toString("hex");
            r = n + 21, e.push({
                mode: o,
                path: l,
                oid: f,
                type: s
            });
        }
        return e;
    }
    a(pL, "parseBuffer");
    function mL(t) {
        if (typeof t == "number" && (t = t.toString(8)), t.match(/^0?4.*/)) return "040000";
        if (t.match(/^1006.*/)) return "100644";
        if (t.match(/^1007.*/)) return "100755";
        if (t.match(/^120.*/)) return "120000";
        if (t.match(/^160.*/)) return "160000";
        throw new W("Could not understand file mode: ".concat(t));
    }
    a(mL, "limitModeToAllowed");
    function yL(t) {
        return !t.oid && t.sha && (t.oid = t.sha), t.mode = mL(t.mode), t.type || (t.type = AE(t.mode)), t;
    }
    a(yL, "nudgeIntoShape");
    var xc = class xc {
        static from(e) {
            return new xc(e);
        }
        render() {
            return this._entries.map((e)=>"".concat(e.mode, " ").concat(e.type, " ").concat(e.oid, "    ").concat(e.path)).join("\n");
        }
        toObject() {
            let e = [
                ...this._entries
            ];
            return e.sort(dL), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(e.map((r)=>{
                let i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(r.mode.replace(/^0/, "")), n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(" "), o = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(r.path, "utf8"), s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from([
                    0
                ]), l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(r.oid, "hex");
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
                    i,
                    n,
                    o,
                    s,
                    l
                ]);
            }));
        }
        entries() {
            return this._entries;
        }
        *[Symbol.iterator]() {
            for (let e of this._entries)yield e;
        }
        constructor(e){
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(e)) this._entries = pL(e);
            else if (Array.isArray(e)) this._entries = e.map(yL);
            else throw new W("invalid type passed to GitTree constructor");
            this._entries.sort(OE);
        }
    };
    a(xc, "GitTree");
    var et = xc, jp = class jp {
        static wrap(param) {
            let { type: e, object: r } = param;
            let i = "".concat(e, " ").concat(r.length, "\0"), n = i.length, o = n + r.length, s = new Uint8Array(o);
            for(let l = 0; l < n; l++)s[l] = i.charCodeAt(l);
            return s.set(r, n), s;
        }
        static unwrap(e) {
            let r = e.indexOf(32), i = e.indexOf(0), n = e.slice(0, r).toString("utf8"), o = e.slice(r + 1, i).toString("utf8"), s = e.length - (i + 1);
            if (parseInt(o) !== s) throw new W("Length mismatch: expected ".concat(o, " bytes but got ").concat(s, " instead."));
            return {
                type: n,
                object: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e.slice(i + 1))
            };
        }
    };
    a(jp, "GitObject");
    var Gr = jp;
    async function IE(param) {
        let { fs: t, gitdir: e, oid: r } = param;
        let i = "objects/".concat(r.slice(0, 2), "/").concat(r.slice(2)), n = await t.read("".concat(e, "/").concat(i));
        return n ? {
            object: n,
            format: "deflated",
            source: i
        } : null;
    }
    a(IE, "readObjectLoose");
    function wL(t, e) {
        let r = new Et(t), i = fE(r);
        if (i !== e.byteLength) throw new W("applyDelta expected source buffer to be ".concat(i, " bytes but the provided buffer was ").concat(e.length, " bytes"));
        let n = fE(r), o, s = hE(r, e);
        if (s.byteLength === n) o = s;
        else {
            o = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(n);
            let l = new Et(o);
            for(l.copy(s); !r.eof();)l.copy(hE(r, e));
            let f = l.tell();
            if (n !== f) throw new W("applyDelta expected target buffer to be ".concat(n, " bytes but the resulting buffer was ").concat(f, " bytes"));
        }
        return o;
    }
    a(wL, "applyDelta");
    function fE(t) {
        let e = 0, r = 0, i = null;
        do i = t.readUInt8(), e |= (i & 127) << r, r += 7;
        while (i & 128)
        return e;
    }
    a(fE, "readVarIntLE");
    function uE(t, e, r) {
        let i = 0, n = 0;
        for(; r--;)e & 1 && (i |= t.readUInt8() << n), e >>= 1, n += 8;
        return i;
    }
    a(uE, "readCompactLE");
    function hE(t, e) {
        let r = t.readUInt8(), i = 128, n = 15, o = 112;
        if (r & i) {
            let s = uE(t, r & n, 4), l = uE(t, (r & o) >> 4, 3);
            return l === 0 && (l = 65536), e.slice(s, s + l);
        } else return t.slice(r);
    }
    a(hE, "readOp");
    function gL(t) {
        let e = [
            t
        ];
        return {
            next () {
                return Promise.resolve({
                    done: e.length === 0,
                    value: e.pop()
                });
            },
            return () {
                return e = [], {};
            },
            [Symbol.asyncIterator] () {
                return this;
            }
        };
    }
    a(gL, "fromValue");
    function DE(t) {
        return t[Symbol.asyncIterator] ? t[Symbol.asyncIterator]() : t[Symbol.iterator] ? t[Symbol.iterator]() : t.next ? t : gL(t);
    }
    a(DE, "getIterator");
    var Up = class Up {
        eof() {
            return this._ended && this.cursor === this.buffer.length;
        }
        tell() {
            return this._discardedBytes + this.cursor;
        }
        async byte() {
            if (!this.eof() && (this.started || await this._init(), !(this.cursor === this.buffer.length && (await this._loadnext(), this._ended)))) return this._moveCursor(1), this.buffer[this.undoCursor];
        }
        async chunk() {
            if (!this.eof() && (this.started || await this._init(), !(this.cursor === this.buffer.length && (await this._loadnext(), this._ended)))) return this._moveCursor(this.buffer.length), this.buffer.slice(this.undoCursor, this.cursor);
        }
        async read(e) {
            if (!this.eof()) return this.started || await this._init(), this.cursor + e > this.buffer.length && (this._trim(), await this._accumulate(e)), this._moveCursor(e), this.buffer.slice(this.undoCursor, this.cursor);
        }
        async skip(e) {
            this.eof() || (this.started || await this._init(), this.cursor + e > this.buffer.length && (this._trim(), await this._accumulate(e)), this._moveCursor(e));
        }
        async undo() {
            this.cursor = this.undoCursor;
        }
        async _next() {
            this.started = !0;
            let { done: e, value: r } = await this.stream.next();
            return e && (this._ended = !0, !r) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(0) : (r && (r = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(r)), r);
        }
        _trim() {
            this.buffer = this.buffer.slice(this.undoCursor), this.cursor -= this.undoCursor, this._discardedBytes += this.undoCursor, this.undoCursor = 0;
        }
        _moveCursor(e) {
            this.undoCursor = this.cursor, this.cursor += e, this.cursor > this.buffer.length && (this.cursor = this.buffer.length);
        }
        async _accumulate(e) {
            if (this._ended) return;
            let r = [
                this.buffer
            ];
            for(; this.cursor + e > bL(r);){
                let i = await this._next();
                if (this._ended) break;
                r.push(i);
            }
            this.buffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(r);
        }
        async _loadnext() {
            this._discardedBytes += this.buffer.length, this.undoCursor = 0, this.cursor = 0, this.buffer = await this._next();
        }
        async _init() {
            this.buffer = await this._next();
        }
        constructor(e){
            if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] > "u") throw new Error("Missing Buffer dependency");
            this.stream = DE(e), this.buffer = null, this.cursor = 0, this.undoCursor = 0, this.started = !1, this._ended = !1, this._discardedBytes = 0;
        }
    };
    a(Up, "StreamReader");
    var ac = Up;
    function bL(t) {
        return t.reduce((e, r)=>e + r.length, 0);
    }
    a(bL, "lengthBuffers");
    async function vL(t, e) {
        let r = new ac(t), i = await r.read(4);
        if (i = i.toString("utf8"), i !== "PACK") throw new W("Invalid PACK header '".concat(i, "'"));
        let n = await r.read(4);
        if (n = n.readUInt32BE(0), n !== 2) throw new W("Invalid packfile version: ".concat(n));
        let o = await r.read(4);
        if (o = o.readUInt32BE(0), !(o < 1)) for(; !r.eof() && o--;){
            let s = r.tell(), { type: l, length: f, ofs: c, reference: u } = await _L(r), h = new kp.Inflate;
            for(; !h.result;){
                let d = await r.chunk();
                if (!d) break;
                if (h.push(d, !1), h.err) throw new W("Pako error: ".concat(h.msg));
                if (h.result) {
                    if (h.result.length !== f) throw new W("Inflated object size is different from that stated in packfile.");
                    await r.undo(), await r.read(d.length - h.strm.avail_in);
                    let p = r.tell();
                    await e({
                        data: h.result,
                        type: l,
                        num: o,
                        offset: s,
                        end: p,
                        reference: u,
                        ofs: c
                    });
                }
            }
        }
    }
    a(vL, "listpack");
    async function _L(t) {
        let e = await t.byte(), r = e >> 4 & 7, i = e & 15;
        if (e & 128) {
            let s = 4;
            do e = await t.byte(), i |= (e & 127) << s, s += 7;
            while (e & 128)
        }
        let n, o;
        if (r === 6) {
            let s = 0;
            n = 0;
            let l = [];
            do e = await t.byte(), n |= (e & 127) << s, s += 7, l.push(e);
            while (e & 128)
            o = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(l);
        }
        return r === 7 && (o = await t.read(20)), {
            type: r,
            length: i,
            ofs: n,
            reference: o
        };
    }
    a(_L, "parseHeader");
    var cp = !1;
    async function CE(t) {
        return cp === null && (cp = EL()), cp ? FL(t) : kp.inflate(t);
    }
    a(CE, "inflate");
    async function FL(t) {
        let e = new DecompressionStream("deflate"), r = new Blob([
            t
        ]).stream().pipeThrough(e);
        return new Uint8Array(await new Response(r).arrayBuffer());
    }
    a(FL, "browserInflate");
    function EL() {
        try {
            if (new DecompressionStream("deflate")) return !0;
        } catch (e) {}
        return !1;
    }
    a(EL, "testDecompressionStream");
    function SL(t) {
        let e = [], r = 0, i = 0;
        do {
            r = t.readUInt8();
            let n = r & 127;
            e.push(n), i = r & 128;
        }while (i)
        return e.reduce((n, o)=>n + 1 << 7 | o, -1);
    }
    a(SL, "decodeVarInt");
    function xL(t, e) {
        let r = e, i = 4, n = null;
        do n = t.readUInt8(), r |= (n & 127) << i, i += 7;
        while (n & 128)
        return r;
    }
    a(xL, "otherVarIntDecode");
    var us = class us {
        static async fromIdx(param) {
            let { idx: e, getExternalRefDelta: r } = param;
            let i = new Et(e);
            if (i.slice(4).toString("hex") !== "ff744f63") return;
            let o = i.readUInt32BE();
            if (o !== 2) throw new W("Unable to read version ".concat(o, " packfile IDX. (Only version 2 supported)"));
            if (e.byteLength > 2048 * 1024 * 1024) throw new W("To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.");
            i.seek(i.tell() + 4 * 255);
            let s = i.readUInt32BE(), l = [];
            for(let u = 0; u < s; u++){
                let h = i.slice(20).toString("hex");
                l[u] = h;
            }
            i.seek(i.tell() + 4 * s);
            let f = new Map;
            for(let u = 0; u < s; u++)f.set(l[u], i.readUInt32BE());
            let c = i.slice(20).toString("hex");
            return new us({
                hashes: l,
                crcs: {},
                offsets: f,
                packfileSha: c,
                getExternalRefDelta: r
            });
        }
        static async fromPack(param) {
            let { pack: e, getExternalRefDelta: r, onProgress: i } = param;
            let n = {
                1: "commit",
                2: "tree",
                3: "blob",
                4: "tag",
                6: "ofs-delta",
                7: "ref-delta"
            }, o = {}, s = e.slice(-20).toString("hex"), l = [], f = {}, c = new Map, u = null, h = null;
            await vL([
                e
            ], async (param)=>{
                let { data: w, type: v, reference: g, offset: F, num: O } = param;
                u === null && (u = O);
                let S = Math.floor((u - O) * 100 / u);
                S !== h && i && await i({
                    phase: "Receiving objects",
                    loaded: u - O,
                    total: u
                }), h = S, v = n[v], [
                    "commit",
                    "tree",
                    "blob",
                    "tag"
                ].includes(v) ? o[F] = {
                    type: v,
                    offset: F
                } : v === "ofs-delta" ? o[F] = {
                    type: v,
                    offset: F
                } : v === "ref-delta" && (o[F] = {
                    type: v,
                    offset: F
                });
            });
            let d = Object.keys(o).map(Number);
            for (let [w, v] of d.entries()){
                let g = w + 1 === d.length ? e.byteLength - 20 : d[w + 1], F = o[v], O = qB.buf(e.slice(v, g)) >>> 0;
                F.end = g, F.crc = O;
            }
            let p = new us({
                pack: Promise.resolve(e),
                packfileSha: s,
                crcs: f,
                hashes: l,
                offsets: c,
                getExternalRefDelta: r
            });
            h = null;
            let m = 0, y = [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ];
            for(let w in o){
                w = Number(w);
                let v = Math.floor(m * 100 / u);
                v !== h && i && await i({
                    phase: "Resolving deltas",
                    loaded: m,
                    total: u
                }), m++, h = v;
                let g = o[w];
                if (!g.oid) try {
                    p.readDepth = 0, p.externalReadDepth = 0;
                    let { type: F, object: O } = await p.readSlice({
                        start: w
                    });
                    y[p.readDepth] += 1;
                    let S = await gr(Gr.wrap({
                        type: F,
                        object: O
                    }));
                    g.oid = S, l.push(S), c.set(S, w), f[S] = g.crc;
                } catch (e) {
                    continue;
                }
            }
            return l.sort(), p;
        }
        async toBuffer() {
            let e = [], r = a((c, u)=>{
                e.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(c, u));
            }, "write");
            r("ff744f63", "hex"), r("00000002", "hex");
            let i = new Et(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(256 * 4));
            for(let c = 0; c < 256; c++){
                let u = 0;
                for (let h of this.hashes)parseInt(h.slice(0, 2), 16) <= c && u++;
                i.writeUInt32BE(u);
            }
            e.push(i.buffer);
            for (let c of this.hashes)r(c, "hex");
            let n = new Et(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(this.hashes.length * 4));
            for (let c of this.hashes)n.writeUInt32BE(this.crcs[c]);
            e.push(n.buffer);
            let o = new Et(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(this.hashes.length * 4));
            for (let c of this.hashes)o.writeUInt32BE(this.offsets.get(c));
            e.push(o.buffer), r(this.packfileSha, "hex");
            let s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(e), l = await gr(s), f = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(20);
            return f.write(l, "hex"), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
                s,
                f
            ]);
        }
        async load(param) {
            let { pack: e } = param;
            this.pack = e;
        }
        async unload() {
            this.pack = null;
        }
        async read(param) {
            let { oid: e } = param;
            if (!this.offsets.get(e)) {
                if (this.getExternalRefDelta) return this.externalReadDepth++, this.getExternalRefDelta(e);
                throw new W("Could not read object ".concat(e, " from packfile"));
            }
            let r = this.offsets.get(e);
            return this.readSlice({
                start: r
            });
        }
        async readSlice(param) {
            let { start: e } = param;
            if (this.offsetCache[e]) return Object.assign({}, this.offsetCache[e]);
            this.readDepth++;
            let r = {
                16: "commit",
                32: "tree",
                48: "blob",
                64: "tag",
                96: "ofs_delta",
                112: "ref_delta"
            };
            if (!this.pack) throw new W("Tried to read from a GitPackIndex with no packfile loaded into memory");
            let i = (await this.pack).slice(e), n = new Et(i), o = n.readUInt8(), s = o & 112, l = r[s];
            if (l === void 0) throw new W("Unrecognized type: 0b" + s.toString(2));
            let f = o & 15, c = f;
            o & 128 && (c = xL(n, f));
            let h = null, d = null;
            if (l === "ofs_delta") {
                let m = SL(n), y = e - m;
                ({ object: h, type: l } = await this.readSlice({
                    start: y
                }));
            }
            if (l === "ref_delta") {
                let m = n.slice(20).toString("hex");
                ({ object: h, type: l } = await this.read({
                    oid: m
                }));
            }
            let p = i.slice(n.tell());
            if (d = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(await CE(p)), d.byteLength !== c) throw new W("Packfile told us object would have length ".concat(c, " but it had length ").concat(d.byteLength));
            return h && (d = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(wL(d, h))), this.readDepth > 3 && (this.offsetCache[e] = {
                type: l,
                object: d
            }), {
                type: l,
                format: "content",
                object: d
            };
        }
        constructor(e){
            Object.assign(this, e), this.offsetCache = {};
        }
    };
    a(us, "GitPackIndex");
    var ws = us, rc = Symbol("PackfileCache");
    async function TL(param) {
        let { fs: t, filename: e, getExternalRefDelta: r, emitter: i, emitterPrefix: n } = param;
        let o = await t.read(e);
        return ws.fromIdx({
            idx: o,
            getExternalRefDelta: r
        });
    }
    a(TL, "loadPackIndex");
    function Pp(param) {
        let { fs: t, cache: e, filename: r, getExternalRefDelta: i, emitter: n, emitterPrefix: o } = param;
        e[rc] || (e[rc] = new Map);
        let s = e[rc].get(r);
        return s || (s = TL({
            fs: t,
            filename: r,
            getExternalRefDelta: i,
            emitter: n,
            emitterPrefix: o
        }), e[rc].set(r, s)), s;
    }
    a(Pp, "readPackIndex");
    async function OL(param) {
        let { fs: t, cache: e, gitdir: r, oid: i, format: n = "content", getExternalRefDelta: o } = param;
        let s = await t.readdir(D.join(r, "objects/pack"));
        s = s.filter((l)=>l.endsWith(".idx"));
        for (let l of s){
            let f = "".concat(r, "/objects/pack/").concat(l), c = await Pp({
                fs: t,
                cache: e,
                filename: f,
                getExternalRefDelta: o
            });
            if (c.error) throw new W(c.error);
            if (c.offsets.has(i)) {
                if (!c.pack) {
                    let h = f.replace(/idx$/, "pack");
                    c.pack = t.read(h);
                }
                let u = await c.read({
                    oid: i,
                    getExternalRefDelta: o
                });
                return u.format = "content", u.source = "objects/pack/".concat(l.replace(/idx$/, "pack")), u;
            }
        }
        return null;
    }
    a(OL, "readObjectPacked");
    async function de(param) {
        let { fs: t, cache: e, gitdir: r, oid: i, format: n = "content" } = param;
        let o = a((u)=>de({
                fs: t,
                cache: e,
                gitdir: r,
                oid: u
            }), "getExternalRefDelta"), s;
        if (i === "4b825dc642cb6eb9a060e54bf8d69288fbee4904" && (s = {
            format: "wrapped",
            object: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from("tree 0\0")
        }), s || (s = await IE({
            fs: t,
            gitdir: r,
            oid: i
        })), !s) {
            if (s = await OL({
                fs: t,
                cache: e,
                gitdir: r,
                oid: i,
                getExternalRefDelta: o
            }), !s) throw new ce(i);
            return s;
        }
        if (n === "deflated" || (s.format === "deflated" && (s.object = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(await CE(s.object)), s.format = "wrapped"), n === "wrapped")) return s;
        let l = await gr(s.object);
        if (l !== i) throw new W("SHA check failed! Expected ".concat(i, ", computed ").concat(l));
        let { object: f, type: c } = Gr.unwrap(s.object);
        if (s.type = c, s.object = f, s.format = "content", n === "content") return s;
        throw new W('invalid requested format "'.concat(n, '"'));
    }
    a(de, "_readObject");
    var Tc = class Tc extends re {
        constructor(e, r, i = !0){
            super("Failed to create ".concat(e, " at ").concat(r, " because it already exists.").concat(i ? " (Hint: use 'force: true' parameter to overwrite existing ".concat(e, ".)") : "")), this.code = this.name = Tc.code, this.data = {
                noun: e,
                where: r,
                canForce: i
            };
        }
    };
    a(Tc, "AlreadyExistsError");
    var Ct = Tc;
    Ct.code = "AlreadyExistsError";
    var Oc = class Oc extends re {
        constructor(e, r, i){
            super("Found multiple ".concat(e, ' matching "').concat(r, '" (').concat(i.join(", "), "). Use a longer abbreviation length to disambiguate them.")), this.code = this.name = Oc.code, this.data = {
                nouns: e,
                short: r,
                matches: i
            };
        }
    };
    a(Oc, "AmbiguousError");
    var gs = Oc;
    gs.code = "AmbiguousError";
    var Rc = class Rc extends re {
        constructor(e){
            super("Your local changes to the following files would be overwritten by checkout: ".concat(e.join(", "))), this.code = this.name = Rc.code, this.data = {
                filepaths: e
            };
        }
    };
    a(Rc, "CheckoutConflictError");
    var bs = Rc;
    bs.code = "CheckoutConflictError";
    var kc = class kc extends re {
        constructor(e, r){
            super('Failed to checkout "'.concat(e, '" because commit ').concat(r, " is not available locally. Do a git fetch to make the branch available locally.")), this.code = this.name = kc.code, this.data = {
                ref: e,
                oid: r
            };
        }
    };
    a(kc, "CommitNotFetchedError");
    var vs = kc;
    vs.code = "CommitNotFetchedError";
    var Pc = class Pc extends re {
        constructor(){
            super("Empty response from git server."), this.code = this.name = Pc.code, this.data = {};
        }
    };
    a(Pc, "EmptyServerResponseError");
    var _s = Pc;
    _s.code = "EmptyServerResponseError";
    var Ac = class Ac extends re {
        constructor(){
            super("A simple fast-forward merge was not possible."), this.code = this.name = Ac.code, this.data = {};
        }
    };
    a(Ac, "FastForwardError");
    var Fs = Ac;
    Fs.code = "FastForwardError";
    var Ic = class Ic extends re {
        constructor(e, r){
            super("One or more branches were not updated: ".concat(e)), this.code = this.name = Ic.code, this.data = {
                prettyDetails: e,
                result: r
            };
        }
    };
    a(Ic, "GitPushError");
    var Es = Ic;
    Es.code = "GitPushError";
    var Dc = class Dc extends re {
        constructor(e, r, i){
            super("HTTP Error: ".concat(e, " ").concat(r)), this.code = this.name = Dc.code, this.data = {
                statusCode: e,
                statusMessage: r,
                response: i
            };
        }
    };
    a(Dc, "HttpError");
    var jn = Dc;
    jn.code = "HttpError";
    var Cc = class Cc extends re {
        constructor(e){
            let r = "invalid filepath";
            e === "leading-slash" || e === "trailing-slash" ? r = '"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.' : e === "directory" && (r = '"filepath" should not be a directory.'), super(r), this.code = this.name = Cc.code, this.data = {
                reason: e
            };
        }
    };
    a(Cc, "InvalidFilepathError");
    var Kr = Cc;
    Kr.code = "InvalidFilepathError";
    var Nc = class Nc extends re {
        constructor(e, r){
            super('"'.concat(e, '" would be an invalid git reference. (Hint: a valid alternative would be "').concat(r, '".)')), this.code = this.name = Nc.code, this.data = {
                ref: e,
                suggestion: r
            };
        }
    };
    a(Nc, "InvalidRefNameError");
    var Nt = Nc;
    Nt.code = "InvalidRefNameError";
    var Bc = class Bc extends re {
        constructor(e){
            super("Maximum search depth of ".concat(e, " exceeded.")), this.code = this.name = Bc.code, this.data = {
                depth: e
            };
        }
    };
    a(Bc, "MaxDepthError");
    var Ss = Bc;
    Ss.code = "MaxDepthError";
    var Lc = class Lc extends re {
        constructor(){
            super("Merges with conflicts are not supported yet."), this.code = this.name = Lc.code, this.data = {};
        }
    };
    a(Lc, "MergeNotSupportedError");
    var Un = Lc;
    Un.code = "MergeNotSupportedError";
    var $c = class $c extends re {
        constructor(e, r, i, n){
            super("Automatic merge failed with one or more merge conflicts in the following files: ".concat(e.toString(), ". Fix conflicts then commit the result.")), this.code = this.name = $c.code, this.data = {
                filepaths: e,
                bothModified: r,
                deleteByUs: i,
                deleteByTheirs: n
            };
        }
    };
    a($c, "MergeConflictError");
    var qn = $c;
    qn.code = "MergeConflictError";
    var Mc = class Mc extends re {
        constructor(e){
            super("No name was provided for ".concat(e, " in the argument or in the .git/config file.")), this.code = this.name = Mc.code, this.data = {
                role: e
            };
        }
    };
    a(Mc, "MissingNameError");
    var He = Mc;
    He.code = "MissingNameError";
    var jc = class jc extends re {
        constructor(e){
            super('The function requires a "'.concat(e, '" parameter but none was provided.')), this.code = this.name = jc.code, this.data = {
                parameter: e
            };
        }
    };
    a(jc, "MissingParameterError");
    var Qe = jc;
    Qe.code = "MissingParameterError";
    var Uc = class Uc extends re {
        constructor(e){
            super('There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more'), this.code = this.name = Uc.code, this.data = {
                errors: e
            }, this.errors = e;
        }
    };
    a(Uc, "MultipleGitError");
    var xs = Uc;
    xs.code = "MultipleGitError";
    var qc = class qc extends re {
        constructor(e, r){
            super('Expected "'.concat(e, '" but received "').concat(r, '".')), this.code = this.name = qc.code, this.data = {
                expected: e,
                actual: r
            };
        }
    };
    a(qc, "ParseError");
    var Ri = qc;
    Ri.code = "ParseError";
    var Hc = class Hc extends re {
        constructor(e){
            let r = "";
            e === "not-fast-forward" ? r = " because it was not a simple fast-forward" : e === "tag-exists" && (r = " because tag already exists"), super("Push rejected".concat(r, '. Use "force: true" to override.')), this.code = this.name = Hc.code, this.data = {
                reason: e
            };
        }
    };
    a(Hc, "PushRejectedError");
    var Hn = Hc;
    Hn.code = "PushRejectedError";
    var zc = class zc extends re {
        constructor(e, r){
            super('Remote does not support the "'.concat(e, '" so the "').concat(r, '" parameter cannot be used.')), this.code = this.name = zc.code, this.data = {
                capability: e,
                parameter: r
            };
        }
    };
    a(zc, "RemoteCapabilityError");
    var Wr = zc;
    Wr.code = "RemoteCapabilityError";
    var Wc = class Wc extends re {
        constructor(e, r){
            super('Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: '.concat(e)), this.code = this.name = Wc.code, this.data = {
                preview: e,
                response: r
            };
        }
    };
    a(Wc, "SmartHttpError");
    var Ts = Wc;
    Ts.code = "SmartHttpError";
    var Vc = class Vc extends re {
        constructor(e, r, i){
            super('Git remote "'.concat(e, '" uses an unrecognized transport protocol: "').concat(r, '"')), this.code = this.name = Vc.code, this.data = {
                url: e,
                transport: r,
                suggestion: i
            };
        }
    };
    a(Vc, "UnknownTransportError");
    var Os = Vc;
    Os.code = "UnknownTransportError";
    var Gc = class Gc extends re {
        constructor(e){
            super('Cannot parse remote URL: "'.concat(e, '"')), this.code = this.name = Gc.code, this.data = {
                url: e
            };
        }
    };
    a(Gc, "UrlParseError");
    var Rs = Gc;
    Rs.code = "UrlParseError";
    var Kc = class Kc extends re {
        constructor(){
            super("The operation was canceled."), this.code = this.name = Kc.code, this.data = {};
        }
    };
    a(Kc, "UserCanceledError");
    var zn = Kc;
    zn.code = "UserCanceledError";
    var Zc = class Zc extends re {
        constructor(e){
            super("Could not merge index: Entry for '".concat(e, "' is not up to date. Either reset the index entry to HEAD, or stage your unstaged changes.")), this.code = this.name = Zc.code, this.data = {
                filepath: e
            };
        }
    };
    a(Zc, "IndexResetError");
    var ks = Zc;
    ks.code = "IndexResetError";
    var Xc = class Xc extends re {
        constructor(e){
            super('"'.concat(e, "\" does not point to any commit. You're maybe working on a repository with no commits yet. ")), this.code = this.name = Xc.code, this.data = {
                ref: e
            };
        }
    };
    a(Xc, "NoCommitError");
    var Ps = Xc;
    Ps.code = "NoCommitError";
    var NE = Object.freeze({
        __proto__: null,
        AlreadyExistsError: Ct,
        AmbiguousError: gs,
        CheckoutConflictError: bs,
        CommitNotFetchedError: vs,
        EmptyServerResponseError: _s,
        FastForwardError: Fs,
        GitPushError: Es,
        HttpError: jn,
        InternalError: W,
        InvalidFilepathError: Kr,
        InvalidOidError: Vr,
        InvalidRefNameError: Nt,
        MaxDepthError: Ss,
        MergeNotSupportedError: Un,
        MergeConflictError: qn,
        MissingNameError: He,
        MissingParameterError: Qe,
        MultipleGitError: xs,
        NoRefspecError: ys,
        NotFoundError: ce,
        ObjectTypeError: Ze,
        ParseError: Ri,
        PushRejectedError: Hn,
        RemoteCapabilityError: Wr,
        SmartHttpError: Ts,
        UnknownTransportError: Os,
        UnsafeFilepathError: Ln,
        UrlParseError: Rs,
        UserCanceledError: zn,
        UnmergedPathsError: ms,
        IndexResetError: ks,
        NoCommitError: Ps
    });
    function Fp(param) {
        let { name: t, email: e, timestamp: r, timezoneOffset: i } = param;
        return i = RL(i), "".concat(t, " <").concat(e, "> ").concat(r, " ").concat(i);
    }
    a(Fp, "formatAuthor");
    function RL(t) {
        let e = kL(PL(t));
        t = Math.abs(t);
        let r = Math.floor(t / 60);
        t -= r * 60;
        let i = String(r), n = String(t);
        return i.length < 2 && (i = "0" + i), n.length < 2 && (n = "0" + n), (e === -1 ? "-" : "+") + i + n;
    }
    a(RL, "formatTimezoneOffset");
    function kL(t) {
        return Math.sign(t) || (Object.is(t, -0) ? -1 : 1);
    }
    a(kL, "simpleSign");
    function PL(t) {
        return t === 0 ? t : -t;
    }
    a(PL, "negateExceptForZero");
    function wr(t) {
        return t = t.replace(/\r/g, ""), t = t.replace(/^\n+/, ""), t = t.replace(/\n+$/, "") + "\n", t;
    }
    a(wr, "normalizeNewlines");
    function lc(t) {
        let [, e, r, i, n] = t.match(/^(.*) <(.*)> (.*) (.*)$/);
        return {
            name: e,
            email: r,
            timestamp: Number(i),
            timezoneOffset: AL(n)
        };
    }
    a(lc, "parseAuthor");
    function AL(t) {
        let [, e, r, i] = t.match(/(\+|-)(\d\d)(\d\d)/);
        return i = (e === "+" ? 1 : -1) * (Number(r) * 60 + Number(i)), IL(i);
    }
    a(AL, "parseTimezoneOffset");
    function IL(t) {
        return t === 0 ? t : -t;
    }
    a(IL, "negateExceptForZero$1");
    var Cn = class Cn {
        static from(e) {
            return new Cn(e);
        }
        static render(e) {
            return "object ".concat(e.object, "\ntype ").concat(e.type, "\ntag ").concat(e.tag, "\ntagger ").concat(Fp(e.tagger), "\n\n").concat(e.message, "\n").concat(e.gpgsig ? e.gpgsig : "");
        }
        justHeaders() {
            return this._tag.slice(0, this._tag.indexOf("\n\n"));
        }
        message() {
            let e = this.withoutSignature();
            return e.slice(e.indexOf("\n\n") + 2);
        }
        parse() {
            return Object.assign(this.headers(), {
                message: this.message(),
                gpgsig: this.gpgsig()
            });
        }
        render() {
            return this._tag;
        }
        headers() {
            let e = this.justHeaders().split("\n"), r = [];
            for (let n of e)n[0] === " " ? r[r.length - 1] += "\n" + n.slice(1) : r.push(n);
            let i = {};
            for (let n of r){
                let o = n.slice(0, n.indexOf(" ")), s = n.slice(n.indexOf(" ") + 1);
                Array.isArray(i[o]) ? i[o].push(s) : i[o] = s;
            }
            return i.tagger && (i.tagger = lc(i.tagger)), i.committer && (i.committer = lc(i.committer)), i;
        }
        withoutSignature() {
            let e = wr(this._tag);
            return e.indexOf("\n-----BEGIN PGP SIGNATURE-----") === -1 ? e : e.slice(0, e.lastIndexOf("\n-----BEGIN PGP SIGNATURE-----"));
        }
        gpgsig() {
            if (this._tag.indexOf("\n-----BEGIN PGP SIGNATURE-----") === -1) return;
            let e = this._tag.slice(this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"), this._tag.indexOf("-----END PGP SIGNATURE-----") + 27);
            return wr(e);
        }
        payload() {
            return this.withoutSignature() + "\n";
        }
        toObject() {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(this._tag, "utf8");
        }
        static async sign(e, r, i) {
            let n = e.payload(), { signature: o } = await r({
                payload: n,
                secretKey: i
            });
            o = wr(o);
            let s = n + o;
            return Cn.from(s);
        }
        constructor(e){
            if (typeof e == "string") this._tag = e;
            else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(e)) this._tag = e.toString("utf8");
            else if (typeof e == "object") this._tag = Cn.render(e);
            else throw new W("invalid type passed to GitAnnotatedTag constructor");
        }
    };
    a(Cn, "GitAnnotatedTag");
    var ft = Cn;
    function fp(t) {
        return t.trim().split("\n").map((e)=>" " + e).join("\n") + "\n";
    }
    a(fp, "indent");
    function DL(t) {
        return t.split("\n").map((e)=>e.replace(/^ /, "")).join("\n");
    }
    a(DL, "outdent");
    var Je = class Je {
        static fromPayloadSignature(param) {
            let { payload: e, signature: r } = param;
            let i = Je.justHeaders(e), n = Je.justMessage(e), o = wr(i + "\ngpgsig" + fp(r) + "\n" + n);
            return new Je(o);
        }
        static from(e) {
            return new Je(e);
        }
        toObject() {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(this._commit, "utf8");
        }
        headers() {
            return this.parseHeaders();
        }
        message() {
            return Je.justMessage(this._commit);
        }
        parse() {
            return Object.assign({
                message: this.message()
            }, this.headers());
        }
        static justMessage(e) {
            return wr(e.slice(e.indexOf("\n\n") + 2));
        }
        static justHeaders(e) {
            return e.slice(0, e.indexOf("\n\n"));
        }
        parseHeaders() {
            let e = Je.justHeaders(this._commit).split("\n"), r = [];
            for (let n of e)n[0] === " " ? r[r.length - 1] += "\n" + n.slice(1) : r.push(n);
            let i = {
                parent: []
            };
            for (let n of r){
                let o = n.slice(0, n.indexOf(" ")), s = n.slice(n.indexOf(" ") + 1);
                Array.isArray(i[o]) ? i[o].push(s) : i[o] = s;
            }
            return i.author && (i.author = lc(i.author)), i.committer && (i.committer = lc(i.committer)), i;
        }
        static renderHeaders(e) {
            let r = "";
            if (e.tree ? r += "tree ".concat(e.tree, "\n") : r += "tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\n", e.parent) {
                if (e.parent.length === void 0) throw new W("commit 'parent' property should be an array");
                for (let o of e.parent)r += "parent ".concat(o, "\n");
            }
            let i = e.author;
            r += "author ".concat(Fp(i), "\n");
            let n = e.committer || e.author;
            return r += "committer ".concat(Fp(n), "\n"), e.gpgsig && (r += "gpgsig" + fp(e.gpgsig)), r;
        }
        static render(e) {
            return Je.renderHeaders(e) + "\n" + wr(e.message);
        }
        render() {
            return this._commit;
        }
        withoutSignature() {
            let e = wr(this._commit);
            if (e.indexOf("\ngpgsig") === -1) return e;
            let r = e.slice(0, e.indexOf("\ngpgsig")), i = e.slice(e.indexOf("-----END PGP SIGNATURE-----\n") + 28);
            return wr(r + "\n" + i);
        }
        isolateSignature() {
            let e = this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"), this._commit.indexOf("-----END PGP SIGNATURE-----") + 27);
            return DL(e);
        }
        static async sign(e, r, i) {
            let n = e.withoutSignature(), o = Je.justMessage(e._commit), { signature: s } = await r({
                payload: n,
                secretKey: i
            });
            s = wr(s);
            let f = Je.justHeaders(e._commit) + "\ngpgsig" + fp(s) + "\n" + o;
            return Je.from(f);
        }
        constructor(e){
            if (typeof e == "string") this._commit = e;
            else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(e)) this._commit = e.toString("utf8");
            else if (typeof e == "object") this._commit = Je.render(e);
            else throw new W("invalid type passed to GitCommit constructor");
        }
    };
    a(Je, "GitCommit");
    var tt = Je;
    async function Wn(param) {
        let { fs: t, cache: e, gitdir: r, oid: i } = param;
        if (i === "4b825dc642cb6eb9a060e54bf8d69288fbee4904") return {
            tree: et.from([]),
            oid: i
        };
        let { type: n, object: o } = await de({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i
        });
        if (n === "tag") return i = ft.from(o).parse().object, Wn({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i
        });
        if (n === "commit") return i = tt.from(o).parse().tree, Wn({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i
        });
        if (n !== "tree") throw new Ze(i, n, "tree");
        return {
            tree: et.from(o),
            oid: i
        };
    }
    a(Wn, "resolveTree");
    var qp = class qp {
        async readdir(e) {
            let r = e._fullpath, { fs: i, cache: n, gitdir: o } = this, s = await this.mapPromise, l = s.get(r);
            if (!l) throw new Error("No obj for ".concat(r));
            let f = l.oid;
            if (!f) throw new Error("No oid for obj ".concat(JSON.stringify(l)));
            if (l.type !== "tree") return null;
            let { type: c, object: u } = await de({
                fs: i,
                cache: n,
                gitdir: o,
                oid: f
            });
            if (c !== l.type) throw new Ze(f, c, l.type);
            let h = et.from(u);
            for (let d of h)s.set(D.join(r, d.path), d);
            return h.entries().map((d)=>D.join(r, d.path));
        }
        async type(e) {
            if (e._type === !1) {
                let r = await this.mapPromise, { type: i } = r.get(e._fullpath);
                e._type = i;
            }
            return e._type;
        }
        async mode(e) {
            if (e._mode === !1) {
                let r = await this.mapPromise, { mode: i } = r.get(e._fullpath);
                e._mode = RE(parseInt(i, 8));
            }
            return e._mode;
        }
        async stat(e) {}
        async content(e) {
            if (e._content === !1) {
                let r = await this.mapPromise, { fs: i, cache: n, gitdir: o } = this, l = r.get(e._fullpath).oid, { type: f, object: c } = await de({
                    fs: i,
                    cache: n,
                    gitdir: o,
                    oid: l
                });
                f !== "blob" ? e._content = void 0 : e._content = new Uint8Array(c);
            }
            return e._content;
        }
        async oid(e) {
            if (e._oid === !1) {
                let i = (await this.mapPromise).get(e._fullpath);
                e._oid = i.oid;
            }
            return e._oid;
        }
        constructor({ fs: e, gitdir: r, ref: i, cache: n }){
            var s;
            this.fs = e, this.cache = n, this.gitdir = r, this.mapPromise = (async ()=>{
                let l = new Map, f;
                try {
                    f = await B.resolve({
                        fs: e,
                        gitdir: r,
                        ref: i
                    });
                } catch (u) {
                    u instanceof ce && (f = "4b825dc642cb6eb9a060e54bf8d69288fbee4904");
                }
                let c = await Wn({
                    fs: e,
                    cache: this.cache,
                    gitdir: r,
                    oid: f
                });
                return c.type = "tree", c.mode = "40000", l.set(".", c), l;
            })();
            let o = this;
            this.ConstructEntry = (s = class {
                async type() {
                    return o.type(this);
                }
                async mode() {
                    return o.mode(this);
                }
                async stat() {
                    return o.stat(this);
                }
                async content() {
                    return o.content(this);
                }
                async oid() {
                    return o.oid(this);
                }
                constructor(f){
                    this._fullpath = f, this._type = !1, this._mode = !1, this._stat = !1, this._content = !1, this._oid = !1;
                }
            }, a(s, "TreeEntry"), s);
        }
    };
    a(qp, "GitWalkerRepo");
    var Ep = qp;
    function ct() {
        let { ref: t = "HEAD" } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let e = Object.create(null);
        return Object.defineProperty(e, Qc, {
            value: a(function(param) {
                let { fs: r, gitdir: i, cache: n } = param;
                return new Ep({
                    fs: r,
                    gitdir: i,
                    ref: t,
                    cache: n
                });
            }, "value")
        }), Object.freeze(e), e;
    }
    a(ct, "TREE");
    var Hp = class Hp {
        async readdir(e) {
            let r = e._fullpath, { fs: i, dir: n } = this, o = await i.readdir(D.join(n, r));
            return o === null ? null : o.map((s)=>D.join(r, s));
        }
        async type(e) {
            return e._type === !1 && await e.stat(), e._type;
        }
        async mode(e) {
            return e._mode === !1 && await e.stat(), e._mode;
        }
        async stat(e) {
            if (e._stat === !1) {
                let { fs: r, dir: i } = this, n = await r.lstat("".concat(i, "/").concat(e._fullpath));
                if (!n) throw new Error("ENOENT: no such file or directory, lstat '".concat(e._fullpath, "'"));
                let o = n.isDirectory() ? "tree" : "blob";
                o === "blob" && !n.isFile() && !n.isSymbolicLink() && (o = "special"), e._type = o, n = $n(n), e._mode = n.mode, n.size === -1 && e._actualSize && (n.size = e._actualSize), e._stat = n;
            }
            return e._stat;
        }
        async content(e) {
            if (e._content === !1) {
                let { fs: r, dir: i, gitdir: n } = this;
                if (await e.type() === "tree") e._content = void 0;
                else {
                    let s = await (await this._getGitConfig(r, n)).get("core.autocrlf"), l = await r.read("".concat(i, "/").concat(e._fullpath), {
                        autocrlf: s
                    });
                    e._actualSize = l.length, e._stat && e._stat.size === -1 && (e._stat.size = e._actualSize), e._content = new Uint8Array(l);
                }
            }
            return e._content;
        }
        async oid(e) {
            if (e._oid === !1) {
                let r = this, { fs: i, gitdir: n, cache: o } = this, s;
                await Fe.acquire({
                    fs: i,
                    gitdir: n,
                    cache: o
                }, async function(l) {
                    let f = l.entriesMap.get(e._fullpath), c = await e.stat(), h = await (await r._getGitConfig(i, n)).get("core.filemode"), d = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] < "u" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform !== "win32" : !0;
                    if (!f || ic(c, f, h, d)) {
                        let p = await e.content();
                        p === void 0 ? s = void 0 : (s = await gr(Gr.wrap({
                            type: "blob",
                            object: p
                        })), f && s === f.oid && (!h || c.mode === f.mode) && ic(c, f, h, d) && l.insert({
                            filepath: e._fullpath,
                            stats: c,
                            oid: s
                        }));
                    } else s = f.oid;
                }), e._oid = s;
            }
            return e._oid;
        }
        async _getGitConfig(e, r) {
            return this.config ? this.config : (this.config = await be.get({
                fs: e,
                gitdir: r
            }), this.config);
        }
        constructor({ fs: e, dir: r, gitdir: i, cache: n }){
            var s;
            this.fs = e, this.cache = n, this.dir = r, this.gitdir = i, this.config = null;
            let o = this;
            this.ConstructEntry = (s = class {
                async type() {
                    return o.type(this);
                }
                async mode() {
                    return o.mode(this);
                }
                async stat() {
                    return o.stat(this);
                }
                async content() {
                    return o.content(this);
                }
                async oid() {
                    return o.oid(this);
                }
                constructor(f){
                    this._fullpath = f, this._type = !1, this._mode = !1, this._stat = !1, this._content = !1, this._oid = !1;
                }
            }, a(s, "WorkdirEntry"), s);
        }
    };
    a(Hp, "GitWalkerFs");
    var Sp = Hp;
    function Yn() {
        let t = Object.create(null);
        return Object.defineProperty(t, Qc, {
            value: a(function(param) {
                let { fs: e, dir: r, gitdir: i, cache: n } = param;
                return new Sp({
                    fs: e,
                    dir: r,
                    gitdir: i,
                    cache: n
                });
            }, "value")
        }), Object.freeze(t), t;
    }
    a(Yn, "WORKDIR");
    function CL(t, e) {
        let r = e - t;
        return Array.from({
            length: r
        }, (i, n)=>t + n);
    }
    a(CL, "arrayRange");
    var BE = typeof Array.prototype.flat > "u" ? (t)=>t.reduce((e, r)=>e.concat(r), []) : (t)=>t.flat(), zp = class zp {
        consider(e) {
            e != null && (this.value === null ? this.value = e : e < this.value && (this.value = e));
        }
        reset() {
            this.value = null;
        }
        constructor(){
            this.value = null;
        }
    };
    a(zp, "RunningMinimum");
    var xp = zp;
    function* NL(t) {
        let e = new xp, r, i = [], n = t.length;
        for(let o = 0; o < n; o++)i[o] = t[o].next().value, i[o] !== void 0 && e.consider(i[o]);
        if (e.value !== null) for(;;){
            let o = [];
            r = e.value, e.reset();
            for(let s = 0; s < n; s++)i[s] !== void 0 && i[s] === r ? (o[s] = i[s], i[s] = t[s].next().value) : o[s] = null, i[s] !== void 0 && e.consider(i[s]);
            if (yield o, e.value === null) return;
        }
    }
    a(NL, "unionOfIterators");
    async function Zr(param) {
        let { fs: t, cache: e, dir: r, gitdir: i, trees: n, map: o = a(async (f, c)=>c, "map"), reduce: s = a(async (f, c)=>{
            let u = BE(c);
            return f !== void 0 && u.unshift(f), u;
        }, "reduce"), iterate: l = a((f, c)=>Promise.all([
                ...c
            ].map(f)), "iterate") } = param;
        let f = n.map((p)=>p[Qc]({
                fs: t,
                dir: r,
                gitdir: i,
                cache: e
            })), c = new Array(f.length).fill("."), u = CL(0, f.length), h = a(async (p)=>{
            u.map((w)=>{
                let v = p[w];
                p[w] = v && new f[w].ConstructEntry(v);
            });
            let y = (await Promise.all(u.map((w)=>{
                let v = p[w];
                return v ? f[w].readdir(v) : [];
            }))).map((w)=>(w === null ? [] : w)[Symbol.iterator]());
            return {
                entries: p,
                children: NL(y)
            };
        }, "unionWalkerFromReaddir"), d = a(async (p)=>{
            let { entries: m, children: y } = await h(p), w = m.find((g)=>g && g._fullpath)._fullpath, v = await o(w, m);
            if (v !== null) {
                let g = await l(d, y);
                return g = g.filter((F)=>F !== void 0), s(v, g);
            }
        }, "walk");
        return d(c);
    }
    a(Zr, "_walk");
    async function Tp(t, e) {
        let r = await t.readdir(e);
        r == null ? await t.rm(e) : r.length ? await Promise.all(r.map((i)=>{
            let n = D.join(e, i);
            return t.lstat(n).then((o)=>{
                if (o) return o.isDirectory() ? Tp(t, n) : t.rm(n);
            });
        })).then(()=>t.rmdir(e)) : await t.rmdir(e);
    }
    a(Tp, "rmRecursive");
    function BL(t) {
        return LL(t) && dE(t.then) && dE(t.catch);
    }
    a(BL, "isPromiseLike");
    function LL(t) {
        return t && typeof t == "object";
    }
    a(LL, "isObject");
    function dE(t) {
        return typeof t == "function";
    }
    a(dE, "isFunction");
    function pE(t) {
        return BL(a((r)=>{
            try {
                return r.readFile().catch((i)=>i);
            } catch (i) {
                return i;
            }
        }, "test")(t));
    }
    a(pE, "isPromiseFs");
    var mE = [
        "readFile",
        "writeFile",
        "mkdir",
        "rmdir",
        "unlink",
        "stat",
        "lstat",
        "readdir",
        "readlink",
        "symlink"
    ];
    function yE(t, e) {
        if (pE(e)) for (let r of mE)t["_".concat(r)] = e[r].bind(e);
        else for (let r of mE)t["_".concat(r)] = np(e[r].bind(e));
        pE(e) ? e.rm ? t._rm = e.rm.bind(e) : e.rmdir.length > 1 ? t._rm = e.rmdir.bind(e) : t._rm = Tp.bind(null, t) : e.rm ? t._rm = np(e.rm.bind(e)) : e.rmdir.length > 2 ? t._rm = np(e.rmdir.bind(e)) : t._rm = Tp.bind(null, t);
    }
    a(yE, "bindFs");
    var Wp = class Wp {
        async exists(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            try {
                return await this._stat(e), !0;
            } catch (i) {
                if (i.code === "ENOENT" || i.code === "ENOTDIR" || (i.code || "").includes("ENS")) return !1;
                throw console.log('Unhandled error in "FileSystem.exists()" function', i), i;
            }
        }
        async read(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            try {
                let i = await this._readFile(e, r);
                if (r.autocrlf === "true") try {
                    i = new TextDecoder("utf8", {
                        fatal: !0
                    }).decode(i), i = i.replace(/\r\n/g, "\n"), i = new TextEncoder().encode(i);
                } catch (e) {}
                return typeof i != "string" && (i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(i)), i;
            } catch (e) {
                return null;
            }
        }
        async write(e, r) {
            let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            try {
                await this._writeFile(e, r, i);
                return;
            } catch (e1) {
                await this.mkdir(Mn(e)), await this._writeFile(e, r, i);
            }
        }
        async mkdir(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            try {
                await this._mkdir(e);
                return;
            } catch (i) {
                if (i === null || i.code === "EEXIST") return;
                if (r) throw i;
                if (i.code === "ENOENT") {
                    let n = Mn(e);
                    if (n === "." || n === "/" || n === e) throw i;
                    await this.mkdir(n), await this.mkdir(e, !0);
                }
            }
        }
        async rm(e) {
            try {
                await this._unlink(e);
            } catch (r) {
                if (r.code !== "ENOENT") throw r;
            }
        }
        async rmdir(e, r) {
            try {
                r && r.recursive ? await this._rm(e, r) : await this._rmdir(e);
            } catch (i) {
                if (i.code !== "ENOENT") throw i;
            }
        }
        async readdir(e) {
            try {
                let r = await this._readdir(e);
                return r.sort(Jc), r;
            } catch (r) {
                return r.code === "ENOTDIR" ? null : [];
            }
        }
        async readdirDeep(e) {
            let r = await this._readdir(e);
            return (await Promise.all(r.map(async (n)=>{
                let o = e + "/" + n;
                return (await this._stat(o)).isDirectory() ? this.readdirDeep(o) : o;
            }))).reduce((n, o)=>n.concat(o), []);
        }
        async lstat(e) {
            try {
                return await this._lstat(e);
            } catch (r) {
                if (r.code === "ENOENT" || (r.code || "").includes("ENS")) return null;
                throw r;
            }
        }
        async readlink(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                encoding: "buffer"
            };
            try {
                let i = await this._readlink(e, r);
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(i) ? i : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(i);
            } catch (i) {
                if (i.code === "ENOENT" || (i.code || "").includes("ENS")) return null;
                throw i;
            }
        }
        async writelink(e, r) {
            return this._symlink(r.toString("utf8"), e);
        }
        constructor(e){
            if (typeof e._original_unwrapped_fs < "u") return e;
            let r = Object.getOwnPropertyDescriptor(e, "promises");
            r && r.enumerable ? yE(this, e.promises) : yE(this, e), this._original_unwrapped_fs = e;
        }
    };
    a(Wp, "FileSystem");
    var M = Wp;
    function E(t, e) {
        if (e === void 0) throw new Qe(t);
    }
    a(E, "assertParameter");
    async function cc(t, e) {
        return !t && !e ? !1 : t && !e || !t && e ? !0 : !(await t.type() === "tree" && await e.type() === "tree" || await t.type() === await e.type() && await t.mode() === await e.mode() && await t.oid() === await e.oid());
    }
    a(cc, "modified");
    async function LE(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), commit: i = "HEAD", cache: n = {} } = param;
        try {
            E("fs", t), E("dir", e), E("gitdir", r);
            let o = new M(t), s = [
                ct({
                    ref: i
                }),
                Yn(),
                Ai()
            ], l = [];
            await Fe.acquire({
                fs: o,
                gitdir: r,
                cache: n
            }, async function(c) {
                l = c.unmergedPaths;
            });
            let f = await Zr({
                fs: o,
                cache: n,
                dir: e,
                gitdir: r,
                trees: s,
                map: a(async function(c, param) {
                    let [u, h, d] = param;
                    let p = !await cc(h, d), m = l.includes(c), y = !await cc(d, u);
                    if (p || m) return u ? {
                        path: c,
                        mode: await u.mode(),
                        oid: await u.oid(),
                        type: await u.type(),
                        content: await u.content()
                    } : void 0;
                    if (y) return !1;
                    throw new ks(c);
                }, "map")
            });
            await Fe.acquire({
                fs: o,
                gitdir: r,
                cache: n
            }, async function(c) {
                for (let u of f)if (u !== !1) {
                    if (!u) {
                        await o.rmdir("".concat(e, "/").concat(u.path), {
                            recursive: !0
                        }), c.delete({
                            filepath: u.path
                        });
                        continue;
                    }
                    if (u.type === "blob") {
                        let h = new TextDecoder().decode(u.content);
                        await o.write("".concat(e, "/").concat(u.path), h, {
                            mode: u.mode
                        }), c.insert({
                            filepath: u.path,
                            oid: u.oid,
                            stage: 0
                        });
                    }
                }
            });
        } catch (o) {
            throw o.caller = "git.abortMerge", o;
        }
    }
    a(LE, "abortMerge");
    var Vp = class Vp {
        static async isIgnored(param) {
            let { fs: e, dir: r, gitdir: i = D.join(r, ".git"), filepath: n } = param;
            if (nc(n) === ".git") return !0;
            if (n === ".") return !1;
            let o = "", s = D.join(i, "info", "exclude");
            await e.exists(s) && (o = await e.read(s, "utf8"));
            let l = [
                {
                    gitignore: D.join(r, ".gitignore"),
                    filepath: n
                }
            ], f = n.split("/").filter(Boolean);
            for(let u = 1; u < f.length; u++){
                let h = f.slice(0, u).join("/"), d = f.slice(u).join("/");
                l.push({
                    gitignore: D.join(r, h, ".gitignore"),
                    filepath: d
                });
            }
            let c = !1;
            for (let u of l){
                let h;
                try {
                    h = await e.read(u.gitignore, "utf8");
                } catch (m) {
                    if (m.code === "NOENT") continue;
                }
                let d = HB().add(o);
                d.add(h);
                let p = Mn(u.filepath);
                if (p !== "." && d.ignores(p)) return !0;
                c ? c = !d.test(u.filepath).unignored : c = d.test(u.filepath).ignored;
            }
            return c;
        }
    };
    a(Vp, "GitIgnoreManager");
    var Xr = Vp;
    async function $L(param) {
        let { fs: t, gitdir: e, object: r, format: i, oid: n } = param;
        if (i !== "deflated") throw new W("GitObjectStoreLoose expects objects to write to be in deflated format");
        let o = "objects/".concat(n.slice(0, 2), "/").concat(n.slice(2)), s = "".concat(e, "/").concat(o);
        await t.exists(s) || await t.write(s, r);
    }
    a($L, "writeObjectLoose");
    var up = null;
    async function $E(t) {
        return up === null && (up = jL()), up ? ML(t) : kp.deflate(t);
    }
    a($E, "deflate");
    async function ML(t) {
        let e = new CompressionStream("deflate"), r = new Blob([
            t
        ]).stream().pipeThrough(e);
        return new Uint8Array(await new Response(r).arrayBuffer());
    }
    a(ML, "browserDeflate");
    function jL() {
        try {
            return new CompressionStream("deflate").writable.close(), new Blob([]).stream().cancel(), !0;
        } catch (e) {
            return !1;
        }
    }
    a(jL, "testCompressionStream");
    async function rt(param) {
        let { fs: t, gitdir: e, type: r, object: i, format: n = "content", oid: o = void 0, dryRun: s = !1 } = param;
        return n !== "deflated" && (n !== "wrapped" && (i = Gr.wrap({
            type: r,
            object: i
        })), o = await gr(i), i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(await $E(i))), s || await $L({
            fs: t,
            gitdir: e,
            object: i,
            format: "deflated",
            oid: o
        }), o;
    }
    a(rt, "_writeObject");
    function ME(t) {
        let e;
        for(; ~(e = t.indexOf(92));)t[e] = 47;
        return t;
    }
    a(ME, "posixifyPathBuffer");
    async function jE(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), filepath: i, cache: n = {}, force: o = !1, parallel: s = !0 } = param;
        try {
            E("fs", t), E("dir", e), E("gitdir", r), E("filepath", i);
            let l = new M(t);
            await Fe.acquire({
                fs: l,
                gitdir: r,
                cache: n
            }, async (f)=>{
                let u = await (await be.get({
                    fs: l,
                    gitdir: r
                })).get("core.autocrlf");
                return Op({
                    dir: e,
                    gitdir: r,
                    fs: l,
                    filepath: i,
                    index: f,
                    force: o,
                    parallel: s,
                    autocrlf: u
                });
            });
        } catch (l) {
            throw l.caller = "git.add", l;
        }
    }
    a(jE, "add");
    async function Op(param) {
        let { dir: t, gitdir: e, fs: r, filepath: i, index: n, force: o, parallel: s, autocrlf: l } = param;
        i = Array.isArray(i) ? i : [
            i
        ];
        let f = i.map(async (d)=>{
            if (!o && await Xr.isIgnored({
                fs: r,
                dir: t,
                gitdir: e,
                filepath: d
            })) return;
            let p = await r.lstat(D.join(t, d));
            if (!p) throw new ce(d);
            if (p.isDirectory()) {
                let m = await r.readdir(D.join(t, d));
                if (s) {
                    let y = m.map((w)=>Op({
                            dir: t,
                            gitdir: e,
                            fs: r,
                            filepath: [
                                D.join(d, w)
                            ],
                            index: n,
                            force: o,
                            parallel: s,
                            autocrlf: l
                        }));
                    await Promise.all(y);
                } else for (let y of m)await Op({
                    dir: t,
                    gitdir: e,
                    fs: r,
                    filepath: [
                        D.join(d, y)
                    ],
                    index: n,
                    force: o,
                    parallel: s,
                    autocrlf: l
                });
            } else {
                let m = p.isSymbolicLink() ? await r.readlink(D.join(t, d)).then(ME) : await r.read(D.join(t, d), {
                    autocrlf: l
                });
                if (m === null) throw new ce(d);
                let y = await rt({
                    fs: r,
                    gitdir: e,
                    type: "blob",
                    object: m
                });
                n.insert({
                    filepath: d,
                    stats: p,
                    oid: y
                });
            }
        }), c = await Promise.allSettled(f), u = c.filter((d)=>d.status === "rejected").map((d)=>d.reason);
        if (u.length > 1) throw new xs(u);
        if (u.length === 1) throw u[0];
        return c.filter((d)=>d.status === "fulfilled" && d.value).map((d)=>d.value);
    }
    a(Op, "addToIndex");
    async function As(param) {
        let { fs: t, gitdir: e, path: r } = param;
        return (await be.get({
            fs: t,
            gitdir: e
        })).get(r);
    }
    a(As, "_getConfig");
    function UE(t) {
        for(var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            e[_key - 1] = arguments[_key];
        }
        for (let r of e)if (r) for (let i of Object.keys(r)){
            let n = r[i];
            n !== void 0 && (t[i] = n);
        }
        return t;
    }
    a(UE, "assignDefined");
    async function Yr(param) {
        let { fs: t, gitdir: e, author: r, commit: i } = param;
        let n = Math.floor(Date.now() / 1e3), o = {
            name: await As({
                fs: t,
                gitdir: e,
                path: "user.name"
            }),
            email: await As({
                fs: t,
                gitdir: e,
                path: "user.email"
            }) || "",
            timestamp: n,
            timezoneOffset: new Date(n * 1e3).getTimezoneOffset()
        }, s = UE({}, o, i ? i.author : void 0, r);
        if (s.name !== void 0) return s;
    }
    a(Yr, "normalizeAuthorObject");
    async function Vn(param) {
        let { fs: t, gitdir: e, author: r, committer: i, commit: n } = param;
        let o = Math.floor(Date.now() / 1e3), s = {
            name: await As({
                fs: t,
                gitdir: e,
                path: "user.name"
            }),
            email: await As({
                fs: t,
                gitdir: e,
                path: "user.email"
            }) || "",
            timestamp: o,
            timezoneOffset: new Date(o * 1e3).getTimezoneOffset()
        }, l = UE({}, s, n ? n.committer : void 0, r, i);
        if (l.name !== void 0) return l;
    }
    a(Vn, "normalizeCommitterObject");
    async function qE(param) {
        let { fs: t, cache: e, gitdir: r, oid: i } = param;
        let { type: n, object: o } = await de({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i
        });
        if (n === "tag") return i = ft.from(o).parse().object, qE({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i
        });
        if (n !== "commit") throw new Ze(i, n, "commit");
        return {
            commit: tt.from(o),
            oid: i
        };
    }
    a(qE, "resolveCommit");
    async function Gn(param) {
        let { fs: t, cache: e, gitdir: r, oid: i } = param;
        let { commit: n, oid: o } = await qE({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i
        });
        return {
            oid: o,
            commit: n.parse(),
            payload: n.withoutSignature()
        };
    }
    a(Gn, "_readCommit");
    async function ef(param) {
        let { fs: t, cache: e, onSign: r, gitdir: i, message: n, author: o, committer: s, signingKey: l, amend: f = !1, dryRun: c = !1, noUpdateBranch: u = !1, ref: h, parent: d, tree: p } = param;
        let m = !1;
        h || (h = await B.resolve({
            fs: t,
            gitdir: i,
            ref: "HEAD",
            depth: 2
        }));
        let y, w;
        try {
            y = await B.resolve({
                fs: t,
                gitdir: i,
                ref: h
            }), w = await Gn({
                fs: t,
                gitdir: i,
                oid: y,
                cache: {}
            });
        } catch (e) {
            m = !0;
        }
        if (f && m) throw new Ps(h);
        let v = f ? await Yr({
            fs: t,
            gitdir: i,
            author: o,
            commit: w.commit
        }) : await Yr({
            fs: t,
            gitdir: i,
            author: o
        });
        if (!v) throw new He("author");
        let g = f ? await Vn({
            fs: t,
            gitdir: i,
            author: v,
            committer: s,
            commit: w.commit
        }) : await Vn({
            fs: t,
            gitdir: i,
            author: v,
            committer: s
        });
        if (!g) throw new He("committer");
        return Fe.acquire({
            fs: t,
            gitdir: i,
            cache: e,
            allowUnmerged: !1
        }, async function(F) {
            let S = PE(F.entries).get(".");
            if (p || (p = await HE({
                fs: t,
                gitdir: i,
                inode: S,
                dryRun: c
            })), d ? d = await Promise.all(d.map((x)=>B.resolve({
                    fs: t,
                    gitdir: i,
                    ref: x
                }))) : f ? d = w.commit.parent : d = y ? [
                y
            ] : [], !n) if (f) n = w.commit.message;
            else throw new Qe("message");
            let R = tt.from({
                tree: p,
                parent: d,
                author: v,
                committer: g,
                message: n
            });
            l && (R = await tt.sign(R, r, l));
            let b = await rt({
                fs: t,
                gitdir: i,
                type: "commit",
                object: R.toObject(),
                dryRun: c
            });
            return !u && !c && await B.writeRef({
                fs: t,
                gitdir: i,
                ref: h,
                value: b
            }), b;
        });
    }
    a(ef, "_commit");
    async function HE(param) {
        let { fs: t, gitdir: e, inode: r, dryRun: i } = param;
        let n = r.children;
        for (let f of n)f.type === "tree" && (f.metadata.mode = "040000", f.metadata.oid = await HE({
            fs: t,
            gitdir: e,
            inode: f,
            dryRun: i
        }));
        let o = n.map((f)=>({
                mode: f.metadata.mode,
                path: f.basename,
                oid: f.metadata.oid,
                type: f.type
            })), s = et.from(o);
        return await rt({
            fs: t,
            gitdir: e,
            type: "tree",
            object: s.toObject(),
            dryRun: i
        });
    }
    a(HE, "constructTree");
    async function Is(param) {
        let { fs: t, cache: e, gitdir: r, oid: i, filepath: n } = param;
        if (n.startsWith("/")) throw new Kr("leading-slash");
        if (n.endsWith("/")) throw new Kr("trailing-slash");
        let o = i, s = await Wn({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i
        }), l = s.tree;
        if (n === "") i = s.oid;
        else {
            let f = n.split("/");
            i = await zE({
                fs: t,
                cache: e,
                gitdir: r,
                tree: l,
                pathArray: f,
                oid: o,
                filepath: n
            });
        }
        return i;
    }
    a(Is, "resolveFilepath");
    async function zE(param) {
        let { fs: t, cache: e, gitdir: r, tree: i, pathArray: n, oid: o, filepath: s } = param;
        let l = n.shift();
        for (let f of i)if (f.path === l) {
            if (n.length === 0) return f.oid;
            {
                let { type: c, object: u } = await de({
                    fs: t,
                    cache: e,
                    gitdir: r,
                    oid: f.oid
                });
                if (c !== "tree") throw new Ze(o, c, "tree", s);
                return i = et.from(u), zE({
                    fs: t,
                    cache: e,
                    gitdir: r,
                    tree: i,
                    pathArray: n,
                    oid: o,
                    filepath: s
                });
            }
        }
        throw new ce('file or directory found at "'.concat(o, ":").concat(s, '"'));
    }
    a(zE, "_resolveFilepath");
    async function Jn(param) {
        let { fs: t, cache: e, gitdir: r, oid: i, filepath: n = void 0 } = param;
        n !== void 0 && (i = await Is({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i,
            filepath: n
        }));
        let { tree: o, oid: s } = await Wn({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i
        });
        return {
            oid: s,
            tree: o.entries()
        };
    }
    a(Jn, "_readTree");
    async function Ds(param) {
        let { fs: t, gitdir: e, tree: r } = param;
        let i = et.from(r).toObject();
        return await rt({
            fs: t,
            gitdir: e,
            type: "tree",
            object: i,
            format: "content"
        });
    }
    a(Ds, "_writeTree");
    async function UL(param) {
        let { fs: t, cache: e, onSign: r, gitdir: i, ref: n, oid: o, note: s, force: l, author: f, committer: c, signingKey: u } = param;
        let h;
        try {
            h = await B.resolve({
                gitdir: i,
                fs: t,
                ref: n
            });
        } catch (v) {
            if (!(v instanceof ce)) throw v;
        }
        let p = (await Jn({
            fs: t,
            cache: e,
            gitdir: i,
            oid: h || "4b825dc642cb6eb9a060e54bf8d69288fbee4904"
        })).tree;
        if (l) p = p.filter((v)=>v.path !== o);
        else for (let v of p)if (v.path === o) throw new Ct("note", o);
        typeof s == "string" && (s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(s, "utf8"));
        let m = await rt({
            fs: t,
            gitdir: i,
            type: "blob",
            object: s,
            format: "content"
        });
        p.push({
            mode: "100644",
            path: o,
            oid: m,
            type: "blob"
        });
        let y = await Ds({
            fs: t,
            gitdir: i,
            tree: p
        });
        return await ef({
            fs: t,
            cache: e,
            onSign: r,
            gitdir: i,
            ref: n,
            tree: y,
            parent: h && [
                h
            ],
            message: "Note added by 'isomorphic-git addNote'\n",
            author: f,
            committer: c,
            signingKey: u
        });
    }
    a(UL, "_addNote");
    async function WE(param) {
        let { fs: t, onSign: e, dir: r, gitdir: i = D.join(r, ".git"), ref: n = "refs/notes/commits", oid: o, note: s, force: l, author: f, committer: c, signingKey: u, cache: h = {} } = param;
        try {
            E("fs", t), E("gitdir", i), E("oid", o), E("note", s), u && E("onSign", e);
            let d = new M(t), p = await Yr({
                fs: d,
                gitdir: i,
                author: f
            });
            if (!p) throw new He("author");
            let m = await Vn({
                fs: d,
                gitdir: i,
                author: p,
                committer: c
            });
            if (!m) throw new He("committer");
            return await UL({
                fs: new M(d),
                cache: h,
                onSign: e,
                gitdir: i,
                ref: n,
                oid: o,
                note: s,
                force: l,
                author: p,
                committer: m,
                signingKey: u
            });
        } catch (d) {
            throw d.caller = "git.addNote", d;
        }
    }
    a(WE, "addNote");
    async function VE(param) {
        let { fs: t, gitdir: e, remote: r, url: i, force: n } = param;
        if (!ps(r, !0)) throw new Nt(r, ds.clean(r));
        let o = await be.get({
            fs: t,
            gitdir: e
        });
        if (!n && (await o.getSubsections("remote")).includes(r) && i !== await o.get("remote.".concat(r, ".url"))) throw new Ct("remote", r);
        await o.set("remote.".concat(r, ".url"), i), await o.set("remote.".concat(r, ".fetch"), "+refs/heads/*:refs/remotes/".concat(r, "/*")), await be.save({
            fs: t,
            gitdir: e,
            config: o
        });
    }
    a(VE, "_addRemote");
    async function GE(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), remote: i, url: n, force: o = !1 } = param;
        try {
            return E("fs", t), E("gitdir", r), E("remote", i), E("url", n), await VE({
                fs: new M(t),
                gitdir: r,
                remote: i,
                url: n,
                force: o
            });
        } catch (s) {
            throw s.caller = "git.addRemote", s;
        }
    }
    a(GE, "addRemote");
    async function qL(param) {
        let { fs: t, cache: e, onSign: r, gitdir: i, ref: n, tagger: o, message: s = n, gpgsig: l, object: f, signingKey: c, force: u = !1 } = param;
        if (n = n.startsWith("refs/tags/") ? n : "refs/tags/".concat(n), !u && await B.exists({
            fs: t,
            gitdir: i,
            ref: n
        })) throw new Ct("tag", n);
        let h = await B.resolve({
            fs: t,
            gitdir: i,
            ref: f || "HEAD"
        }), { type: d } = await de({
            fs: t,
            cache: e,
            gitdir: i,
            oid: h
        }), p = ft.from({
            object: h,
            type: d,
            tag: n.replace("refs/tags/", ""),
            tagger: o,
            message: s,
            gpgsig: l
        });
        c && (p = await ft.sign(p, r, c));
        let m = await rt({
            fs: t,
            gitdir: i,
            type: "tag",
            object: p.toObject()
        });
        await B.writeRef({
            fs: t,
            gitdir: i,
            ref: n,
            value: m
        });
    }
    a(qL, "_annotatedTag");
    async function KE(param) {
        let { fs: t, onSign: e, dir: r, gitdir: i = D.join(r, ".git"), ref: n, tagger: o, message: s = n, gpgsig: l, object: f, signingKey: c, force: u = !1, cache: h = {} } = param;
        try {
            E("fs", t), E("gitdir", i), E("ref", n), c && E("onSign", e);
            let d = new M(t), p = await Yr({
                fs: d,
                gitdir: i,
                author: o
            });
            if (!p) throw new He("tagger");
            return await qL({
                fs: d,
                cache: h,
                onSign: e,
                gitdir: i,
                ref: n,
                tagger: p,
                message: s,
                gpgsig: l,
                object: f,
                signingKey: c,
                force: u
            });
        } catch (d) {
            throw d.caller = "git.annotatedTag", d;
        }
    }
    a(KE, "annotatedTag");
    async function HL(param) {
        let { fs: t, gitdir: e, ref: r, object: i, checkout: n = !1, force: o = !1 } = param;
        if (!ps(r, !0)) throw new Nt(r, ds.clean(r));
        let s = "refs/heads/".concat(r);
        if (!o && await B.exists({
            fs: t,
            gitdir: e,
            ref: s
        })) throw new Ct("branch", r, !1);
        let l;
        try {
            l = await B.resolve({
                fs: t,
                gitdir: e,
                ref: i || "HEAD"
            });
        } catch (e) {}
        l && await B.writeRef({
            fs: t,
            gitdir: e,
            ref: s,
            value: l
        }), n && await B.writeSymbolicRef({
            fs: t,
            gitdir: e,
            ref: "HEAD",
            value: s
        });
    }
    a(HL, "_branch");
    async function ZE(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), ref: i, object: n, checkout: o = !1, force: s = !1 } = param;
        try {
            return E("fs", t), E("gitdir", r), E("ref", i), await HL({
                fs: new M(t),
                gitdir: r,
                ref: i,
                object: n,
                checkout: o,
                force: s
            });
        } catch (l) {
            throw l.caller = "git.branch", l;
        }
    }
    a(ZE, "branch");
    var XE = a((t, e)=>t === "." || e == null || e.length === 0 || e === "." ? !0 : e.length >= t.length ? e.startsWith(t) : t.startsWith(e), "worthWalking");
    async function Ap(param) {
        let { fs: t, cache: e, onProgress: r, onPostCheckout: i, dir: n, gitdir: o, remote: s, ref: l, filepaths: f, noCheckout: c, noUpdateHead: u, dryRun: h, force: d, track: p = !0, nonBlocking: m = !1, batchSize: y = 100 } = param;
        let w;
        if (i) try {
            w = await B.resolve({
                fs: t,
                gitdir: o,
                ref: "HEAD"
            });
        } catch (e) {
            w = "0000000000000000000000000000000000000000";
        }
        let v;
        try {
            v = await B.resolve({
                fs: t,
                gitdir: o,
                ref: l
            });
        } catch (g) {
            if (l === "HEAD") throw g;
            let F = "".concat(s, "/").concat(l);
            if (v = await B.resolve({
                fs: t,
                gitdir: o,
                ref: F
            }), p) {
                let O = await be.get({
                    fs: t,
                    gitdir: o
                });
                await O.set("branch.".concat(l, ".remote"), s), await O.set("branch.".concat(l, ".merge"), "refs/heads/".concat(l)), await be.save({
                    fs: t,
                    gitdir: o,
                    config: O
                });
            }
            await B.writeRef({
                fs: t,
                gitdir: o,
                ref: "refs/heads/".concat(l),
                value: v
            });
        }
        if (!c) {
            let g;
            try {
                g = await zL({
                    fs: t,
                    cache: e,
                    onProgress: r,
                    dir: n,
                    gitdir: o,
                    ref: l,
                    force: d,
                    filepaths: f
                });
            } catch (b) {
                throw b instanceof ce && b.data.what === v ? new vs(l, v) : b;
            }
            let F = g.filter((param)=>{
                let [b] = param;
                return b === "conflict";
            }).map((param)=>{
                let [b, x] = param;
                return x;
            });
            if (F.length > 0) throw new bs(F);
            let O = g.filter((param)=>{
                let [b] = param;
                return b === "error";
            }).map((param)=>{
                let [b, x] = param;
                return x;
            });
            if (O.length > 0) throw new W(O.join(", "));
            if (h) {
                i && await i({
                    previousHead: w,
                    newHead: v,
                    type: f != null && f.length > 0 ? "file" : "branch"
                });
                return;
            }
            let S = 0, R = g.length;
            if (await Fe.acquire({
                fs: t,
                gitdir: o,
                cache: e
            }, async function(b) {
                await Promise.all(g.filter((param)=>{
                    let [x] = param;
                    return x === "delete" || x === "delete-index";
                }).map(async function(param) {
                    let [x, _] = param;
                    let P = "".concat(n, "/").concat(_);
                    x === "delete" && await t.rm(P), b.delete({
                        filepath: _
                    }), r && await r({
                        phase: "Updating workdir",
                        loaded: ++S,
                        total: R
                    });
                }));
            }), await Fe.acquire({
                fs: t,
                gitdir: o,
                cache: e
            }, async function(b) {
                for (let [x, _] of g)if (x === "rmdir" || x === "rmdir-index") {
                    let P = "".concat(n, "/").concat(_);
                    try {
                        x === "rmdir" && await t.rmdir(P), b.delete({
                            filepath: _
                        }), r && await r({
                            phase: "Updating workdir",
                            loaded: ++S,
                            total: R
                        });
                    } catch (k) {
                        if (k.code === "ENOTEMPTY") console.log("Did not delete ".concat(_, " because directory is not empty"));
                        else throw k;
                    }
                }
            }), await Promise.all(g.filter((param)=>{
                let [b] = param;
                return b === "mkdir" || b === "mkdir-index";
            }).map(async function(param) {
                let [b, x] = param;
                let _ = "".concat(n, "/").concat(x);
                await t.mkdir(_), r && await r({
                    phase: "Updating workdir",
                    loaded: ++S,
                    total: R
                });
            })), m) {
                let b = g.filter((param)=>{
                    let [_] = param;
                    return _ === "create" || _ === "create-index" || _ === "update" || _ === "mkdir-index";
                }), x = await wE("Update Working Dir", b.map((param)=>{
                    let [_, P, k, C, N] = param;
                    return ()=>VL({
                            fs: t,
                            cache: e,
                            gitdir: o,
                            dir: n
                        }, [
                            _,
                            P,
                            k,
                            C,
                            N
                        ]);
                }), r, y);
                await Fe.acquire({
                    fs: t,
                    gitdir: o,
                    cache: e,
                    allowUnmerged: !0
                }, async function(_) {
                    await wE("Update Index", x.map((param)=>{
                        let [P, k, C] = param;
                        return ()=>WL({
                                index: _,
                                fullpath: P,
                                oid: k,
                                stats: C
                            });
                    }), r, y);
                });
            } else await Fe.acquire({
                fs: t,
                gitdir: o,
                cache: e,
                allowUnmerged: !0
            }, async function(b) {
                await Promise.all(g.filter((param)=>{
                    let [x] = param;
                    return x === "create" || x === "create-index" || x === "update" || x === "mkdir-index";
                }).map(async function(param) {
                    let [x, _, P, k, C] = param;
                    let N = "".concat(n, "/").concat(_);
                    try {
                        if (x !== "create-index" && x !== "mkdir-index") {
                            let { object: Z } = await de({
                                fs: t,
                                cache: e,
                                gitdir: o,
                                oid: P
                            });
                            if (C && await t.rm(N), k === 33188) await t.write(N, Z);
                            else if (k === 33261) await t.write(N, Z, {
                                mode: 511
                            });
                            else if (k === 40960) await t.writelink(N, Z);
                            else throw new W("Invalid mode 0o".concat(k.toString(8), " detected in blob ").concat(P));
                        }
                        let U = await t.lstat(N);
                        k === 33261 && (U.mode = 493), x === "mkdir-index" && (U.mode = 57344), b.insert({
                            filepath: _,
                            stats: U,
                            oid: P
                        }), r && await r({
                            phase: "Updating workdir",
                            loaded: ++S,
                            total: R
                        });
                    } catch (U) {
                        console.log(U);
                    }
                }));
            });
            i && await i({
                previousHead: w,
                newHead: v,
                type: f != null && f.length > 0 ? "file" : "branch"
            });
        }
        if (!u) {
            let g = await B.expand({
                fs: t,
                gitdir: o,
                ref: l
            });
            g.startsWith("refs/heads") ? await B.writeSymbolicRef({
                fs: t,
                gitdir: o,
                ref: "HEAD",
                value: g
            }) : await B.writeRef({
                fs: t,
                gitdir: o,
                ref: "HEAD",
                value: v
            });
        }
    }
    a(Ap, "_checkout");
    async function zL(param) {
        let { fs: t, cache: e, onProgress: r, dir: i, gitdir: n, ref: o, force: s, filepaths: l } = param;
        let f = 0;
        return Zr({
            fs: t,
            cache: e,
            dir: i,
            gitdir: n,
            trees: [
                ct({
                    ref: o
                }),
                Yn(),
                Ai()
            ],
            map: a(async function(c, param) {
                let [u, h, d] = param;
                if (c === ".") return;
                if (l && !l.some((m)=>XE(c, m))) return null;
                switch(r && await r({
                    phase: "Analyzing workdir",
                    loaded: ++f
                }), [
                    !!d,
                    !!u,
                    !!h
                ].map(Number).join("")){
                    case "000":
                        return;
                    case "001":
                        return s && l && l.includes(c) ? [
                            "delete",
                            c
                        ] : void 0;
                    case "010":
                        switch(await u.type()){
                            case "tree":
                                return [
                                    "mkdir",
                                    c
                                ];
                            case "blob":
                                return [
                                    "create",
                                    c,
                                    await u.oid(),
                                    await u.mode()
                                ];
                            case "commit":
                                return [
                                    "mkdir-index",
                                    c,
                                    await u.oid(),
                                    await u.mode()
                                ];
                            default:
                                return [
                                    "error",
                                    "new entry Unhandled type ".concat(await u.type())
                                ];
                        }
                    case "011":
                        switch("".concat(await u.type(), "-").concat(await h.type())){
                            case "tree-tree":
                                return;
                            case "tree-blob":
                            case "blob-tree":
                                return [
                                    "conflict",
                                    c
                                ];
                            case "blob-blob":
                                return await u.oid() !== await h.oid() ? s ? [
                                    "update",
                                    c,
                                    await u.oid(),
                                    await u.mode(),
                                    await u.mode() !== await h.mode()
                                ] : [
                                    "conflict",
                                    c
                                ] : await u.mode() !== await h.mode() ? s ? [
                                    "update",
                                    c,
                                    await u.oid(),
                                    await u.mode(),
                                    !0
                                ] : [
                                    "conflict",
                                    c
                                ] : [
                                    "create-index",
                                    c,
                                    await u.oid(),
                                    await u.mode()
                                ];
                            case "commit-tree":
                                return;
                            case "commit-blob":
                                return [
                                    "conflict",
                                    c
                                ];
                            default:
                                return [
                                    "error",
                                    "new entry Unhandled type ".concat(u.type)
                                ];
                        }
                    case "100":
                        return [
                            "delete-index",
                            c
                        ];
                    case "101":
                        switch(await d.type()){
                            case "tree":
                                return [
                                    "rmdir-index",
                                    c
                                ];
                            case "blob":
                                return await d.oid() !== await h.oid() ? s ? [
                                    "delete",
                                    c
                                ] : [
                                    "conflict",
                                    c
                                ] : [
                                    "delete",
                                    c
                                ];
                            case "commit":
                                return [
                                    "rmdir-index",
                                    c
                                ];
                            default:
                                return [
                                    "error",
                                    "delete entry Unhandled type ".concat(await d.type())
                                ];
                        }
                    case "110":
                    case "111":
                        switch("".concat(await d.type(), "-").concat(await u.type())){
                            case "tree-tree":
                                return;
                            case "blob-blob":
                                {
                                    if (await d.oid() === await u.oid() && await d.mode() === await u.mode() && !s) return;
                                    if (h) {
                                        if (await h.oid() !== await d.oid() && await h.oid() !== await u.oid()) return s ? [
                                            "update",
                                            c,
                                            await u.oid(),
                                            await u.mode(),
                                            await u.mode() !== await h.mode()
                                        ] : [
                                            "conflict",
                                            c
                                        ];
                                    } else if (s) return [
                                        "update",
                                        c,
                                        await u.oid(),
                                        await u.mode(),
                                        await u.mode() !== await d.mode()
                                    ];
                                    return await u.mode() !== await d.mode() ? [
                                        "update",
                                        c,
                                        await u.oid(),
                                        await u.mode(),
                                        !0
                                    ] : await u.oid() !== await d.oid() ? [
                                        "update",
                                        c,
                                        await u.oid(),
                                        await u.mode(),
                                        !1
                                    ] : void 0;
                                }
                            case "tree-blob":
                                return [
                                    "update-dir-to-blob",
                                    c,
                                    await u.oid()
                                ];
                            case "blob-tree":
                                return [
                                    "update-blob-to-tree",
                                    c
                                ];
                            case "commit-commit":
                                return [
                                    "mkdir-index",
                                    c,
                                    await u.oid(),
                                    await u.mode()
                                ];
                            default:
                                return [
                                    "error",
                                    "update entry Unhandled type ".concat(await d.type(), "-").concat(await u.type())
                                ];
                        }
                }
            }, "map"),
            reduce: a(async function(c, u) {
                return u = BE(u), c ? c && c[0] === "rmdir" ? (u.push(c), u) : (u.unshift(c), u) : u;
            }, "reduce")
        });
    }
    a(zL, "analyze");
    async function WL(param) {
        let { index: t, fullpath: e, stats: r, oid: i } = param;
        try {
            t.insert({
                filepath: e,
                stats: r,
                oid: i
            });
        } catch (n) {
            console.warn("Error inserting ".concat(e, " into index:"), n);
        }
    }
    a(WL, "updateIndex");
    async function VL(param, param1) {
        let { fs: t, cache: e, gitdir: r, dir: i } = param, [n, o, s, l, f] = param1;
        let c = "".concat(i, "/").concat(o);
        if (n !== "create-index" && n !== "mkdir-index") {
            let { object: h } = await de({
                fs: t,
                cache: e,
                gitdir: r,
                oid: s
            });
            if (f && await t.rm(c), l === 33188) await t.write(c, h);
            else if (l === 33261) await t.write(c, h, {
                mode: 511
            });
            else if (l === 40960) await t.writelink(c, h);
            else throw new W("Invalid mode 0o".concat(l.toString(8), " detected in blob ").concat(s));
        }
        let u = await t.lstat(c);
        return l === 33261 && (u.mode = 493), n === "mkdir-index" && (u.mode = 57344), [
            o,
            s,
            u
        ];
    }
    a(VL, "updateWorkingDir");
    async function wE(t, e, r, i) {
        let n = [];
        try {
            for(let o = 0; o < e.length; o += i){
                let s = e.slice(o, o + i).map((f)=>f());
                (await Promise.allSettled(s)).forEach((f)=>{
                    f.status === "fulfilled" && n.push(f.value);
                }), r && await r({
                    phase: "Updating workdir",
                    loaded: o + s.length,
                    total: e.length
                });
            }
            return n;
        } catch (o) {
            console.error("Error during ".concat(t, ": ").concat(o));
        }
        return n;
    }
    a(wE, "batchAllSettled");
    async function Ip(param) {
        let { fs: t, onProgress: e, onPostCheckout: r, dir: i, gitdir: n = D.join(i, ".git"), remote: o = "origin", ref: s, filepaths: l, noCheckout: f = !1, noUpdateHead: c = s === void 0, dryRun: u = !1, force: h = !1, track: d = !0, cache: p = {}, nonBlocking: m = !1, batchSize: y = 100 } = param;
        try {
            E("fs", t), E("dir", i), E("gitdir", n);
            let w = s || "HEAD";
            return await Ap({
                fs: new M(t),
                cache: p,
                onProgress: e,
                onPostCheckout: r,
                dir: i,
                gitdir: n,
                remote: o,
                ref: w,
                filepaths: l,
                noCheckout: f,
                noUpdateHead: c,
                dryRun: u,
                force: h,
                track: d,
                nonBlocking: m,
                batchSize: y
            });
        } catch (w) {
            throw w.caller = "git.checkout", w;
        }
    }
    a(Ip, "checkout");
    var GL = new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");
    function Oi(t) {
        let e = GL.exec(t);
        return e ? e[1] === "remotes/" && t.endsWith("/HEAD") ? e[2].slice(0, -5) : e[2] : t;
    }
    a(Oi, "abbreviateRef");
    async function Jr(param) {
        let { fs: t, gitdir: e, fullname: r = !1, test: i = !1 } = param;
        let n = await B.resolve({
            fs: t,
            gitdir: e,
            ref: "HEAD",
            depth: 2
        });
        if (i) try {
            await B.resolve({
                fs: t,
                gitdir: e,
                ref: n
            });
        } catch (e) {
            return;
        }
        if (n.startsWith("refs/")) return r ? n : Oi(n);
    }
    a(Jr, "_currentBranch");
    function KL(t) {
        return t = t.replace(/^git@([^:]+):/, "https://$1/"), t = t.replace(/^ssh:\/\//, "https://"), t;
    }
    a(KL, "translateSSHtoHTTP");
    function YE(param) {
        let { username: t = "", password: e = "" } = param;
        return "Basic ".concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from("".concat(t, ":").concat(e)).toString("base64"));
    }
    a(YE, "calculateBasicAuthHeader");
    async function Cs(t, e) {
        let r = DE(t);
        for(;;){
            let { value: i, done: n } = await r.next();
            if (i && await e(i), n) break;
        }
        r.return && r.return();
    }
    a(Cs, "forAwait");
    async function fc(t) {
        let e = 0, r = [];
        await Cs(t, (o)=>{
            r.push(o), e += o.byteLength;
        });
        let i = new Uint8Array(e), n = 0;
        for (let o of r)i.set(o, n), n += o.byteLength;
        return i;
    }
    a(fc, "collect");
    function gE(t) {
        let e = t.match(/^https?:\/\/([^/]+)@/);
        if (e == null) return {
            url: t,
            auth: {}
        };
        e = e[1];
        let [r, i] = e.split(":");
        return t = t.replace("".concat(e, "@"), ""), {
            url: t,
            auth: {
                username: r,
                password: i
            }
        };
    }
    a(gE, "extractAuthFromUrl");
    function Rp(t, e) {
        let r = e.toString(16);
        return "0".repeat(t - r.length) + r;
    }
    a(Rp, "padHex");
    var Gp = class Gp {
        static flush() {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from("0000", "utf8");
        }
        static delim() {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from("0001", "utf8");
        }
        static encode(e) {
            typeof e == "string" && (e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e));
            let r = e.length + 4, i = Rp(4, r);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(i, "utf8"),
                e
            ]);
        }
        static streamReader(e) {
            let r = new ac(e);
            return a(async function() {
                try {
                    let n = await r.read(4);
                    if (n == null) return !0;
                    if (n = parseInt(n.toString("utf8"), 16), n === 0 || n === 1) return null;
                    let o = await r.read(n - 4);
                    return o !== null && o !== void 0 ? o : !0;
                } catch (n) {
                    return e.error = n, !0;
                }
            }, "read");
        }
    };
    a(Gp, "GitPktLine");
    var ye = Gp;
    async function bE(t) {
        let e = {}, r;
        for(; r = await t(), r !== !0;){
            if (r === null) continue;
            r = r.toString("utf8").replace(/\n$/, "");
            let i = r.indexOf("=");
            if (i > -1) {
                let n = r.slice(0, i), o = r.slice(i + 1);
                e[n] = o;
            } else e[r] = !0;
        }
        return {
            protocolVersion: 2,
            capabilities2: e
        };
    }
    a(bE, "parseCapabilitiesV2");
    async function vE(t, param) {
        let { service: e } = param;
        let r = new Set, i = new Map, n = new Map, o = ye.streamReader(t), s = await o();
        for(; s === null;)s = await o();
        if (s === !0) throw new _s;
        if (s.includes("version 2")) return bE(o);
        if (s.toString("utf8").replace(/\n$/, "") !== "# service=".concat(e)) throw new Ri("# service=".concat(e, "\\n"), s.toString("utf8"));
        let l = await o();
        for(; l === null;)l = await o();
        if (l === !0) return {
            capabilities: r,
            refs: i,
            symrefs: n
        };
        if (l = l.toString("utf8"), l.includes("version 2")) return bE(o);
        let [f, c] = hp(l, "\0", "\\x00");
        if (c.split(" ").map((u)=>r.add(u)), f !== "0000000000000000000000000000000000000000 capabilities^{}") {
            let [u, h] = hp(f, " ", " ");
            for(i.set(h, u);;){
                let d = await o();
                if (d === !0) break;
                if (d !== null) {
                    let [p, m] = hp(d.toString("utf8"), " ", " ");
                    i.set(m, p);
                }
            }
        }
        for (let u of r)if (u.startsWith("symref=")) {
            let h = u.match(/symref=([^:]+):(.*)/);
            h.length === 3 && n.set(h[1], h[2]);
        }
        return {
            protocolVersion: 1,
            capabilities: r,
            refs: i,
            symrefs: n
        };
    }
    a(vE, "parseRefsAdResponse");
    function hp(t, e, r) {
        let i = t.trim().split(e);
        if (i.length !== 2) throw new Ri("Two strings separated by '".concat(r, "'"), t.toString("utf8"));
        return i;
    }
    a(hp, "splitAndAssert");
    var _E = a((t, e)=>t.endsWith("?") ? "".concat(t).concat(e) : "".concat(t, "/").concat(e.replace(/^https?:\/\//, "")), "corsProxify"), FE = a((t, e)=>{
        (e.username || e.password) && (t.Authorization = YE(e)), e.headers && Object.assign(t, e.headers);
    }, "updateHeaders"), dp = a(async (t)=>{
        try {
            let e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(await fc(t.body)), r = e.toString("utf8");
            return {
                preview: r.length < 256 ? r : r.slice(0, 256) + "...",
                response: r,
                data: e
            };
        } catch (e) {
            return {};
        }
    }, "stringifyBody"), Kp = class Kp {
        static async capabilities() {
            return [
                "discover",
                "connect"
            ];
        }
        static async discover(param) {
            let { http: e, onProgress: r, onAuth: i, onAuthSuccess: n, onAuthFailure: o, corsProxy: s, service: l, url: f, headers: c, protocolVersion: u } = param;
            let { url: h, auth: d } = gE(f), p = s ? _E(s, h) : h;
            (d.username || d.password) && (c.Authorization = YE(d)), u === 2 && (c["Git-Protocol"] = "version=2");
            let m, y, w = !1;
            do if (m = await e.request({
                onProgress: r,
                method: "GET",
                url: "".concat(p, "/info/refs?service=").concat(l),
                headers: c
            }), y = !1, m.statusCode === 401 || m.statusCode === 203) {
                let v = w ? o : i;
                if (v) {
                    if (d = await v(h, {
                        ...d,
                        headers: {
                            ...c
                        }
                    }), d && d.cancel) throw new zn;
                    d && (FE(c, d), w = !0, y = !0);
                }
            } else m.statusCode === 200 && w && n && await n(h, d);
            while (y)
            if (m.statusCode !== 200) {
                let { response: v } = await dp(m);
                throw new jn(m.statusCode, m.statusMessage, v);
            }
            if (m.headers["content-type"] === "application/x-".concat(l, "-advertisement")) {
                let v = await vE(m.body, {
                    service: l
                });
                return v.auth = d, v;
            } else {
                let { preview: v, response: g, data: F } = await dp(m);
                try {
                    let O = await vE([
                        F
                    ], {
                        service: l
                    });
                    return O.auth = d, O;
                } catch (e) {
                    throw new Ts(v, g);
                }
            }
        }
        static async connect(param) {
            let { http: e, onProgress: r, corsProxy: i, service: n, url: o, auth: s, body: l, headers: f } = param;
            let c = gE(o);
            c && (o = c.url), i && (o = _E(i, o)), f["content-type"] = "application/x-".concat(n, "-request"), f.accept = "application/x-".concat(n, "-result"), FE(f, s);
            let u = await e.request({
                onProgress: r,
                method: "POST",
                url: "".concat(o, "/").concat(n),
                body: l,
                headers: f
            });
            if (u.statusCode !== 200) {
                let { response: h } = dp(u);
                throw new jn(u.statusCode, u.statusMessage, h);
            }
            return u;
        }
    };
    a(Kp, "GitRemoteHTTP");
    var Kn = Kp, Zp = class Zp {
        static getRemoteHelperFor(param) {
            let { url: e } = param;
            let r = new Map;
            r.set("http", Kn), r.set("https", Kn);
            let i = ZL({
                url: e
            });
            if (!i) throw new Rs(e);
            if (r.has(i.transport)) return r.get(i.transport);
            throw new Os(e, i.transport, i.transport === "ssh" ? KL(e) : void 0);
        }
    };
    a(Zp, "GitRemoteManager");
    var Zn = Zp;
    function ZL(param) {
        let { url: t } = param;
        if (t.startsWith("git@")) return {
            transport: "ssh",
            address: t
        };
        let e = t.match(/(\w+)(:\/\/|::)(.*)/);
        if (e !== null) {
            if (e[2] === "://") return {
                transport: e[1],
                address: e[0]
            };
            if (e[2] === "::") return {
                transport: e[1],
                address: e[3]
            };
        }
    }
    a(ZL, "parseRemoteUrl");
    var Ti = null, Xp = class Xp {
        static async read(param) {
            let { fs: e, gitdir: r } = param;
            Ti === null && (Ti = new hs);
            let i = D.join(r, "shallow"), n = new Set;
            return await Ti.acquire(i, async function() {
                let o = await e.read(i, {
                    encoding: "utf8"
                });
                if (o === null || o.trim() === "") return n;
                o.trim().split("\n").map((s)=>n.add(s));
            }), n;
        }
        static async write(param) {
            let { fs: e, gitdir: r, oids: i } = param;
            Ti === null && (Ti = new hs);
            let n = D.join(r, "shallow");
            if (i.size > 0) {
                let o = [
                    ...i
                ].join("\n") + "\n";
                await Ti.acquire(n, async function() {
                    await e.write(n, o, {
                        encoding: "utf8"
                    });
                });
            } else await Ti.acquire(n, async function() {
                await e.rm(n);
            });
        }
    };
    a(Xp, "GitShallowManager");
    var ki = Xp;
    async function XL(param) {
        let { fs: t, gitdir: e, oid: r } = param;
        let i = "objects/".concat(r.slice(0, 2), "/").concat(r.slice(2));
        return t.exists("".concat(e, "/").concat(i));
    }
    a(XL, "hasObjectLoose");
    async function YL(param) {
        let { fs: t, cache: e, gitdir: r, oid: i, getExternalRefDelta: n } = param;
        let o = await t.readdir(D.join(r, "objects/pack"));
        o = o.filter((s)=>s.endsWith(".idx"));
        for (let s of o){
            let l = "".concat(r, "/objects/pack/").concat(s), f = await Pp({
                fs: t,
                cache: e,
                filename: l,
                getExternalRefDelta: n
            });
            if (f.error) throw new W(f.error);
            if (f.offsets.has(i)) return !0;
        }
        return !1;
    }
    a(YL, "hasObjectPacked");
    async function EE(param) {
        let { fs: t, cache: e, gitdir: r, oid: i, format: n = "content" } = param;
        let o = a((l)=>de({
                fs: t,
                cache: e,
                gitdir: r,
                oid: l
            }), "getExternalRefDelta"), s = await XL({
            fs: t,
            gitdir: r,
            oid: i
        });
        return s || (s = await YL({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i,
            getExternalRefDelta: o
        })), s;
    }
    a(EE, "hasObject");
    function JL(t) {
        let n = "5041434b" + "00000002" + "00000000";
        return t.slice(0, 12).toString("hex") === n;
    }
    a(JL, "emptyPackfile");
    function JE(t, e) {
        let r = t.map((i)=>i.split("=", 1)[0]);
        return e.filter((i)=>{
            let n = i.split("=", 1)[0];
            return r.includes(n);
        });
    }
    a(JE, "filterCapabilities");
    var tf = {
        name: "isomorphic-git",
        version: "1.34.0",
        agent: "git/isomorphic-git@1.34.0"
    }, Yp = class Yp {
        write(e) {
            if (this._ended) throw Error("You cannot write to a FIFO that has already been ended!");
            if (this._waiting) {
                let r = this._waiting;
                this._waiting = null, r({
                    value: e
                });
            } else this._queue.push(e);
        }
        end() {
            if (this._ended = !0, this._waiting) {
                let e = this._waiting;
                this._waiting = null, e({
                    done: !0
                });
            }
        }
        destroy(e) {
            this.error = e, this.end();
        }
        async next() {
            if (this._queue.length > 0) return {
                value: this._queue.shift()
            };
            if (this._ended) return {
                done: !0
            };
            if (this._waiting) throw Error("You cannot call read until the previous call to read has returned!");
            return new Promise((e)=>{
                this._waiting = e;
            });
        }
        constructor(){
            this._queue = [];
        }
    };
    a(Yp, "FIFO");
    var Bn = Yp;
    function QL(t) {
        let e = t.indexOf("\r"), r = t.indexOf("\n");
        return e === -1 && r === -1 ? -1 : e === -1 ? r + 1 : r === -1 ? e + 1 : r === e + 1 ? r + 1 : Math.min(e, r) + 1;
    }
    a(QL, "findSplit");
    function QE(t) {
        let e = new Bn, r = "";
        return (async ()=>(await Cs(t, (i)=>{
                for(i = i.toString("utf8"), r += i;;){
                    let n = QL(r);
                    if (n === -1) break;
                    e.write(r.slice(0, n)), r = r.slice(n);
                }
            }), r.length > 0 && e.write(r), e.end()))(), e;
    }
    a(QE, "splitLines");
    var Jp = class Jp {
        static demux(e) {
            let r = ye.streamReader(e), i = new Bn, n = new Bn, o = new Bn, s = a(async function() {
                let l = await r();
                if (l === null) return s();
                if (l === !0) {
                    i.end(), o.end(), e.error ? n.destroy(e.error) : n.end();
                    return;
                }
                switch(l[0]){
                    case 1:
                        {
                            n.write(l.slice(1));
                            break;
                        }
                    case 2:
                        {
                            o.write(l.slice(1));
                            break;
                        }
                    case 3:
                        {
                            let f = l.slice(1);
                            o.write(f), i.end(), o.end(), n.destroy(new Error(f.toString("utf8")));
                            return;
                        }
                    default:
                        i.write(l);
                }
                s();
            }, "nextBit");
            return s(), {
                packetlines: i,
                packfile: n,
                progress: o
            };
        }
    };
    a(Jp, "GitSideBand");
    var uc = Jp;
    async function e$(t) {
        let { packetlines: e, packfile: r, progress: i } = uc.demux(t), n = [], o = [], s = [], l = !1, f = !1;
        return new Promise((c, u)=>{
            Cs(e, (h)=>{
                let d = h.toString("utf8").trim();
                if (d.startsWith("shallow")) {
                    let p = d.slice(-41).trim();
                    p.length !== 40 && u(new Vr(p)), n.push(p);
                } else if (d.startsWith("unshallow")) {
                    let p = d.slice(-41).trim();
                    p.length !== 40 && u(new Vr(p)), o.push(p);
                } else if (d.startsWith("ACK")) {
                    let [, p, m] = d.split(" ");
                    s.push({
                        oid: p,
                        status: m
                    }), m || (f = !0);
                } else d.startsWith("NAK") ? (l = !0, f = !0) : (f = !0, l = !0);
                f && (t.error ? u(t.error) : c({
                    shallows: n,
                    unshallows: o,
                    acks: s,
                    nak: l,
                    packfile: r,
                    progress: i
                }));
            }).finally(()=>{
                f || (t.error ? u(t.error) : c({
                    shallows: n,
                    unshallows: o,
                    acks: s,
                    nak: l,
                    packfile: r,
                    progress: i
                }));
            });
        });
    }
    a(e$, "parseUploadPackResponse");
    function t$(param) {
        let { capabilities: t = [], wants: e = [], haves: r = [], shallows: i = [], depth: n = null, since: o = null, exclude: s = [] } = param;
        let l = [];
        e = [
            ...new Set(e)
        ];
        let f = " ".concat(t.join(" "));
        for (let c of e)l.push(ye.encode("want ".concat(c).concat(f, "\n"))), f = "";
        for (let c of i)l.push(ye.encode("shallow ".concat(c, "\n")));
        n !== null && l.push(ye.encode("deepen ".concat(n, "\n"))), o !== null && l.push(ye.encode("deepen-since ".concat(Math.floor(o.valueOf() / 1e3), "\n")));
        for (let c of s)l.push(ye.encode("deepen-not ".concat(c, "\n")));
        l.push(ye.flush());
        for (let c of r)l.push(ye.encode("have ".concat(c, "\n")));
        return l.push(ye.encode("done\n")), l;
    }
    a(t$, "writeUploadPackRequest");
    async function Dp(param) {
        let { fs: t, cache: e, http: r, onProgress: i, onMessage: n, onAuth: o, onAuthSuccess: s, onAuthFailure: l, gitdir: f, ref: c, remoteRef: u, remote: h, url: d, corsProxy: p, depth: m = null, since: y = null, exclude: w = [], relative: v = !1, tags: g = !1, singleBranch: F = !1, headers: O = {}, prune: S = !1, pruneTags: R = !1 } = param;
        let b = c || await Jr({
            fs: t,
            gitdir: f,
            test: !0
        }), x = await be.get({
            fs: t,
            gitdir: f
        }), _ = h || b && await x.get("branch.".concat(b, ".remote")) || "origin", P = d || await x.get("remote.".concat(_, ".url"));
        if (typeof P > "u") throw new Qe("remote OR url");
        let k = u || b && await x.get("branch.".concat(b, ".merge")) || c || "HEAD";
        p === void 0 && (p = await x.get("http.corsProxy"));
        let C = Zn.getRemoteHelperFor({
            url: P
        }), N = await C.discover({
            http: r,
            onAuth: o,
            onAuthSuccess: s,
            onAuthFailure: l,
            corsProxy: p,
            service: "git-upload-pack",
            url: P,
            headers: O,
            protocolVersion: 1
        }), U = N.auth, Z = N.refs;
        if (Z.size === 0) return {
            defaultBranch: null,
            fetchHead: null,
            fetchHeadDescription: null
        };
        if (m !== null && !N.capabilities.has("shallow")) throw new Wr("shallow", "depth");
        if (y !== null && !N.capabilities.has("deepen-since")) throw new Wr("deepen-since", "since");
        if (w.length > 0 && !N.capabilities.has("deepen-not")) throw new Wr("deepen-not", "exclude");
        if (v === !0 && !N.capabilities.has("deepen-relative")) throw new Wr("deepen-relative", "relative");
        let { oid: me, fullref: Ee } = B.resolveAgainstMap({
            ref: k,
            map: Z
        });
        for (let Y of Z.keys())Y === Ee || Y === "HEAD" || Y.startsWith("refs/heads/") || g && Y.startsWith("refs/tags/") || Z.delete(Y);
        let $ = JE([
            ...N.capabilities
        ], [
            "multi_ack_detailed",
            "no-done",
            "side-band-64k",
            "ofs-delta",
            "agent=".concat(tf.agent)
        ]);
        v && $.push("deepen-relative");
        let H = F ? [
            me
        ] : Z.values(), G = F ? [
            b
        ] : await B.listRefs({
            fs: t,
            gitdir: f,
            filepath: "refs"
        }), X = [];
        for (let Y of G)try {
            Y = await B.expand({
                fs: t,
                gitdir: f,
                ref: Y
            });
            let he = await B.resolve({
                fs: t,
                gitdir: f,
                ref: Y
            });
            await EE({
                fs: t,
                cache: e,
                gitdir: f,
                oid: he
            }) && X.push(he);
        } catch (e) {}
        X = [
            ...new Set(X)
        ];
        let z = await ki.read({
            fs: t,
            gitdir: f
        }), fe = N.capabilities.has("shallow") ? [
            ...z
        ] : [], ee = t$({
            capabilities: $,
            wants: H,
            haves: X,
            shallows: fe,
            depth: m,
            since: y,
            exclude: w
        }), Oe = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(await fc(ee)), Re = await C.connect({
            http: r,
            onProgress: i,
            corsProxy: p,
            service: "git-upload-pack",
            url: P,
            auth: U,
            body: [
                Oe
            ],
            headers: O
        }), se = await e$(Re.body);
        Re.headers && (se.headers = Re.headers);
        for (let Y of se.shallows)if (!z.has(Y)) try {
            let { object: he } = await de({
                fs: t,
                cache: e,
                gitdir: f,
                oid: Y
            }), Me = new tt(he), $t = await Promise.all(Me.headers().parent.map((oo)=>EE({
                    fs: t,
                    cache: e,
                    gitdir: f,
                    oid: oo
                })));
            $t.length === 0 || $t.every((oo)=>oo) || z.add(Y);
        } catch (e) {
            z.add(Y);
        }
        for (let Y of se.unshallows)z.delete(Y);
        if (await ki.write({
            fs: t,
            gitdir: f,
            oids: z
        }), F) {
            let Y = new Map([
                [
                    Ee,
                    me
                ]
            ]), he = new Map, Me = 10, $t = Ee;
            for(; Me--;){
                let _f = N.symrefs.get($t);
                if (_f === void 0) break;
                he.set($t, _f), $t = _f;
            }
            let vf = Z.get($t);
            vf && Y.set($t, vf);
            let { pruned: oo } = await B.updateRemoteRefs({
                fs: t,
                gitdir: f,
                remote: _,
                refs: Y,
                symrefs: he,
                tags: g,
                prune: S
            });
            S && (se.pruned = oo);
        } else {
            let { pruned: Y } = await B.updateRemoteRefs({
                fs: t,
                gitdir: f,
                remote: _,
                refs: Z,
                symrefs: N.symrefs,
                tags: g,
                prune: S,
                pruneTags: R
            });
            S && (se.pruned = Y);
        }
        if (se.HEAD = N.symrefs.get("HEAD"), se.HEAD === void 0) {
            let { oid: Y } = B.resolveAgainstMap({
                ref: "HEAD",
                map: Z
            });
            for (let [he, Me] of Z.entries())if (he !== "HEAD" && Me === Y) {
                se.HEAD = he;
                break;
            }
        }
        let Ot = Ee.startsWith("refs/tags") ? "tag" : "branch";
        if (se.FETCH_HEAD = {
            oid: me,
            description: "".concat(Ot, " '").concat(Oi(Ee), "' of ").concat(P)
        }, i || n) {
            let Y = QE(se.progress);
            Cs(Y, async (he)=>{
                if (n && await n(he), i) {
                    let Me = he.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);
                    Me && await i({
                        phase: Me[1].trim(),
                        loaded: parseInt(Me[2], 10),
                        total: parseInt(Me[3], 10)
                    });
                }
            });
        }
        let ve = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(await fc(se.packfile));
        if (Re.body.error) throw Re.body.error;
        let Ve = ve.slice(-20).toString("hex"), Be = {
            defaultBranch: se.HEAD,
            fetchHead: se.FETCH_HEAD.oid,
            fetchHeadDescription: se.FETCH_HEAD.description
        };
        if (se.headers && (Be.headers = se.headers), S && (Be.pruned = se.pruned), Ve !== "" && !JL(ve)) {
            Be.packfile = "objects/pack/pack-".concat(Ve, ".pack");
            let Y = D.join(f, Be.packfile);
            await t.write(Y, ve);
            let he = a(($t)=>de({
                    fs: t,
                    cache: e,
                    gitdir: f,
                    oid: $t
                }), "getExternalRefDelta"), Me = await ws.fromPack({
                pack: ve,
                getExternalRefDelta: he,
                onProgress: i
            });
            await t.write(Y.replace(/\.pack$/, ".idx"), await Me.toBuffer());
        }
        return Be;
    }
    a(Dp, "_fetch");
    async function eS(param) {
        let { fs: t, bare: e = !1, dir: r, gitdir: i = e ? r : D.join(r, ".git"), defaultBranch: n = "master" } = param;
        if (await t.exists(i + "/config")) return;
        let o = [
            "hooks",
            "info",
            "objects/info",
            "objects/pack",
            "refs/heads",
            "refs/tags"
        ];
        o = o.map((s)=>i + "/" + s);
        for (let s of o)await t.mkdir(s);
        await t.write(i + "/config", "[core]\n	repositoryformatversion = 0\n	filemode = false\n	bare = ".concat(e, "\n") + (e ? "" : "	logallrefupdates = true\n") + "	symlinks = false\n	ignorecase = true\n"), await t.write(i + "/HEAD", "ref: refs/heads/".concat(n, "\n"));
    }
    a(eS, "_init");
    async function r$(param) {
        let { fs: t, cache: e, http: r, onProgress: i, onMessage: n, onAuth: o, onAuthSuccess: s, onAuthFailure: l, onPostCheckout: f, dir: c, gitdir: u, url: h, corsProxy: d, ref: p, remote: m, depth: y, since: w, exclude: v, relative: g, singleBranch: F, noCheckout: O, noTags: S, headers: R, nonBlocking: b, batchSize: x = 100 } = param;
        try {
            if (await eS({
                fs: t,
                gitdir: u
            }), await VE({
                fs: t,
                gitdir: u,
                remote: m,
                url: h,
                force: !1
            }), d) {
                let k = await be.get({
                    fs: t,
                    gitdir: u
                });
                await k.set("http.corsProxy", d), await be.save({
                    fs: t,
                    gitdir: u,
                    config: k
                });
            }
            let { defaultBranch: _, fetchHead: P } = await Dp({
                fs: t,
                cache: e,
                http: r,
                onProgress: i,
                onMessage: n,
                onAuth: o,
                onAuthSuccess: s,
                onAuthFailure: l,
                gitdir: u,
                ref: p,
                remote: m,
                corsProxy: d,
                depth: y,
                since: w,
                exclude: v,
                relative: g,
                singleBranch: F,
                headers: R,
                tags: !S
            });
            if (P === null) return;
            p = p || _, p = p.replace("refs/heads/", ""), await Ap({
                fs: t,
                cache: e,
                onProgress: i,
                onPostCheckout: f,
                dir: c,
                gitdir: u,
                ref: p,
                remote: m,
                noCheckout: O,
                nonBlocking: b,
                batchSize: x
            });
        } catch (_) {
            throw await t.rmdir(u, {
                recursive: !0,
                maxRetries: 10
            }).catch(()=>{}), _;
        }
    }
    a(r$, "_clone");
    async function tS(param) {
        let { fs: t, http: e, onProgress: r, onMessage: i, onAuth: n, onAuthSuccess: o, onAuthFailure: s, onPostCheckout: l, dir: f, gitdir: c = D.join(f, ".git"), url: u, corsProxy: h = void 0, ref: d = void 0, remote: p = "origin", depth: m = void 0, since: y = void 0, exclude: w = [], relative: v = !1, singleBranch: g = !1, noCheckout: F = !1, noTags: O = !1, headers: S = {}, cache: R = {}, nonBlocking: b = !1, batchSize: x = 100 } = param;
        try {
            return E("fs", t), E("http", e), E("gitdir", c), F || E("dir", f), E("url", u), await r$({
                fs: new M(t),
                cache: R,
                http: e,
                onProgress: r,
                onMessage: i,
                onAuth: n,
                onAuthSuccess: o,
                onAuthFailure: s,
                onPostCheckout: l,
                dir: f,
                gitdir: c,
                url: u,
                corsProxy: h,
                ref: d,
                remote: p,
                depth: m,
                since: y,
                exclude: w,
                relative: v,
                singleBranch: g,
                noCheckout: F,
                noTags: O,
                headers: S,
                nonBlocking: b,
                batchSize: x
            });
        } catch (_) {
            throw _.caller = "git.clone", _;
        }
    }
    a(tS, "clone");
    async function rS(param) {
        let { fs: t, onSign: e, dir: r, gitdir: i = D.join(r, ".git"), message: n, author: o, committer: s, signingKey: l, amend: f = !1, dryRun: c = !1, noUpdateBranch: u = !1, ref: h, parent: d, tree: p, cache: m = {} } = param;
        try {
            E("fs", t), f || E("message", n), l && E("onSign", e);
            let y = new M(t);
            return await ef({
                fs: y,
                cache: m,
                onSign: e,
                gitdir: i,
                message: n,
                author: o,
                committer: s,
                signingKey: l,
                amend: f,
                dryRun: c,
                noUpdateBranch: u,
                ref: h,
                parent: d,
                tree: p
            });
        } catch (y) {
            throw y.caller = "git.commit", y;
        }
    }
    a(rS, "commit");
    async function iS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), fullname: i = !1, test: n = !1 } = param;
        try {
            return E("fs", t), E("gitdir", r), await Jr({
                fs: new M(t),
                gitdir: r,
                fullname: i,
                test: n
            });
        } catch (o) {
            throw o.caller = "git.currentBranch", o;
        }
    }
    a(iS, "currentBranch");
    async function i$(param) {
        let { fs: t, gitdir: e, ref: r } = param;
        if (r = r.startsWith("refs/heads/") ? r : "refs/heads/".concat(r), !await B.exists({
            fs: t,
            gitdir: e,
            ref: r
        })) throw new ce(r);
        let n = await B.expand({
            fs: t,
            gitdir: e,
            ref: r
        }), o = await Jr({
            fs: t,
            gitdir: e,
            fullname: !0
        });
        if (n === o) {
            let f = await B.resolve({
                fs: t,
                gitdir: e,
                ref: n
            });
            await B.writeRef({
                fs: t,
                gitdir: e,
                ref: "HEAD",
                value: f
            });
        }
        await B.deleteRef({
            fs: t,
            gitdir: e,
            ref: n
        });
        let s = Oi(r), l = await be.get({
            fs: t,
            gitdir: e
        });
        await l.deleteSection("branch", s), await be.save({
            fs: t,
            gitdir: e,
            config: l
        });
    }
    a(i$, "_deleteBranch");
    async function nS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), ref: i } = param;
        try {
            return E("fs", t), E("ref", i), await i$({
                fs: new M(t),
                gitdir: r,
                ref: i
            });
        } catch (n) {
            throw n.caller = "git.deleteBranch", n;
        }
    }
    a(nS, "deleteBranch");
    async function oS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), ref: i } = param;
        try {
            E("fs", t), E("ref", i), await B.deleteRef({
                fs: new M(t),
                gitdir: r,
                ref: i
            });
        } catch (n) {
            throw n.caller = "git.deleteRef", n;
        }
    }
    a(oS, "deleteRef");
    async function n$(param) {
        let { fs: t, gitdir: e, remote: r } = param;
        let i = await be.get({
            fs: t,
            gitdir: e
        });
        await i.deleteSection("remote", r), await be.save({
            fs: t,
            gitdir: e,
            config: i
        });
    }
    a(n$, "_deleteRemote");
    async function sS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), remote: i } = param;
        try {
            return E("fs", t), E("remote", i), await n$({
                fs: new M(t),
                gitdir: r,
                remote: i
            });
        } catch (n) {
            throw n.caller = "git.deleteRemote", n;
        }
    }
    a(sS, "deleteRemote");
    async function o$(param) {
        let { fs: t, gitdir: e, ref: r } = param;
        r = r.startsWith("refs/tags/") ? r : "refs/tags/".concat(r), await B.deleteRef({
            fs: t,
            gitdir: e,
            ref: r
        });
    }
    a(o$, "_deleteTag");
    async function aS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), ref: i } = param;
        try {
            return E("fs", t), E("ref", i), await o$({
                fs: new M(t),
                gitdir: r,
                ref: i
            });
        } catch (n) {
            throw n.caller = "git.deleteTag", n;
        }
    }
    a(aS, "deleteTag");
    async function s$(param) {
        let { fs: t, gitdir: e, oid: r } = param;
        let i = r.slice(0, 2);
        return (await t.readdir("".concat(e, "/objects/").concat(i))).map((o)=>"".concat(i).concat(o)).filter((o)=>o.startsWith(r));
    }
    a(s$, "expandOidLoose");
    async function a$(param) {
        let { fs: t, cache: e, gitdir: r, oid: i, getExternalRefDelta: n } = param;
        let o = [], s = await t.readdir(D.join(r, "objects/pack"));
        s = s.filter((l)=>l.endsWith(".idx"));
        for (let l of s){
            let f = "".concat(r, "/objects/pack/").concat(l), c = await Pp({
                fs: t,
                cache: e,
                filename: f,
                getExternalRefDelta: n
            });
            if (c.error) throw new W(c.error);
            for (let u of c.offsets.keys())u.startsWith(i) && o.push(u);
        }
        return o;
    }
    a(a$, "expandOidPacked");
    async function l$(param) {
        let { fs: t, cache: e, gitdir: r, oid: i } = param;
        let n = a((l)=>de({
                fs: t,
                cache: e,
                gitdir: r,
                oid: l
            }), "getExternalRefDelta"), o = await s$({
            fs: t,
            gitdir: r,
            oid: i
        }), s = await a$({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i,
            getExternalRefDelta: n
        });
        for (let l of s)o.indexOf(l) === -1 && o.push(l);
        if (o.length === 1) return o[0];
        throw o.length > 1 ? new gs("oids", i, o) : new ce('an object matching "'.concat(i, '"'));
    }
    a(l$, "_expandOid");
    async function lS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), oid: i, cache: n = {} } = param;
        try {
            return E("fs", t), E("gitdir", r), E("oid", i), await l$({
                fs: new M(t),
                cache: n,
                gitdir: r,
                oid: i
            });
        } catch (o) {
            throw o.caller = "git.expandOid", o;
        }
    }
    a(lS, "expandOid");
    async function cS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), ref: i } = param;
        try {
            return E("fs", t), E("gitdir", r), E("ref", i), await B.expand({
                fs: new M(t),
                gitdir: r,
                ref: i
            });
        } catch (n) {
            throw n.caller = "git.expandRef", n;
        }
    }
    a(cS, "expandRef");
    async function Cp(param) {
        let { fs: t, cache: e, gitdir: r, oids: i } = param;
        let n = {}, o = i.length, s = i.map((l, f)=>({
                index: f,
                oid: l
            }));
        for(; s.length;){
            let l = new Set;
            for (let { oid: c, index: u } of s)n[c] || (n[c] = new Set), n[c].add(u), n[c].size === o && l.add(c);
            if (l.size > 0) return [
                ...l
            ];
            let f = new Map;
            for (let { oid: c, index: u } of s)try {
                let { object: h } = await de({
                    fs: t,
                    cache: e,
                    gitdir: r,
                    oid: c
                }), d = tt.from(h), { parent: p } = d.parseHeaders();
                for (let m of p)(!n[m] || !n[m].has(u)) && f.set(m + ":" + u, {
                    oid: m,
                    index: u
                });
            } catch (e) {}
            s = Array.from(f.values());
        }
        return [];
    }
    a(Cp, "_findMergeBase");
    var pp = /^.*(\r?\n|$)/gm;
    function c$(param) {
        let { branches: t, contents: e } = param;
        let r = t[1], i = t[2], n = e[0], o = e[1], s = e[2], l = o.match(pp), f = n.match(pp), c = s.match(pp), u = zB(l, f, c), h = 7, d = "", p = !0;
        for (let m of u)m.ok && (d += m.ok.join("")), m.conflict && (p = !1, d += "".concat("<".repeat(h), " ").concat(r, "\n"), d += m.conflict.a.join(""), d += "".concat("=".repeat(h), "\n"), d += m.conflict.b.join(""), d += "".concat(">".repeat(h), " ").concat(i, "\n"));
        return {
            cleanMerge: p,
            mergedText: d
        };
    }
    a(c$, "mergeFile");
    async function f$(param) {
        let { fs: t, cache: e, dir: r, gitdir: i = D.join(r, ".git"), index: n, ourOid: o, baseOid: s, theirOid: l, ourName: f = "ours", baseName: c = "base", theirName: u = "theirs", dryRun: h = !1, abortOnConflict: d = !0, mergeDriver: p } = param;
        let m = ct({
            ref: o
        }), y = ct({
            ref: s
        }), w = ct({
            ref: l
        }), v = [], g = [], F = [], O = [], S = await Zr({
            fs: t,
            cache: e,
            dir: r,
            gitdir: i,
            trees: [
                m,
                y,
                w
            ],
            map: a(async function(R, param) {
                let [b, x, _] = param;
                let P = nc(R), k = await cc(b, x), C = await cc(_, x);
                switch("".concat(k, "-").concat(C)){
                    case "false-false":
                        return {
                            mode: await x.mode(),
                            path: P,
                            oid: await x.oid(),
                            type: await x.type()
                        };
                    case "false-true":
                        return !_ && await b.type() === "tree" ? {
                            mode: await b.mode(),
                            path: P,
                            oid: await b.oid(),
                            type: await b.type()
                        } : _ ? {
                            mode: await _.mode(),
                            path: P,
                            oid: await _.oid(),
                            type: await _.type()
                        } : void 0;
                    case "true-false":
                        return !b && await _.type() === "tree" ? {
                            mode: await _.mode(),
                            path: P,
                            oid: await _.oid(),
                            type: await _.type()
                        } : b ? {
                            mode: await b.mode(),
                            path: P,
                            oid: await b.oid(),
                            type: await b.type()
                        } : void 0;
                    case "true-true":
                        {
                            if (b && _ && await b.type() === "tree" && await _.type() === "tree") return {
                                mode: await b.mode(),
                                path: P,
                                oid: await b.oid(),
                                type: "tree"
                            };
                            if (b && _ && await b.type() === "blob" && await _.type() === "blob") return u$({
                                fs: t,
                                gitdir: i,
                                path: P,
                                ours: b,
                                base: x,
                                theirs: _,
                                ourName: f,
                                baseName: c,
                                theirName: u,
                                mergeDriver: p
                            }).then(async (N)=>{
                                if (N.cleanMerge) d || n.insert({
                                    filepath: R,
                                    oid: N.mergeResult.oid,
                                    stage: 0
                                });
                                else if (v.push(R), g.push(R), !d) {
                                    let U = "";
                                    x && await x.type() === "blob" && (U = await x.oid());
                                    let Z = await b.oid(), me = await _.oid();
                                    n.delete({
                                        filepath: R
                                    }), U && n.insert({
                                        filepath: R,
                                        oid: U,
                                        stage: 1
                                    }), n.insert({
                                        filepath: R,
                                        oid: Z,
                                        stage: 2
                                    }), n.insert({
                                        filepath: R,
                                        oid: me,
                                        stage: 3
                                    });
                                }
                                return N.mergeResult;
                            });
                            if (x && !b && _ && await x.type() === "blob" && await _.type() === "blob") {
                                if (v.push(R), F.push(R), !d) {
                                    let N = await x.oid(), U = await _.oid();
                                    n.delete({
                                        filepath: R
                                    }), n.insert({
                                        filepath: R,
                                        oid: N,
                                        stage: 1
                                    }), n.insert({
                                        filepath: R,
                                        oid: U,
                                        stage: 3
                                    });
                                }
                                return {
                                    mode: await _.mode(),
                                    oid: await _.oid(),
                                    type: "blob",
                                    path: P
                                };
                            }
                            if (x && b && !_ && await x.type() === "blob" && await b.type() === "blob") {
                                if (v.push(R), O.push(R), !d) {
                                    let N = await x.oid(), U = await b.oid();
                                    n.delete({
                                        filepath: R
                                    }), n.insert({
                                        filepath: R,
                                        oid: N,
                                        stage: 1
                                    }), n.insert({
                                        filepath: R,
                                        oid: U,
                                        stage: 2
                                    });
                                }
                                return {
                                    mode: await b.mode(),
                                    oid: await b.oid(),
                                    type: "blob",
                                    path: P
                                };
                            }
                            if (x && !b && !_ && (await x.type() === "blob" || await x.type() === "tree")) return;
                            throw new Un;
                        }
                }
            }, "map"),
            reduce: v.length !== 0 && (!r || d) ? void 0 : async (R, b)=>{
                let x = b.filter(Boolean);
                if (R && !(R && R.type === "tree" && x.length === 0 && R.path !== ".")) {
                    if (x.length > 0 || R.path === "." && x.length === 0) {
                        let P = new et(x).toObject(), k = await rt({
                            fs: t,
                            gitdir: i,
                            type: "tree",
                            object: P,
                            dryRun: h
                        });
                        R.oid = k;
                    }
                    return R;
                }
            }
        });
        return v.length !== 0 ? (r && !d && await Zr({
            fs: t,
            cache: e,
            dir: r,
            gitdir: i,
            trees: [
                ct({
                    ref: S.oid
                })
            ],
            map: a(async function(R, param) {
                let [b] = param;
                let x = "".concat(r, "/").concat(R);
                if (await b.type() === "blob") {
                    let _ = await b.mode(), P = new TextDecoder().decode(await b.content());
                    await t.write(x, P, {
                        mode: _
                    });
                }
                return !0;
            }, "map")
        }), new qn(v, g, F, O)) : S.oid;
    }
    a(f$, "mergeTree");
    async function u$(param) {
        let { fs: t, gitdir: e, path: r, ours: i, base: n, theirs: o, ourName: s, theirName: l, baseName: f, dryRun: c, mergeDriver: u = c$ } = param;
        let h = "blob", d = "100755", p = "", m = "";
        n && await n.type() === "blob" && (d = await n.mode(), p = await n.oid(), m = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(await n.content()).toString("utf8"));
        let y = d === await i.mode() ? await o.mode() : await i.mode();
        if (await i.oid() === await o.oid()) return {
            cleanMerge: !0,
            mergeResult: {
                mode: y,
                path: r,
                oid: await i.oid(),
                type: h
            }
        };
        if (await i.oid() === p) return {
            cleanMerge: !0,
            mergeResult: {
                mode: y,
                path: r,
                oid: await o.oid(),
                type: h
            }
        };
        if (await o.oid() === p) return {
            cleanMerge: !0,
            mergeResult: {
                mode: y,
                path: r,
                oid: await i.oid(),
                type: h
            }
        };
        let w = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(await i.content()).toString("utf8"), v = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(await o.content()).toString("utf8"), { mergedText: g, cleanMerge: F } = await u({
            branches: [
                f,
                s,
                l
            ],
            contents: [
                m,
                w,
                v
            ],
            path: r
        }), O = await rt({
            fs: t,
            gitdir: e,
            type: "blob",
            object: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(g, "utf8"),
            dryRun: c
        });
        return {
            cleanMerge: F,
            mergeResult: {
                mode: y,
                path: r,
                oid: O,
                type: h
            }
        };
    }
    a(u$, "mergeBlobs");
    async function fS(param) {
        let { fs: t, cache: e, dir: r, gitdir: i, ours: n, theirs: o, fastForward: s = !0, fastForwardOnly: l = !1, dryRun: f = !1, noUpdateBranch: c = !1, abortOnConflict: u = !0, message: h, author: d, committer: p, signingKey: m, onSign: y, mergeDriver: w, allowUnrelatedHistories: v = !1 } = param;
        n === void 0 && (n = await Jr({
            fs: t,
            gitdir: i,
            fullname: !0
        })), n = await B.expand({
            fs: t,
            gitdir: i,
            ref: n
        }), o = await B.expand({
            fs: t,
            gitdir: i,
            ref: o
        });
        let g = await B.resolve({
            fs: t,
            gitdir: i,
            ref: n
        }), F = await B.resolve({
            fs: t,
            gitdir: i,
            ref: o
        }), O = await Cp({
            fs: t,
            cache: e,
            gitdir: i,
            oids: [
                g,
                F
            ]
        });
        if (O.length !== 1) if (O.length === 0 && v) O.push("4b825dc642cb6eb9a060e54bf8d69288fbee4904");
        else throw new Un;
        let S = O[0];
        if (S === F) return {
            oid: g,
            alreadyMerged: !0
        };
        if (s && S === g) return !f && !c && await B.writeRef({
            fs: t,
            gitdir: i,
            ref: n,
            value: F
        }), {
            oid: F,
            fastForward: !0
        };
        {
            if (l) throw new Fs;
            let R = await Fe.acquire({
                fs: t,
                gitdir: i,
                cache: e,
                allowUnmerged: !1
            }, async (x)=>f$({
                    fs: t,
                    cache: e,
                    dir: r,
                    gitdir: i,
                    index: x,
                    ourOid: g,
                    theirOid: F,
                    baseOid: S,
                    ourName: Oi(n),
                    baseName: "base",
                    theirName: Oi(o),
                    dryRun: f,
                    abortOnConflict: u,
                    mergeDriver: w
                }));
            if (R instanceof qn) throw R;
            return h || (h = "Merge branch '".concat(Oi(o), "' into ").concat(Oi(n))), {
                oid: await ef({
                    fs: t,
                    cache: e,
                    gitdir: i,
                    message: h,
                    ref: n,
                    tree: R,
                    parent: [
                        g,
                        F
                    ],
                    author: d,
                    committer: p,
                    signingKey: m,
                    onSign: y,
                    dryRun: f,
                    noUpdateBranch: c
                }),
                tree: R,
                mergeCommit: !0
            };
        }
    }
    a(fS, "_merge");
    async function uS(param) {
        let { fs: t, cache: e, http: r, onProgress: i, onMessage: n, onAuth: o, onAuthSuccess: s, onAuthFailure: l, dir: f, gitdir: c, ref: u, url: h, remote: d, remoteRef: p, prune: m, pruneTags: y, fastForward: w, fastForwardOnly: v, corsProxy: g, singleBranch: F, headers: O, author: S, committer: R, signingKey: b } = param;
        try {
            if (!u) {
                let P = await Jr({
                    fs: t,
                    gitdir: c
                });
                if (!P) throw new Qe("ref");
                u = P;
            }
            let { fetchHead: x, fetchHeadDescription: _ } = await Dp({
                fs: t,
                cache: e,
                http: r,
                onProgress: i,
                onMessage: n,
                onAuth: o,
                onAuthSuccess: s,
                onAuthFailure: l,
                gitdir: c,
                corsProxy: g,
                ref: u,
                url: h,
                remote: d,
                remoteRef: p,
                singleBranch: F,
                headers: O,
                prune: m,
                pruneTags: y
            });
            await fS({
                fs: t,
                cache: e,
                gitdir: c,
                ours: u,
                theirs: x,
                fastForward: w,
                fastForwardOnly: v,
                message: "Merge ".concat(_),
                author: S,
                committer: R,
                signingKey: b,
                dryRun: !1,
                noUpdateBranch: !1
            }), await Ap({
                fs: t,
                cache: e,
                onProgress: i,
                dir: f,
                gitdir: c,
                ref: u,
                remote: d,
                noCheckout: !1
            });
        } catch (x) {
            throw x.caller = "git.pull", x;
        }
    }
    a(uS, "_pull");
    async function hS(param) {
        let { fs: t, http: e, onProgress: r, onMessage: i, onAuth: n, onAuthSuccess: o, onAuthFailure: s, dir: l, gitdir: f = D.join(l, ".git"), ref: c, url: u, remote: h, remoteRef: d, corsProxy: p, singleBranch: m, headers: y = {}, cache: w = {} } = param;
        try {
            E("fs", t), E("http", e), E("gitdir", f);
            let v = {
                name: "",
                email: "",
                timestamp: Date.now(),
                timezoneOffset: 0
            };
            return await uS({
                fs: new M(t),
                cache: w,
                http: e,
                onProgress: r,
                onMessage: i,
                onAuth: n,
                onAuthSuccess: o,
                onAuthFailure: s,
                dir: l,
                gitdir: f,
                ref: c,
                url: u,
                remote: h,
                remoteRef: d,
                fastForwardOnly: !0,
                corsProxy: p,
                singleBranch: m,
                headers: y,
                author: v,
                committer: v
            });
        } catch (v) {
            throw v.caller = "git.fastForward", v;
        }
    }
    a(hS, "fastForward");
    async function dS(param) {
        let { fs: t, http: e, onProgress: r, onMessage: i, onAuth: n, onAuthSuccess: o, onAuthFailure: s, dir: l, gitdir: f = D.join(l, ".git"), ref: c, remote: u, remoteRef: h, url: d, corsProxy: p, depth: m = null, since: y = null, exclude: w = [], relative: v = !1, tags: g = !1, singleBranch: F = !1, headers: O = {}, prune: S = !1, pruneTags: R = !1, cache: b = {} } = param;
        try {
            return E("fs", t), E("http", e), E("gitdir", f), await Dp({
                fs: new M(t),
                cache: b,
                http: e,
                onProgress: r,
                onMessage: i,
                onAuth: n,
                onAuthSuccess: o,
                onAuthFailure: s,
                gitdir: f,
                ref: c,
                remote: u,
                remoteRef: h,
                url: d,
                corsProxy: p,
                depth: m,
                since: y,
                exclude: w,
                relative: v,
                tags: g,
                singleBranch: F,
                headers: O,
                prune: S,
                pruneTags: R
            });
        } catch (x) {
            throw x.caller = "git.fetch", x;
        }
    }
    a(dS, "fetch");
    async function pS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), oids: i, cache: n = {} } = param;
        try {
            return E("fs", t), E("gitdir", r), E("oids", i), await Cp({
                fs: new M(t),
                cache: n,
                gitdir: r,
                oids: i
            });
        } catch (o) {
            throw o.caller = "git.findMergeBase", o;
        }
    }
    a(pS, "findMergeBase");
    async function mS(param) {
        let { fs: t, filepath: e } = param;
        if (await t.exists(D.join(e, ".git"))) return e;
        {
            let r = Mn(e);
            if (r === e) throw new ce("git root for ".concat(e));
            return mS({
                fs: t,
                filepath: r
            });
        }
    }
    a(mS, "_findRoot");
    async function yS(param) {
        let { fs: t, filepath: e } = param;
        try {
            return E("fs", t), E("filepath", e), await mS({
                fs: new M(t),
                filepath: e
            });
        } catch (r) {
            throw r.caller = "git.findRoot", r;
        }
    }
    a(yS, "findRoot");
    async function wS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), path: i } = param;
        try {
            return E("fs", t), E("gitdir", r), E("path", i), await As({
                fs: new M(t),
                gitdir: r,
                path: i
            });
        } catch (n) {
            throw n.caller = "git.getConfig", n;
        }
    }
    a(wS, "getConfig");
    async function h$(param) {
        let { fs: t, gitdir: e, path: r } = param;
        return (await be.get({
            fs: t,
            gitdir: e
        })).getall(r);
    }
    a(h$, "_getConfigAll");
    async function gS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), path: i } = param;
        try {
            return E("fs", t), E("gitdir", r), E("path", i), await h$({
                fs: new M(t),
                gitdir: r,
                path: i
            });
        } catch (n) {
            throw n.caller = "git.getConfigAll", n;
        }
    }
    a(gS, "getConfigAll");
    async function bS(param) {
        let { http: t, onAuth: e, onAuthSuccess: r, onAuthFailure: i, corsProxy: n, url: o, headers: s = {}, forPush: l = !1 } = param;
        try {
            E("http", t), E("url", o);
            let c = await Zn.getRemoteHelperFor({
                url: o
            }).discover({
                http: t,
                onAuth: e,
                onAuthSuccess: r,
                onAuthFailure: i,
                corsProxy: n,
                service: l ? "git-receive-pack" : "git-upload-pack",
                url: o,
                headers: s,
                protocolVersion: 1
            }), u = {
                capabilities: [
                    ...c.capabilities
                ]
            };
            for (let [h, d] of c.refs){
                let p = h.split("/"), m = p.pop(), y = u;
                for (let w of p)y[w] = y[w] || {}, y = y[w];
                y[m] = d;
            }
            for (let [h, d] of c.symrefs){
                let p = h.split("/"), m = p.pop(), y = u;
                for (let w of p)y[w] = y[w] || {}, y = y[w];
                y[m] = d;
            }
            return u;
        } catch (f) {
            throw f.caller = "git.getRemoteInfo", f;
        }
    }
    a(bS, "getRemoteInfo");
    function vS(t, e, r, i) {
        let n = [];
        for (let [o, s] of t.refs){
            if (e && !o.startsWith(e)) continue;
            if (o.endsWith("^{}")) {
                if (i) {
                    let f = o.replace("^{}", ""), c = n[n.length - 1], u = c.ref === f ? c : n.find((h)=>h.ref === f);
                    if (u === void 0) throw new Error("I did not expect this to happen");
                    u.peeled = s;
                }
                continue;
            }
            let l = {
                ref: o,
                oid: s
            };
            r && t.symrefs.has(o) && (l.target = t.symrefs.get(o)), n.push(l);
        }
        return n;
    }
    a(vS, "formatInfoRefs");
    async function _S(param) {
        let { http: t, onAuth: e, onAuthSuccess: r, onAuthFailure: i, corsProxy: n, url: o, headers: s = {}, forPush: l = !1, protocolVersion: f = 2 } = param;
        try {
            E("http", t), E("url", o);
            let u = await Zn.getRemoteHelperFor({
                url: o
            }).discover({
                http: t,
                onAuth: e,
                onAuthSuccess: r,
                onAuthFailure: i,
                corsProxy: n,
                service: l ? "git-receive-pack" : "git-upload-pack",
                url: o,
                headers: s,
                protocolVersion: f
            });
            if (u.protocolVersion === 2) return {
                protocolVersion: u.protocolVersion,
                capabilities: u.capabilities2
            };
            let h = {};
            for (let d of u.capabilities){
                let [p, m] = d.split("=");
                m ? h[p] = m : h[p] = !0;
            }
            return {
                protocolVersion: 1,
                capabilities: h,
                refs: vS(u, void 0, !0, !0)
            };
        } catch (c) {
            throw c.caller = "git.getRemoteInfo2", c;
        }
    }
    a(_S, "getRemoteInfo2");
    async function d$(param) {
        let { type: t, object: e, format: r = "content", oid: i = void 0 } = param;
        return r !== "deflated" && (r !== "wrapped" && (e = Gr.wrap({
            type: t,
            object: e
        })), i = await gr(e)), {
            oid: i,
            object: e
        };
    }
    a(d$, "hashObject");
    async function FS(param) {
        let { object: t } = param;
        try {
            E("object", t), typeof t == "string" ? t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(t, "utf8") : t instanceof Uint8Array || (t = new Uint8Array(t));
            let e = "blob", { oid: r, object: i } = await d$({
                type: e,
                format: "content",
                object: t
            });
            return {
                oid: r,
                type: e,
                object: i,
                format: "wrapped"
            };
        } catch (e) {
            throw e.caller = "git.hashBlob", e;
        }
    }
    a(FS, "hashBlob");
    async function p$(param) {
        let { fs: t, cache: e, onProgress: r, dir: i, gitdir: n, filepath: o } = param;
        try {
            o = D.join(i, o);
            let s = await t.read(o), l = a((c)=>de({
                    fs: t,
                    cache: e,
                    gitdir: n,
                    oid: c
                }), "getExternalRefDelta"), f = await ws.fromPack({
                pack: s,
                getExternalRefDelta: l,
                onProgress: r
            });
            return await t.write(o.replace(/\.pack$/, ".idx"), await f.toBuffer()), {
                oids: [
                    ...f.hashes
                ]
            };
        } catch (s) {
            throw s.caller = "git.indexPack", s;
        }
    }
    a(p$, "_indexPack");
    async function ES(param) {
        let { fs: t, onProgress: e, dir: r, gitdir: i = D.join(r, ".git"), filepath: n, cache: o = {} } = param;
        try {
            return E("fs", t), E("dir", r), E("gitdir", r), E("filepath", n), await p$({
                fs: new M(t),
                cache: o,
                onProgress: e,
                dir: r,
                gitdir: i,
                filepath: n
            });
        } catch (s) {
            throw s.caller = "git.indexPack", s;
        }
    }
    a(ES, "indexPack");
    async function SS(param) {
        let { fs: t, bare: e = !1, dir: r, gitdir: i = e ? r : D.join(r, ".git"), defaultBranch: n = "master" } = param;
        try {
            return E("fs", t), E("gitdir", i), e || E("dir", r), await eS({
                fs: new M(t),
                bare: e,
                dir: r,
                gitdir: i,
                defaultBranch: n
            });
        } catch (o) {
            throw o.caller = "git.init", o;
        }
    }
    a(SS, "init");
    async function xS(param) {
        let { fs: t, cache: e, gitdir: r, oid: i, ancestor: n, depth: o } = param;
        let s = await ki.read({
            fs: t,
            gitdir: r
        });
        if (!i) throw new Qe("oid");
        if (!n) throw new Qe("ancestor");
        if (i === n) return !1;
        let l = [
            i
        ], f = new Set, c = 0;
        for(; l.length;){
            if (c++ === o) throw new Ss(o);
            let u = l.shift(), { type: h, object: d } = await de({
                fs: t,
                cache: e,
                gitdir: r,
                oid: u
            });
            if (h !== "commit") throw new Ze(u, h, "commit");
            let p = tt.from(d).parse();
            for (let m of p.parent)if (m === n) return !0;
            if (!s.has(u)) for (let m of p.parent)f.has(m) || (l.push(m), f.add(m));
        }
        return !1;
    }
    a(xS, "_isDescendent");
    async function TS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), oid: i, ancestor: n, depth: o = -1, cache: s = {} } = param;
        try {
            return E("fs", t), E("gitdir", r), E("oid", i), E("ancestor", n), await xS({
                fs: new M(t),
                cache: s,
                gitdir: r,
                oid: i,
                ancestor: n,
                depth: o
            });
        } catch (l) {
            throw l.caller = "git.isDescendent", l;
        }
    }
    a(TS, "isDescendent");
    async function OS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), filepath: i } = param;
        try {
            return E("fs", t), E("dir", e), E("gitdir", r), E("filepath", i), Xr.isIgnored({
                fs: new M(t),
                dir: e,
                gitdir: r,
                filepath: i
            });
        } catch (n) {
            throw n.caller = "git.isIgnored", n;
        }
    }
    a(OS, "isIgnored");
    async function RS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), remote: i } = param;
        try {
            return E("fs", t), E("gitdir", r), B.listBranches({
                fs: new M(t),
                gitdir: r,
                remote: i
            });
        } catch (n) {
            throw n.caller = "git.listBranches", n;
        }
    }
    a(RS, "listBranches");
    async function m$(param) {
        let { fs: t, gitdir: e, ref: r, cache: i } = param;
        if (r) {
            let n = await B.resolve({
                gitdir: e,
                fs: t,
                ref: r
            }), o = [];
            return await kS({
                fs: t,
                cache: i,
                gitdir: e,
                oid: n,
                filenames: o,
                prefix: ""
            }), o;
        } else return Fe.acquire({
            fs: t,
            gitdir: e,
            cache: i
        }, async function(n) {
            return n.entries.map((o)=>o.path);
        });
    }
    a(m$, "_listFiles");
    async function kS(param) {
        let { fs: t, cache: e, gitdir: r, oid: i, filenames: n, prefix: o } = param;
        let { tree: s } = await Jn({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i
        });
        for (let l of s)l.type === "tree" ? await kS({
            fs: t,
            cache: e,
            gitdir: r,
            oid: l.oid,
            filenames: n,
            prefix: D.join(o, l.path)
        }) : n.push(D.join(o, l.path));
    }
    a(kS, "accumulateFilesFromOid");
    async function PS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), ref: i, cache: n = {} } = param;
        try {
            return E("fs", t), E("gitdir", r), await m$({
                fs: new M(t),
                cache: n,
                gitdir: r,
                ref: i
            });
        } catch (o) {
            throw o.caller = "git.listFiles", o;
        }
    }
    a(PS, "listFiles");
    async function y$(param) {
        let { fs: t, cache: e, gitdir: r, ref: i } = param;
        let n;
        try {
            n = await B.resolve({
                gitdir: r,
                fs: t,
                ref: i
            });
        } catch (l) {
            if (l instanceof ce) return [];
        }
        return (await Jn({
            fs: t,
            cache: e,
            gitdir: r,
            oid: n
        })).tree.map((l)=>({
                target: l.path,
                note: l.oid
            }));
    }
    a(y$, "_listNotes");
    async function AS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), ref: i = "refs/notes/commits", cache: n = {} } = param;
        try {
            return E("fs", t), E("gitdir", r), E("ref", i), await y$({
                fs: new M(t),
                cache: n,
                gitdir: r,
                ref: i
            });
        } catch (o) {
            throw o.caller = "git.listNotes", o;
        }
    }
    a(AS, "listNotes");
    async function IS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), filepath: i } = param;
        try {
            return E("fs", t), E("gitdir", r), B.listRefs({
                fs: new M(t),
                gitdir: r,
                filepath: i
            });
        } catch (n) {
            throw n.caller = "git.listRefs", n;
        }
    }
    a(IS, "listRefs");
    async function w$(param) {
        let { fs: t, gitdir: e } = param;
        let r = await be.get({
            fs: t,
            gitdir: e
        }), i = await r.getSubsections("remote");
        return Promise.all(i.map(async (o)=>{
            let s = await r.get("remote.".concat(o, ".url"));
            return {
                remote: o,
                url: s
            };
        }));
    }
    a(w$, "_listRemotes");
    async function DS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git") } = param;
        try {
            return E("fs", t), E("gitdir", r), await w$({
                fs: new M(t),
                gitdir: r
            });
        } catch (i) {
            throw i.caller = "git.listRemotes", i;
        }
    }
    a(DS, "listRemotes");
    async function g$(t) {
        let e = ye.streamReader(t), r = [], i;
        for(; i = await e(), i !== !0;){
            if (i === null) continue;
            i = i.toString("utf8").replace(/\n$/, "");
            let [n, o, ...s] = i.split(" "), l = {
                ref: o,
                oid: n
            };
            for (let f of s){
                let [c, u] = f.split(":");
                c === "symref-target" ? l.target = u : c === "peeled" && (l.peeled = u);
            }
            r.push(l);
        }
        return r;
    }
    a(g$, "parseListRefsResponse");
    async function b$(param) {
        let { prefix: t, symrefs: e, peelTags: r } = param;
        let i = [];
        return i.push(ye.encode("command=ls-refs\n")), i.push(ye.encode("agent=".concat(tf.agent, "\n"))), (r || e || t) && i.push(ye.delim()), r && i.push(ye.encode("peel")), e && i.push(ye.encode("symrefs")), t && i.push(ye.encode("ref-prefix ".concat(t))), i.push(ye.flush()), i;
    }
    a(b$, "writeListRefsRequest");
    async function CS(param) {
        let { http: t, onAuth: e, onAuthSuccess: r, onAuthFailure: i, corsProxy: n, url: o, headers: s = {}, forPush: l = !1, protocolVersion: f = 2, prefix: c, symrefs: u, peelTags: h } = param;
        try {
            E("http", t), E("url", o);
            let d = await Kn.discover({
                http: t,
                onAuth: e,
                onAuthSuccess: r,
                onAuthFailure: i,
                corsProxy: n,
                service: l ? "git-receive-pack" : "git-upload-pack",
                url: o,
                headers: s,
                protocolVersion: f
            });
            if (d.protocolVersion === 1) return vS(d, c, u, h);
            let p = await b$({
                prefix: c,
                symrefs: u,
                peelTags: h
            }), m = await Kn.connect({
                http: t,
                auth: d.auth,
                headers: s,
                corsProxy: n,
                service: l ? "git-receive-pack" : "git-upload-pack",
                url: o,
                body: p
            });
            return g$(m.body);
        } catch (d) {
            throw d.caller = "git.listServerRefs", d;
        }
    }
    a(CS, "listServerRefs");
    async function NS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git") } = param;
        try {
            return E("fs", t), E("gitdir", r), B.listTags({
                fs: new M(t),
                gitdir: r
            });
        } catch (i) {
            throw i.caller = "git.listTags", i;
        }
    }
    a(NS, "listTags");
    function v$(t, e) {
        return t.committer.timestamp - e.committer.timestamp;
    }
    a(v$, "compareAge");
    var _$ = "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";
    async function SE(param) {
        let { fs: t, cache: e, gitdir: r, oid: i, fileId: n } = param;
        if (n === _$) return;
        let o = i, s, l = await Wn({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i
        }), f = l.tree;
        return n === l.oid ? s = l.path : (s = await BS({
            fs: t,
            cache: e,
            gitdir: r,
            tree: f,
            fileId: n,
            oid: o
        }), Array.isArray(s) && (s.length === 0 ? s = void 0 : s.length === 1 && (s = s[0]))), s;
    }
    a(SE, "resolveFileIdInTree");
    async function BS(param) {
        let { fs: t, cache: e, gitdir: r, tree: i, fileId: n, oid: o, filepaths: s = [], parentPath: l = "" } = param;
        let f = i.entries().map(function(c) {
            let u;
            return c.oid === n ? (u = D.join(l, c.path), s.push(u)) : c.type === "tree" && (u = de({
                fs: t,
                cache: e,
                gitdir: r,
                oid: c.oid
            }).then(function(param) {
                let { object: h } = param;
                return BS({
                    fs: t,
                    cache: e,
                    gitdir: r,
                    tree: et.from(h),
                    fileId: n,
                    oid: o,
                    filepaths: s,
                    parentPath: D.join(l, c.path)
                });
            })), u;
        });
        return await Promise.all(f), s;
    }
    a(BS, "_resolveFileId");
    async function F$(param) {
        let { fs: t, cache: e, gitdir: r, filepath: i, ref: n, depth: o, since: s, force: l, follow: f } = param;
        let c = typeof s > "u" ? void 0 : Math.floor(s.valueOf() / 1e3), u = [], h = await ki.read({
            fs: t,
            gitdir: r
        }), d = await B.resolve({
            fs: t,
            gitdir: r,
            ref: n
        }), p = [
            await Gn({
                fs: t,
                cache: e,
                gitdir: r,
                oid: d
            })
        ], m, y, w;
        function v(g) {
            w && i && u.push(g);
        }
        for(a(v, "endCommit"); p.length > 0;){
            let g = p.pop();
            if (c !== void 0 && g.commit.committer.timestamp <= c) break;
            if (i) {
                let F;
                try {
                    F = await Is({
                        fs: t,
                        cache: e,
                        gitdir: r,
                        oid: g.commit.tree,
                        filepath: i
                    }), y && m !== F && u.push(y), m = F, y = g, w = !0;
                } catch (O) {
                    if (O instanceof ce) {
                        let S = f && m;
                        if (S && (S = await SE({
                            fs: t,
                            cache: e,
                            gitdir: r,
                            oid: g.commit.tree,
                            fileId: m
                        }), S)) if (Array.isArray(S)) {
                            if (y) {
                                let R = await SE({
                                    fs: t,
                                    cache: e,
                                    gitdir: r,
                                    oid: y.commit.tree,
                                    fileId: m
                                });
                                if (Array.isArray(R)) if (S = S.filter((b)=>R.indexOf(b) === -1), S.length === 1) S = S[0], i = S, y && u.push(y);
                                else {
                                    S = !1, y && u.push(y);
                                    break;
                                }
                            }
                        } else i = S, y && u.push(y);
                        if (!S) {
                            if (w && m && (u.push(y), !l)) break;
                            if (!l && !f) throw O;
                        }
                        y = g, w = !1;
                    } else throw O;
                }
            } else u.push(g);
            if (o !== void 0 && u.length === o) {
                v(g);
                break;
            }
            if (!h.has(g.oid)) for (let F of g.commit.parent){
                let O = await Gn({
                    fs: t,
                    cache: e,
                    gitdir: r,
                    oid: F
                });
                p.map((S)=>S.oid).includes(O.oid) || p.push(O);
            }
            p.length === 0 && v(g), p.sort((F, O)=>v$(F.commit, O.commit));
        }
        return u;
    }
    a(F$, "_log");
    async function LS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), filepath: i, ref: n = "HEAD", depth: o, since: s, force: l, follow: f, cache: c = {} } = param;
        try {
            return E("fs", t), E("gitdir", r), E("ref", n), await F$({
                fs: new M(t),
                cache: c,
                gitdir: r,
                filepath: i,
                ref: n,
                depth: o,
                since: s,
                force: l,
                follow: f
            });
        } catch (u) {
            throw u.caller = "git.log", u;
        }
    }
    a(LS, "log");
    async function $S(param) {
        let { fs: t, onSign: e, dir: r, gitdir: i = D.join(r, ".git"), ours: n, theirs: o, fastForward: s = !0, fastForwardOnly: l = !1, dryRun: f = !1, noUpdateBranch: c = !1, abortOnConflict: u = !0, message: h, author: d, committer: p, signingKey: m, cache: y = {}, mergeDriver: w, allowUnrelatedHistories: v = !1 } = param;
        try {
            E("fs", t), m && E("onSign", e);
            let g = new M(t), F = await Yr({
                fs: g,
                gitdir: i,
                author: d
            });
            if (!F && (!l || !s)) throw new He("author");
            let O = await Vn({
                fs: g,
                gitdir: i,
                author: F,
                committer: p
            });
            if (!O && (!l || !s)) throw new He("committer");
            return await fS({
                fs: g,
                cache: y,
                dir: r,
                gitdir: i,
                ours: n,
                theirs: o,
                fastForward: s,
                fastForwardOnly: l,
                dryRun: f,
                noUpdateBranch: c,
                abortOnConflict: u,
                message: h,
                author: F,
                committer: O,
                signingKey: m,
                onSign: e,
                mergeDriver: w,
                allowUnrelatedHistories: v
            });
        } catch (g) {
            throw g.caller = "git.merge", g;
        }
    }
    a($S, "merge");
    var E$ = {
        commit: 16,
        tree: 32,
        blob: 48,
        tag: 64,
        ofs_delta: 96,
        ref_delta: 112
    };
    async function MS(param) {
        let { fs: t, cache: e, dir: r, gitdir: i = D.join(r, ".git"), oids: n } = param;
        let o = new TE, s = [];
        function l(u, h) {
            let d = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(u, h);
            s.push(d), o.update(d);
        }
        a(l, "write");
        async function f(param) {
            let { stype: u, object: h } = param;
            let d = E$[u], p = h.length, m = p > 15 ? 128 : 0, y = p & 15;
            p = p >>> 4;
            let w = (m | d | y).toString(16);
            for(l(w, "hex"); m;)m = p > 127 ? 128 : 0, w = m | p & 127, l(Rp(2, w), "hex"), p = p >>> 7;
            l(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(await $E(h)));
        }
        a(f, "writeObject"), l("PACK"), l("00000002", "hex"), l(Rp(8, n.length), "hex");
        for (let u of n){
            let { type: h, object: d } = await de({
                fs: t,
                cache: e,
                gitdir: i,
                oid: u
            });
            await f({
                write: l,
                object: d,
                stype: h
            });
        }
        let c = o.digest();
        return s.push(c), s;
    }
    a(MS, "_pack");
    async function S$(param) {
        let { fs: t, cache: e, gitdir: r, oids: i, write: n } = param;
        let o = await MS({
            fs: t,
            cache: e,
            gitdir: r,
            oids: i
        }), s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(await fc(o)), f = "pack-".concat(s.slice(-20).toString("hex"), ".pack");
        return n ? (await t.write(D.join(r, "objects/pack/".concat(f)), s), {
            filename: f
        }) : {
            filename: f,
            packfile: new Uint8Array(s)
        };
    }
    a(S$, "_packObjects");
    async function jS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), oids: i, write: n = !1, cache: o = {} } = param;
        try {
            return E("fs", t), E("gitdir", r), E("oids", i), await S$({
                fs: new M(t),
                cache: o,
                gitdir: r,
                oids: i,
                write: n
            });
        } catch (s) {
            throw s.caller = "git.packObjects", s;
        }
    }
    a(jS, "packObjects");
    async function US(param) {
        let { fs: t, http: e, onProgress: r, onMessage: i, onAuth: n, onAuthSuccess: o, onAuthFailure: s, dir: l, gitdir: f = D.join(l, ".git"), ref: c, url: u, remote: h, remoteRef: d, prune: p = !1, pruneTags: m = !1, fastForward: y = !0, fastForwardOnly: w = !1, corsProxy: v, singleBranch: g, headers: F = {}, author: O, committer: S, signingKey: R, cache: b = {} } = param;
        try {
            E("fs", t), E("gitdir", f);
            let x = new M(t), _ = await Yr({
                fs: x,
                gitdir: f,
                author: O
            });
            if (!_) throw new He("author");
            let P = await Vn({
                fs: x,
                gitdir: f,
                author: _,
                committer: S
            });
            if (!P) throw new He("committer");
            return await uS({
                fs: x,
                cache: b,
                http: e,
                onProgress: r,
                onMessage: i,
                onAuth: n,
                onAuthSuccess: o,
                onAuthFailure: s,
                dir: l,
                gitdir: f,
                ref: c,
                url: u,
                remote: h,
                remoteRef: d,
                fastForward: y,
                fastForwardOnly: w,
                corsProxy: v,
                singleBranch: g,
                headers: F,
                author: _,
                committer: P,
                signingKey: R,
                prune: p,
                pruneTags: m
            });
        } catch (x) {
            throw x.caller = "git.pull", x;
        }
    }
    a(US, "pull");
    async function x$(param) {
        let { fs: t, cache: e, dir: r, gitdir: i = D.join(r, ".git"), start: n, finish: o } = param;
        let s = await ki.read({
            fs: t,
            gitdir: i
        }), l = new Set, f = new Set;
        for (let h of n)l.add(await B.resolve({
            fs: t,
            gitdir: i,
            ref: h
        }));
        for (let h of o)try {
            let d = await B.resolve({
                fs: t,
                gitdir: i,
                ref: h
            });
            f.add(d);
        } catch (e) {}
        let c = new Set;
        async function u(h) {
            c.add(h);
            let { type: d, object: p } = await de({
                fs: t,
                cache: e,
                gitdir: i,
                oid: h
            });
            if (d === "tag") {
                let y = ft.from(p).headers().object;
                return u(y);
            }
            if (d !== "commit") throw new Ze(h, d, "commit");
            if (!s.has(h)) {
                let y = tt.from(p).headers().parent;
                for (h of y)!f.has(h) && !c.has(h) && await u(h);
            }
        }
        a(u, "walk");
        for (let h of l)await u(h);
        return c;
    }
    a(x$, "listCommitsAndTags");
    async function mp(param) {
        let { fs: t, cache: e, dir: r, gitdir: i = D.join(r, ".git"), oids: n } = param;
        let o = new Set;
        async function s(l) {
            if (o.has(l)) return;
            o.add(l);
            let { type: f, object: c } = await de({
                fs: t,
                cache: e,
                gitdir: i,
                oid: l
            });
            if (f === "tag") {
                let h = ft.from(c).headers().object;
                await s(h);
            } else if (f === "commit") {
                let h = tt.from(c).headers().tree;
                await s(h);
            } else if (f === "tree") {
                let u = et.from(c);
                for (let h of u)h.type === "blob" && o.add(h.oid), h.type === "tree" && await s(h.oid);
            }
        }
        a(s, "walk");
        for (let l of n)await s(l);
        return o;
    }
    a(mp, "listObjects");
    async function T$(t) {
        let e = {}, r = "", i = ye.streamReader(t), n = await i();
        for(; n !== !0;)n !== null && (r += n.toString("utf8") + "\n"), n = await i();
        let o = r.toString("utf8").split("\n");
        if (n = o.shift(), !n.startsWith("unpack ")) throw new Ri('unpack ok" or "unpack [error message]', n);
        e.ok = n === "unpack ok", e.ok || (e.error = n.slice(7)), e.refs = {};
        for (let s of o){
            if (s.trim() === "") continue;
            let l = s.slice(0, 2), f = s.slice(3), c = f.indexOf(" ");
            c === -1 && (c = f.length);
            let u = f.slice(0, c), h = f.slice(c + 1);
            e.refs[u] = {
                ok: l === "ok",
                error: h
            };
        }
        return e;
    }
    a(T$, "parseReceivePackResponse");
    async function O$(param) {
        let { capabilities: t = [], triplets: e = [] } = param;
        let r = [], i = "\0 ".concat(t.join(" "));
        for (let n of e)r.push(ye.encode("".concat(n.oldoid, " ").concat(n.oid, " ").concat(n.fullRef).concat(i, "\n"))), i = "";
        return r.push(ye.flush()), r;
    }
    a(O$, "writeReceivePackRequest");
    async function R$(param) {
        let { fs: t, cache: e, http: r, onProgress: i, onMessage: n, onAuth: o, onAuthSuccess: s, onAuthFailure: l, onPrePush: f, gitdir: c, ref: u, remoteRef: h, remote: d, url: p, force: m = !1, delete: y = !1, corsProxy: w, headers: v = {} } = param;
        let g = u || await Jr({
            fs: t,
            gitdir: c
        });
        if (typeof g > "u") throw new Qe("ref");
        let F = await be.get({
            fs: t,
            gitdir: c
        });
        d = d || await F.get("branch.".concat(g, ".pushRemote")) || await F.get("remote.pushDefault") || await F.get("branch.".concat(g, ".remote")) || "origin";
        let O = p || await F.get("remote.".concat(d, ".pushurl")) || await F.get("remote.".concat(d, ".url"));
        if (typeof O > "u") throw new Qe("remote OR url");
        let S = h || await F.get("branch.".concat(g, ".merge"));
        if (typeof O > "u") throw new Qe("remoteRef");
        w === void 0 && (w = await F.get("http.corsProxy"));
        let R = await B.expand({
            fs: t,
            gitdir: c,
            ref: g
        }), b = y ? "0000000000000000000000000000000000000000" : await B.resolve({
            fs: t,
            gitdir: c,
            ref: R
        }), x = Zn.getRemoteHelperFor({
            url: O
        }), _ = await x.discover({
            http: r,
            onAuth: o,
            onAuthSuccess: s,
            onAuthFailure: l,
            corsProxy: w,
            service: "git-receive-pack",
            url: O,
            headers: v,
            protocolVersion: 1
        }), P = _.auth, k;
        if (!S) k = R;
        else try {
            k = await B.expandAgainstMap({
                ref: S,
                map: _.refs
            });
        } catch (z) {
            if (z instanceof ce) k = S.startsWith("refs/") ? S : "refs/heads/".concat(S);
            else throw z;
        }
        let C = _.refs.get(k) || "0000000000000000000000000000000000000000";
        if (f && !await f({
            remote: d,
            url: O,
            localRef: {
                ref: y ? "(delete)" : R,
                oid: b
            },
            remoteRef: {
                ref: k,
                oid: C
            }
        })) throw new zn;
        let N = !_.capabilities.has("no-thin"), U = new Set;
        if (!y) {
            let z = [
                ..._.refs.values()
            ], fe = new Set;
            if (C !== "0000000000000000000000000000000000000000") {
                let ee = await Cp({
                    fs: t,
                    cache: e,
                    gitdir: c,
                    oids: [
                        b,
                        C
                    ]
                });
                for (let Oe of ee)z.push(Oe);
                N && (fe = await mp({
                    fs: t,
                    cache: e,
                    gitdir: c,
                    oids: ee
                }));
            }
            if (!z.includes(b)) {
                let ee = await x$({
                    fs: t,
                    cache: e,
                    gitdir: c,
                    start: [
                        b
                    ],
                    finish: z
                });
                U = await mp({
                    fs: t,
                    cache: e,
                    gitdir: c,
                    oids: ee
                });
            }
            if (N) {
                try {
                    let ee = await B.resolve({
                        fs: t,
                        gitdir: c,
                        ref: "refs/remotes/".concat(d, "/HEAD"),
                        depth: 2
                    }), { oid: Oe } = await B.resolveAgainstMap({
                        ref: ee.replace("refs/remotes/".concat(d, "/"), ""),
                        fullref: ee,
                        map: _.refs
                    }), Re = [
                        Oe
                    ];
                    for (let se of (await mp({
                        fs: t,
                        cache: e,
                        gitdir: c,
                        oids: Re
                    })))fe.add(se);
                } catch (e) {}
                for (let ee of fe)U.delete(ee);
            }
            if (b === C && (m = !0), !m) {
                if (R.startsWith("refs/tags") && C !== "0000000000000000000000000000000000000000") throw new Hn("tag-exists");
                if (b !== "0000000000000000000000000000000000000000" && C !== "0000000000000000000000000000000000000000" && !await xS({
                    fs: t,
                    cache: e,
                    gitdir: c,
                    oid: b,
                    ancestor: C,
                    depth: -1
                })) throw new Hn("not-fast-forward");
            }
        }
        let Z = JE([
            ..._.capabilities
        ], [
            "report-status",
            "side-band-64k",
            "agent=".concat(tf.agent)
        ]), me = await O$({
            capabilities: Z,
            triplets: [
                {
                    oldoid: C,
                    oid: b,
                    fullRef: k
                }
            ]
        }), Ee = y ? [] : await MS({
            fs: t,
            cache: e,
            gitdir: c,
            oids: [
                ...U
            ]
        }), $ = await x.connect({
            http: r,
            onProgress: i,
            corsProxy: w,
            service: "git-receive-pack",
            url: O,
            auth: P,
            headers: v,
            body: [
                ...me,
                ...Ee
            ]
        }), { packfile: H, progress: G } = await uc.demux($.body);
        if (n) {
            let z = QE(G);
            Cs(z, async (fe)=>{
                await n(fe);
            });
        }
        let X = await T$(H);
        if ($.headers && (X.headers = $.headers), d && X.ok && X.refs[k].ok && !R.startsWith("refs/tags")) {
            let z = "refs/remotes/".concat(d, "/").concat(k.replace("refs/heads", ""));
            y ? await B.deleteRef({
                fs: t,
                gitdir: c,
                ref: z
            }) : await B.writeRef({
                fs: t,
                gitdir: c,
                ref: z,
                value: b
            });
        }
        if (X.ok && Object.values(X.refs).every((z)=>z.ok)) return X;
        {
            let z = Object.entries(X.refs).filter((param)=>{
                let [fe, ee] = param;
                return !ee.ok;
            }).map((param)=>{
                let [fe, ee] = param;
                return "\n  - ".concat(fe, ": ").concat(ee.error);
            }).join("");
            throw new Es(z, X);
        }
    }
    a(R$, "_push");
    async function qS(param) {
        let { fs: t, http: e, onProgress: r, onMessage: i, onAuth: n, onAuthSuccess: o, onAuthFailure: s, onPrePush: l, dir: f, gitdir: c = D.join(f, ".git"), ref: u, remoteRef: h, remote: d = "origin", url: p, force: m = !1, delete: y = !1, corsProxy: w, headers: v = {}, cache: g = {} } = param;
        try {
            return E("fs", t), E("http", e), E("gitdir", c), await R$({
                fs: new M(t),
                cache: g,
                http: e,
                onProgress: r,
                onMessage: i,
                onAuth: n,
                onAuthSuccess: o,
                onAuthFailure: s,
                onPrePush: l,
                gitdir: c,
                ref: u,
                remoteRef: h,
                remote: d,
                url: p,
                force: m,
                delete: y,
                corsProxy: w,
                headers: v
            });
        } catch (F) {
            throw F.caller = "git.push", F;
        }
    }
    a(qS, "push");
    async function HS(param) {
        let { fs: t, cache: e, gitdir: r, oid: i } = param;
        let { type: n, object: o } = await de({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i
        });
        if (n === "tag") return i = ft.from(o).parse().object, HS({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i
        });
        if (n !== "blob") throw new Ze(i, n, "blob");
        return {
            oid: i,
            blob: new Uint8Array(o)
        };
    }
    a(HS, "resolveBlob");
    async function zS(param) {
        let { fs: t, cache: e, gitdir: r, oid: i, filepath: n = void 0 } = param;
        return n !== void 0 && (i = await Is({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i,
            filepath: n
        })), await HS({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i
        });
    }
    a(zS, "_readBlob");
    async function WS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), oid: i, filepath: n, cache: o = {} } = param;
        try {
            return E("fs", t), E("gitdir", r), E("oid", i), await zS({
                fs: new M(t),
                cache: o,
                gitdir: r,
                oid: i,
                filepath: n
            });
        } catch (s) {
            throw s.caller = "git.readBlob", s;
        }
    }
    a(WS, "readBlob");
    async function Np(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), oid: i, cache: n = {} } = param;
        try {
            return E("fs", t), E("gitdir", r), E("oid", i), await Gn({
                fs: new M(t),
                cache: n,
                gitdir: r,
                oid: i
            });
        } catch (o) {
            throw o.caller = "git.readCommit", o;
        }
    }
    a(Np, "readCommit");
    async function k$(param) {
        let { fs: t, cache: e, gitdir: r, ref: i = "refs/notes/commits", oid: n } = param;
        let o = await B.resolve({
            gitdir: r,
            fs: t,
            ref: i
        }), { blob: s } = await zS({
            fs: t,
            cache: e,
            gitdir: r,
            oid: o,
            filepath: n
        });
        return s;
    }
    a(k$, "_readNote");
    async function VS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), ref: i = "refs/notes/commits", oid: n, cache: o = {} } = param;
        try {
            return E("fs", t), E("gitdir", r), E("ref", i), E("oid", n), await k$({
                fs: new M(t),
                cache: o,
                gitdir: r,
                ref: i,
                oid: n
            });
        } catch (s) {
            throw s.caller = "git.readNote", s;
        }
    }
    a(VS, "readNote");
    async function GS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), oid: i, format: n = "parsed", filepath: o = void 0, encoding: s = void 0, cache: l = {} } = param;
        try {
            E("fs", t), E("gitdir", r), E("oid", i);
            let f = new M(t);
            o !== void 0 && (i = await Is({
                fs: f,
                cache: l,
                gitdir: r,
                oid: i,
                filepath: o
            }));
            let u = await de({
                fs: f,
                cache: l,
                gitdir: r,
                oid: i,
                format: n === "parsed" ? "content" : n
            });
            if (u.oid = i, n === "parsed") switch(u.format = "parsed", u.type){
                case "commit":
                    u.object = tt.from(u.object).parse();
                    break;
                case "tree":
                    u.object = et.from(u.object).entries();
                    break;
                case "blob":
                    s ? u.object = u.object.toString(s) : (u.object = new Uint8Array(u.object), u.format = "content");
                    break;
                case "tag":
                    u.object = ft.from(u.object).parse();
                    break;
                default:
                    throw new Ze(u.oid, u.type, "blob|commit|tag|tree");
            }
            else (u.format === "deflated" || u.format === "wrapped") && (u.type = u.format);
            return u;
        } catch (f) {
            throw f.caller = "git.readObject", f;
        }
    }
    a(GS, "readObject");
    async function P$(param) {
        let { fs: t, cache: e, gitdir: r, oid: i } = param;
        let { type: n, object: o } = await de({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i,
            format: "content"
        });
        if (n !== "tag") throw new Ze(i, n, "tag");
        let s = ft.from(o);
        return {
            oid: i,
            tag: s.parse(),
            payload: s.payload()
        };
    }
    a(P$, "_readTag");
    async function KS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), oid: i, cache: n = {} } = param;
        try {
            return E("fs", t), E("gitdir", r), E("oid", i), await P$({
                fs: new M(t),
                cache: n,
                gitdir: r,
                oid: i
            });
        } catch (o) {
            throw o.caller = "git.readTag", o;
        }
    }
    a(KS, "readTag");
    async function ZS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), oid: i, filepath: n = void 0, cache: o = {} } = param;
        try {
            return E("fs", t), E("gitdir", r), E("oid", i), await Jn({
                fs: new M(t),
                cache: o,
                gitdir: r,
                oid: i,
                filepath: n
            });
        } catch (s) {
            throw s.caller = "git.readTree", s;
        }
    }
    a(ZS, "readTree");
    async function XS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), filepath: i, cache: n = {} } = param;
        try {
            E("fs", t), E("gitdir", r), E("filepath", i), await Fe.acquire({
                fs: new M(t),
                gitdir: r,
                cache: n
            }, async function(o) {
                o.delete({
                    filepath: i
                });
            });
        } catch (o) {
            throw o.caller = "git.remove", o;
        }
    }
    a(XS, "remove");
    async function A$(param) {
        let { fs: t, cache: e, onSign: r, gitdir: i, ref: n = "refs/notes/commits", oid: o, author: s, committer: l, signingKey: f } = param;
        let c;
        try {
            c = await B.resolve({
                gitdir: i,
                fs: t,
                ref: n
            });
        } catch (m) {
            if (!(m instanceof ce)) throw m;
        }
        let h = (await Jn({
            fs: t,
            gitdir: i,
            oid: c || "4b825dc642cb6eb9a060e54bf8d69288fbee4904"
        })).tree;
        h = h.filter((m)=>m.path !== o);
        let d = await Ds({
            fs: t,
            gitdir: i,
            tree: h
        });
        return await ef({
            fs: t,
            cache: e,
            onSign: r,
            gitdir: i,
            ref: n,
            tree: d,
            parent: c && [
                c
            ],
            message: "Note removed by 'isomorphic-git removeNote'\n",
            author: s,
            committer: l,
            signingKey: f
        });
    }
    a(A$, "_removeNote");
    async function YS(param) {
        let { fs: t, onSign: e, dir: r, gitdir: i = D.join(r, ".git"), ref: n = "refs/notes/commits", oid: o, author: s, committer: l, signingKey: f, cache: c = {} } = param;
        try {
            E("fs", t), E("gitdir", i), E("oid", o);
            let u = new M(t), h = await Yr({
                fs: u,
                gitdir: i,
                author: s
            });
            if (!h) throw new He("author");
            let d = await Vn({
                fs: u,
                gitdir: i,
                author: h,
                committer: l
            });
            if (!d) throw new He("committer");
            return await A$({
                fs: u,
                cache: c,
                onSign: e,
                gitdir: i,
                ref: n,
                oid: o,
                author: h,
                committer: d,
                signingKey: f
            });
        } catch (u) {
            throw u.caller = "git.removeNote", u;
        }
    }
    a(YS, "removeNote");
    async function I$(param) {
        let { fs: t, gitdir: e, oldref: r, ref: i, checkout: n = !1 } = param;
        if (!ps(i, !0)) throw new Nt(i, ds.clean(i));
        if (!ps(r, !0)) throw new Nt(r, ds.clean(r));
        let o = "refs/heads/".concat(r), s = "refs/heads/".concat(i);
        if (await B.exists({
            fs: t,
            gitdir: e,
            ref: s
        })) throw new Ct("branch", i, !1);
        let f = await B.resolve({
            fs: t,
            gitdir: e,
            ref: o,
            depth: 1
        });
        await B.writeRef({
            fs: t,
            gitdir: e,
            ref: s,
            value: f
        }), await B.deleteRef({
            fs: t,
            gitdir: e,
            ref: o
        });
        let u = await Jr({
            fs: t,
            gitdir: e,
            fullname: !0
        }) === o;
        (n || u) && await B.writeSymbolicRef({
            fs: t,
            gitdir: e,
            ref: "HEAD",
            value: s
        });
    }
    a(I$, "_renameBranch");
    async function JS(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), ref: i, oldref: n, checkout: o = !1 } = param;
        try {
            return E("fs", t), E("gitdir", r), E("ref", i), E("oldref", n), await I$({
                fs: new M(t),
                gitdir: r,
                ref: i,
                oldref: n,
                checkout: o
            });
        } catch (s) {
            throw s.caller = "git.renameBranch", s;
        }
    }
    a(JS, "renameBranch");
    async function QS(param) {
        let { gitdir: t, type: e, object: r } = param;
        return gr(Gr.wrap({
            type: e,
            object: r
        }));
    }
    a(QS, "hashObject$1");
    async function e1(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), filepath: i, ref: n, cache: o = {} } = param;
        try {
            E("fs", t), E("gitdir", r), E("filepath", i);
            let s = new M(t), l, f;
            try {
                l = await B.resolve({
                    fs: s,
                    gitdir: r,
                    ref: n || "HEAD"
                });
            } catch (h) {
                if (n) throw h;
            }
            if (l) try {
                l = await Is({
                    fs: s,
                    cache: o,
                    gitdir: r,
                    oid: l,
                    filepath: i
                });
            } catch (e) {
                l = null;
            }
            let c = {
                ctime: new Date(0),
                mtime: new Date(0),
                dev: 0,
                ino: 0,
                mode: 0,
                uid: 0,
                gid: 0,
                size: 0
            }, u = e && await s.read(D.join(e, i));
            u && (f = await QS({
                gitdir: r,
                type: "blob",
                object: u
            }), l === f && (c = await s.lstat(D.join(e, i)))), await Fe.acquire({
                fs: s,
                gitdir: r,
                cache: o
            }, async function(h) {
                h.delete({
                    filepath: i
                }), l && h.insert({
                    filepath: i,
                    stats: c,
                    oid: l
                });
            });
        } catch (s) {
            throw s.caller = "git.reset", s;
        }
    }
    a(e1, "resetIndex");
    async function t1(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), ref: i, depth: n } = param;
        try {
            return E("fs", t), E("gitdir", r), E("ref", i), await B.resolve({
                fs: new M(t),
                gitdir: r,
                ref: i,
                depth: n
            });
        } catch (o) {
            throw o.caller = "git.resolveRef", o;
        }
    }
    a(t1, "resolveRef");
    async function r1(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), path: i, value: n, append: o = !1 } = param;
        try {
            E("fs", t), E("gitdir", r), E("path", i);
            let s = new M(t), l = await be.get({
                fs: s,
                gitdir: r
            });
            o ? await l.append(i, n) : await l.set(i, n), await be.save({
                fs: s,
                gitdir: r,
                config: l
            });
        } catch (s) {
            throw s.caller = "git.setConfig", s;
        }
    }
    a(r1, "setConfig");
    async function i1(param) {
        let { fs: t, gitdir: e, commit: r } = param;
        let i = tt.from(r).toObject();
        return await rt({
            fs: t,
            gitdir: e,
            type: "commit",
            object: i,
            format: "content"
        });
    }
    a(i1, "_writeCommit");
    var Yc = class Yc {
        static get timezoneOffsetForRefLogEntry() {
            let e = new Date().getTimezoneOffset(), r = Math.abs(Math.floor(e / 60)), i = Math.abs(e % 60).toString().padStart(2, "0");
            return "".concat(e > 0 ? "-" : "+").concat(r.toString().padStart(2, "0")).concat(i);
        }
        static createStashReflogEntry(e, r, i) {
            let n = e.name.replace(/\s/g, ""), o = "0000000000000000000000000000000000000000", s = Math.floor(Date.now() / 1e3), l = Yc.timezoneOffsetForRefLogEntry;
            return "".concat(o, " ").concat(r, " ").concat(n, " ").concat(e.email, " ").concat(s, " ").concat(l, "	").concat(i, "\n");
        }
        static getStashReflogEntry(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            return e.split("\n").filter((o)=>o).reverse().map((o, s)=>r ? "stash@{".concat(s, "}: ").concat(o.split("	")[1]) : o);
        }
    };
    a(Yc, "GitRefStash");
    var hc = Yc, D$ = {
        stage: Ai,
        workdir: Yn
    }, yp;
    async function Xn(t, e) {
        return yp === void 0 && (yp = new hs), yp.acquire(t, e);
    }
    a(Xn, "acquireLock$1");
    async function C$(t, e, r, i) {
        let n = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
        let o = D.join(r, i), s = await t.lstat(o);
        if (!s) throw new ce(o);
        if (s.isDirectory()) throw new W("".concat(o, ": file expected, but found directory"));
        let l = n ? await IE({
            fs: t,
            gitdir: e,
            oid: n
        }) : void 0, f = l ? n : void 0;
        return l || await Xn({
            fs: t,
            gitdir: e,
            currentFilepath: o
        }, async ()=>{
            let c = s.isSymbolicLink() ? await t.readlink(o).then(ME) : await t.read(o);
            if (c === null) throw new ce(o);
            f = await rt({
                fs: t,
                gitdir: e,
                type: "blob",
                object: c
            });
        }), f;
    }
    a(C$, "checkAndWriteBlob");
    async function N$(param) {
        let { fs: t, dir: e, gitdir: r, entries: i } = param;
        async function n(o) {
            if (o.type === "tree") {
                if (!o.oid) {
                    let s = await Promise.all(o.children.map(n));
                    o.oid = await Ds({
                        fs: t,
                        gitdir: r,
                        tree: s
                    }), o.mode = 16384;
                }
            } else o.type === "blob" && (o.oid = await C$(t, r, e, o.path, o.oid), o.mode = 33188);
            return o.path = o.path.split("/").pop(), o;
        }
        return a(n, "processTreeEntry"), Promise.all(i.map(n));
    }
    a(N$, "processTreeEntries");
    async function xE(param) {
        let { fs: t, dir: e, gitdir: r, treePair: i } = param;
        let n = i[1] === "stage", o = i.map((p)=>typeof p == "string" ? D$[p]() : p), s = [], u = await Zr({
            fs: t,
            cache: {},
            dir: e,
            gitdir: r,
            trees: o,
            map: a(async (p, param)=>{
                let [m, y] = param;
                if (!(p === "." || await Xr.isIgnored({
                    fs: t,
                    dir: e,
                    gitdir: r,
                    filepath: p
                })) && y) return (!m || await m.oid() !== await y.oid() && await y.oid() !== void 0) && s.push([
                    m,
                    y
                ]), {
                    mode: await y.mode(),
                    path: p,
                    oid: await y.oid(),
                    type: await y.type()
                };
            }, "map"),
            reduce: a(async (p, m)=>(m = m.filter(Boolean), p ? (p.children = m, p) : m.length > 0 ? m : void 0), "reduce"),
            iterate: a(async (p, m)=>{
                let y = [];
                for (let w of m){
                    let [v, g] = w;
                    n ? g && (await t.exists("".concat(e, "/").concat(g.toString())) ? y.push(w) : s.push([
                        null,
                        g
                    ])) : v && (g ? y.push(w) : s.push([
                        v,
                        null
                    ]));
                }
                return y.length ? Promise.all(y.map(p)) : [];
            }, "iterate")
        });
        if (s.length === 0 || u.length === 0) return null;
        let d = (await N$({
            fs: t,
            dir: e,
            gitdir: r,
            entries: u
        })).filter(Boolean).map((p)=>({
                mode: p.mode,
                path: p.path,
                oid: p.oid,
                type: p.type
            }));
        return Ds({
            fs: t,
            gitdir: r,
            tree: d
        });
    }
    a(xE, "writeTreeChanges");
    async function B$(param) {
        let { fs: t, dir: e, gitdir: r, stashCommit: i, parentCommit: n, wasStaged: o } = param;
        let s = [], l = [], f = await Zr({
            fs: t,
            cache: {},
            dir: e,
            gitdir: r,
            trees: [
                ct({
                    ref: n
                }),
                ct({
                    ref: i
                })
            ],
            map: a(async (c, param)=>{
                let [u, h] = param;
                if (c === "." || await Xr.isIgnored({
                    fs: t,
                    dir: e,
                    gitdir: r,
                    filepath: c
                })) return;
                let d = h ? await h.type() : await u.type();
                if (d !== "tree" && d !== "blob") return;
                if (!h && u) {
                    let m = d === "tree" ? "rmdir" : "rm";
                    return d === "tree" && s.push(c), d === "blob" && o && l.push({
                        filepath: c,
                        oid: await u.oid()
                    }), {
                        method: m,
                        filepath: c
                    };
                }
                let p = await h.oid();
                if (!u || await u.oid() !== p) return d === "tree" ? {
                    method: "mkdir",
                    filepath: c
                } : (o && l.push({
                    filepath: c,
                    oid: p,
                    stats: await t.lstat(D.join(e, c))
                }), {
                    method: "write",
                    filepath: c,
                    oid: p
                });
            }, "map")
        });
        await Xn({
            fs: t,
            gitdir: r,
            dirRemoved: s,
            ops: f
        }, async ()=>{
            for (let c of f){
                let u = D.join(e, c.filepath);
                switch(c.method){
                    case "rmdir":
                        await t.rmdir(u);
                        break;
                    case "mkdir":
                        await t.mkdir(u);
                        break;
                    case "rm":
                        await t.rm(u);
                        break;
                    case "write":
                        if (!s.some((h)=>u.startsWith(h))) {
                            let { object: h } = await de({
                                fs: t,
                                cache: {},
                                gitdir: r,
                                oid: c.oid
                            });
                            await t.exists(u) && await t.rm(u), await t.write(u, h);
                        }
                        break;
                }
            }
        }), await Fe.acquire({
            fs: t,
            gitdir: r,
            cache: {}
        }, async (c)=>{
            l.forEach((param)=>{
                let { filepath: u, stats: h, oid: d } = param;
                c.insert({
                    filepath: u,
                    stats: h,
                    oid: d
                });
            });
        });
    }
    a(B$, "applyTreeChanges");
    var Nn = class Nn {
        static get refStash() {
            return "refs/stash";
        }
        static get refLogsStash() {
            return "logs/refs/stash";
        }
        get refStashPath() {
            return D.join(this.gitdir, Nn.refStash);
        }
        get refLogsStashPath() {
            return D.join(this.gitdir, Nn.refLogsStash);
        }
        async getAuthor() {
            if (!this._author && (this._author = await Yr({
                fs: this.fs,
                gitdir: this.gitdir,
                author: {}
            }), !this._author)) throw new He("author");
            return this._author;
        }
        async getStashSHA(e, r) {
            return await this.fs.exists(this.refStashPath) ? (r || await this.readStashReflogs({
                parsed: !1
            }))[e].split(" ")[1] : null;
        }
        async writeStashCommit(param) {
            let { message: e, tree: r, parent: i } = param;
            return i1({
                fs: this.fs,
                gitdir: this.gitdir,
                commit: {
                    message: e,
                    tree: r,
                    parent: i,
                    author: await this.getAuthor(),
                    committer: await this.getAuthor()
                }
            });
        }
        async readStashCommit(e) {
            let r = await this.readStashReflogs({
                parsed: !1
            });
            if (e !== 0 && (e < 0 || e > r.length - 1)) throw new Nt("stash@".concat(e), "number that is in range of [0, num of stash pushed]");
            let i = await this.getStashSHA(e, r);
            return i ? Gn({
                fs: this.fs,
                cache: {},
                gitdir: this.gitdir,
                oid: i
            }) : {};
        }
        async writeStashRef(e) {
            return B.writeRef({
                fs: this.fs,
                gitdir: this.gitdir,
                ref: Nn.refStash,
                value: e
            });
        }
        async writeStashReflogEntry(param) {
            let { stashCommit: e, message: r } = param;
            let i = await this.getAuthor(), n = hc.createStashReflogEntry(i, e, r), o = this.refLogsStashPath;
            await Xn({
                filepath: o,
                entry: n
            }, async ()=>{
                let s = await this.fs.exists(o) ? await this.fs.read(o, "utf8") : "";
                await this.fs.write(o, s + n, "utf8");
            });
        }
        async readStashReflogs(param) {
            let { parsed: e = !1 } = param;
            if (!await this.fs.exists(this.refLogsStashPath)) return [];
            let r = await this.fs.read(this.refLogsStashPath, "utf8");
            return hc.getStashReflogEntry(r, e);
        }
        constructor({ fs: e, dir: r, gitdir: i = D.join(r, ".git") }){
            Object.assign(this, {
                fs: e,
                dir: r,
                gitdir: i,
                _author: null
            });
        }
    };
    a(Nn, "GitStashManager");
    var Pi = Nn;
    async function n1(param) {
        let { fs: t, dir: e, gitdir: r, message: i = "" } = param;
        let n = new Pi({
            fs: t,
            dir: e,
            gitdir: r
        });
        await n.getAuthor();
        let o = await Jr({
            fs: t,
            gitdir: r,
            fullname: !1
        }), s = await B.resolve({
            fs: t,
            gitdir: r,
            ref: "HEAD"
        }), f = (await Np({
            fs: t,
            dir: e,
            gitdir: r,
            oid: s
        })).commit.message, c = [
            s
        ], u = null, h = ct({
            ref: "HEAD"
        }), d = await xE({
            fs: t,
            dir: e,
            gitdir: r,
            treePair: [
                ct({
                    ref: "HEAD"
                }),
                "stage"
            ]
        });
        if (d) {
            let w = await n.writeStashCommit({
                message: "stash-Index: WIP on ".concat(o, " - ").concat(new Date().toISOString()),
                tree: d,
                parent: c
            });
            c.push(w), u = d, h = Ai();
        }
        let p = await xE({
            fs: t,
            dir: e,
            gitdir: r,
            treePair: [
                h,
                "workdir"
            ]
        });
        if (p) {
            let w = await n.writeStashCommit({
                message: "stash-WorkDir: WIP on ".concat(o, " - ").concat(new Date().toISOString()),
                tree: p,
                parent: [
                    c[c.length - 1]
                ]
            });
            c.push(w), u = p;
        }
        if (!u || !d && !p) throw new ce("changes, nothing to stash");
        let m = (i.trim() || "WIP on ".concat(o)) + ": ".concat(s.substring(0, 7), " ").concat(f);
        return {
            stashCommit: await n.writeStashCommit({
                message: m,
                tree: u,
                parent: c
            }),
            stashMsg: m,
            branch: o,
            stashMgr: n
        };
    }
    a(n1, "_createStashCommit");
    async function L$(param) {
        let { fs: t, dir: e, gitdir: r, message: i = "" } = param;
        let { stashCommit: n, stashMsg: o, branch: s, stashMgr: l } = await n1({
            fs: t,
            dir: e,
            gitdir: r,
            message: i
        });
        return await l.writeStashRef(n), await l.writeStashReflogEntry({
            stashCommit: n,
            message: o
        }), await Ip({
            fs: t,
            dir: e,
            gitdir: r,
            ref: s,
            track: !1,
            force: !0
        }), n;
    }
    a(L$, "_stashPush");
    async function $$(param) {
        let { fs: t, dir: e, gitdir: r, message: i = "" } = param;
        let { stashCommit: n } = await n1({
            fs: t,
            dir: e,
            gitdir: r,
            message: i
        });
        return n;
    }
    a($$, "_stashCreate");
    async function o1(param) {
        let { fs: t, dir: e, gitdir: r, refIdx: i = 0 } = param;
        let o = await new Pi({
            fs: t,
            dir: e,
            gitdir: r
        }).readStashCommit(i), { parent: s = null } = o.commit ? o.commit : {};
        if (!(!s || !Array.isArray(s))) for(let l = 0; l < s.length - 1; l++){
            let c = (await Gn({
                fs: t,
                cache: {},
                gitdir: r,
                oid: s[l + 1]
            })).commit.message.startsWith("stash-Index");
            await B$({
                fs: t,
                dir: e,
                gitdir: r,
                stashCommit: s[l + 1],
                parentCommit: s[l],
                wasStaged: c
            });
        }
    }
    a(o1, "_stashApply");
    async function s1(param) {
        let { fs: t, dir: e, gitdir: r, refIdx: i = 0 } = param;
        let n = new Pi({
            fs: t,
            dir: e,
            gitdir: r
        });
        if (!(await n.readStashCommit(i)).commit) return;
        let s = n.refStashPath;
        await Xn(s, async ()=>{
            await t.exists(s) && await t.rm(s);
        });
        let l = await n.readStashReflogs({
            parsed: !1
        });
        if (!l.length) return;
        l.splice(i, 1);
        let f = n.refLogsStashPath;
        await Xn({
            reflogEntries: l,
            stashReflogPath: f,
            stashMgr: n
        }, async ()=>{
            if (l.length) {
                await t.write(f, l.reverse().join("\n") + "\n", "utf8");
                let c = l[l.length - 1].split(" ")[1];
                await n.writeStashRef(c);
            } else await t.rm(f);
        });
    }
    a(s1, "_stashDrop");
    async function M$(param) {
        let { fs: t, dir: e, gitdir: r } = param;
        return new Pi({
            fs: t,
            dir: e,
            gitdir: r
        }).readStashReflogs({
            parsed: !0
        });
    }
    a(M$, "_stashList");
    async function j$(param) {
        let { fs: t, dir: e, gitdir: r } = param;
        let i = new Pi({
            fs: t,
            dir: e,
            gitdir: r
        }), n = [
            i.refStashPath,
            i.refLogsStashPath
        ];
        await Xn(n, async ()=>{
            await Promise.all(n.map(async (o)=>{
                if (await t.exists(o)) return t.rm(o);
            }));
        });
    }
    a(j$, "_stashClear");
    async function U$(param) {
        let { fs: t, dir: e, gitdir: r, refIdx: i = 0 } = param;
        await o1({
            fs: t,
            dir: e,
            gitdir: r,
            refIdx: i
        }), await s1({
            fs: t,
            dir: e,
            gitdir: r,
            refIdx: i
        });
    }
    a(U$, "_stashPop");
    async function a1(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), op: i = "push", message: n = "", refIdx: o = 0 } = param;
        E("fs", t), E("dir", e), E("gitdir", r), E("op", i);
        let s = {
            push: L$,
            apply: o1,
            drop: s1,
            list: M$,
            clear: j$,
            pop: U$,
            create: $$
        }, l = [
            "apply",
            "drop",
            "pop"
        ];
        try {
            let f = new M(t);
            [
                "refs",
                "logs",
                "logs/refs"
            ].map((h)=>D.join(r, h)).forEach(async (h)=>{
                await f.exists(h) || await f.mkdir(h);
            });
            let u = s[i];
            if (u) {
                if (l.includes(i) && o < 0) throw new Nt("stash@".concat(o), "number that is in range of [0, num of stash pushed]");
                return await u({
                    fs: f,
                    dir: e,
                    gitdir: r,
                    message: n,
                    refIdx: o
                });
            }
            throw new Error("To be implemented: ".concat(i));
        } catch (f) {
            throw f.caller = "git.stash", f;
        }
    }
    a(a1, "stash");
    async function l1(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), filepath: i, cache: n = {} } = param;
        try {
            E("fs", t), E("gitdir", r), E("filepath", i);
            let o = new M(t);
            if (await Xr.isIgnored({
                fs: o,
                gitdir: r,
                dir: e,
                filepath: i
            })) return "ignored";
            let l = await q$({
                fs: o,
                cache: n,
                gitdir: r
            }), f = await c1({
                fs: o,
                cache: n,
                gitdir: r,
                tree: l,
                path: i
            }), c = await Fe.acquire({
                fs: o,
                gitdir: r,
                cache: n
            }, async function(y) {
                for (let w of y)if (w.path === i) return w;
                return null;
            }), u = await o.lstat(D.join(e, i)), h = f !== null, d = c !== null, p = u !== null, m = a(async ()=>{
                if (d && !ic(c, u)) return c.oid;
                {
                    let y = await o.read(D.join(e, i)), w = await QS({
                        gitdir: r,
                        type: "blob",
                        object: y
                    });
                    return d && c.oid === w && u.size !== -1 && Fe.acquire({
                        fs: o,
                        gitdir: r,
                        cache: n
                    }, async function(v) {
                        v.insert({
                            filepath: i,
                            stats: u,
                            oid: w
                        });
                    }), w;
                }
            }, "getWorkdirOid");
            if (!h && !p && !d) return "absent";
            if (!h && !p && d) return "*absent";
            if (!h && p && !d) return "*added";
            if (!h && p && d) return await m() === c.oid ? "added" : "*added";
            if (h && !p && !d) return "deleted";
            if (h && !p && d) return f === c.oid, "*deleted";
            if (h && p && !d) return await m() === f ? "*undeleted" : "*undeletemodified";
            if (h && p && d) {
                let y = await m();
                return y === f ? y === c.oid ? "unmodified" : "*unmodified" : y === c.oid ? "modified" : "*modified";
            }
        } catch (o) {
            throw o.caller = "git.status", o;
        }
    }
    a(l1, "status");
    async function c1(param) {
        let { fs: t, cache: e, gitdir: r, tree: i, path: n } = param;
        typeof n == "string" && (n = n.split("/"));
        let o = n.shift();
        for (let s of i)if (s.path === o) {
            if (n.length === 0) return s.oid;
            let { type: l, object: f } = await de({
                fs: t,
                cache: e,
                gitdir: r,
                oid: s.oid
            });
            if (l === "tree") {
                let c = et.from(f);
                return c1({
                    fs: t,
                    cache: e,
                    gitdir: r,
                    tree: c,
                    path: n
                });
            }
            if (l === "blob") throw new Ze(s.oid, l, "blob", n.join("/"));
        }
        return null;
    }
    a(c1, "getOidAtPath");
    async function q$(param) {
        let { fs: t, cache: e, gitdir: r } = param;
        let i;
        try {
            i = await B.resolve({
                fs: t,
                gitdir: r,
                ref: "HEAD"
            });
        } catch (o) {
            if (o instanceof ce) return [];
        }
        let { tree: n } = await Jn({
            fs: t,
            cache: e,
            gitdir: r,
            oid: i
        });
        return n;
    }
    a(q$, "getHeadTree");
    async function f1(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), ref: i = "HEAD", filepaths: n = [
            "."
        ], filter: o, cache: s = {}, ignored: l = !1 } = param;
        try {
            E("fs", t), E("gitdir", r), E("ref", i);
            let f = new M(t);
            return await Zr({
                fs: f,
                cache: s,
                dir: e,
                gitdir: r,
                trees: [
                    ct({
                        ref: i
                    }),
                    Yn(),
                    Ai()
                ],
                map: a(async function(c, param) {
                    let [u, h, d] = param;
                    if (!u && !d && h && !l && await Xr.isIgnored({
                        fs: f,
                        dir: e,
                        filepath: c
                    }) || !n.some((R)=>XE(c, R))) return null;
                    if (o && !o(c)) return;
                    let [p, m, y] = await Promise.all([
                        u && u.type(),
                        h && h.type(),
                        d && d.type()
                    ]), w = [
                        p,
                        m,
                        y
                    ].includes("blob");
                    if ((p === "tree" || p === "special") && !w) return;
                    if (p === "commit") return null;
                    if ((m === "tree" || m === "special") && !w) return;
                    if (y === "commit") return null;
                    if ((y === "tree" || y === "special") && !w) return;
                    let v = p === "blob" ? await u.oid() : void 0, g = y === "blob" ? await d.oid() : void 0, F;
                    p !== "blob" && m === "blob" && y !== "blob" ? F = "42" : m === "blob" && (F = await h.oid());
                    let O = [
                        void 0,
                        v,
                        F,
                        g
                    ], S = O.map((R)=>O.indexOf(R));
                    return S.shift(), [
                        c,
                        ...S
                    ];
                }, "map")
            });
        } catch (f) {
            throw f.caller = "git.statusMatrix", f;
        }
    }
    a(f1, "statusMatrix");
    async function u1(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), ref: i, object: n, force: o = !1 } = param;
        try {
            E("fs", t), E("gitdir", r), E("ref", i);
            let s = new M(t);
            if (i === void 0) throw new Qe("ref");
            i = i.startsWith("refs/tags/") ? i : "refs/tags/".concat(i);
            let l = await B.resolve({
                fs: s,
                gitdir: r,
                ref: n || "HEAD"
            });
            if (!o && await B.exists({
                fs: s,
                gitdir: r,
                ref: i
            })) throw new Ct("tag", i);
            await B.writeRef({
                fs: s,
                gitdir: r,
                ref: i,
                value: l
            });
        } catch (s) {
            throw s.caller = "git.tag", s;
        }
    }
    a(u1, "tag");
    async function h1(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), cache: i = {}, filepath: n, oid: o, mode: s, add: l, remove: f, force: c } = param;
        try {
            E("fs", t), E("gitdir", r), E("filepath", n);
            let u = new M(t);
            if (f) return await Fe.acquire({
                fs: u,
                gitdir: r,
                cache: i
            }, async function(d) {
                if (!c) {
                    let p = await u.lstat(D.join(e, n));
                    if (p) {
                        if (p.isDirectory()) throw new Kr("directory");
                        return;
                    }
                }
                d.has({
                    filepath: n
                }) && d.delete({
                    filepath: n
                });
            });
            let h;
            if (!o) {
                if (h = await u.lstat(D.join(e, n)), !h) throw new ce('file at "'.concat(n, '" on disk and "remove" not set'));
                if (h.isDirectory()) throw new Kr("directory");
            }
            return await Fe.acquire({
                fs: u,
                gitdir: r,
                cache: i
            }, async function(d) {
                if (!l && !d.has({
                    filepath: n
                })) throw new ce('file at "'.concat(n, '" in index and "add" not set'));
                let p;
                if (o) p = {
                    ctime: new Date(0),
                    mtime: new Date(0),
                    dev: 0,
                    ino: 0,
                    mode: s,
                    uid: 0,
                    gid: 0,
                    size: 0
                };
                else {
                    p = h;
                    let m = p.isSymbolicLink() ? await u.readlink(D.join(e, n)) : await u.read(D.join(e, n));
                    o = await rt({
                        fs: u,
                        gitdir: r,
                        type: "blob",
                        format: "content",
                        object: m
                    });
                }
                return d.insert({
                    filepath: n,
                    oid: o,
                    stats: p
                }), o;
            });
        } catch (u) {
            throw u.caller = "git.updateIndex", u;
        }
    }
    a(h1, "updateIndex$1");
    function d1() {
        try {
            return tf.version;
        } catch (t) {
            throw t.caller = "git.version", t;
        }
    }
    a(d1, "version");
    async function p1(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), trees: i, map: n, reduce: o, iterate: s, cache: l = {} } = param;
        try {
            return E("fs", t), E("gitdir", r), E("trees", i), await Zr({
                fs: new M(t),
                cache: l,
                dir: e,
                gitdir: r,
                trees: i,
                map: n,
                reduce: o,
                iterate: s
            });
        } catch (f) {
            throw f.caller = "git.walk", f;
        }
    }
    a(p1, "walk");
    async function m1(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), blob: i } = param;
        try {
            return E("fs", t), E("gitdir", r), E("blob", i), await rt({
                fs: new M(t),
                gitdir: r,
                type: "blob",
                object: i,
                format: "content"
            });
        } catch (n) {
            throw n.caller = "git.writeBlob", n;
        }
    }
    a(m1, "writeBlob");
    async function y1(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), commit: i } = param;
        try {
            return E("fs", t), E("gitdir", r), E("commit", i), await i1({
                fs: new M(t),
                gitdir: r,
                commit: i
            });
        } catch (n) {
            throw n.caller = "git.writeCommit", n;
        }
    }
    a(y1, "writeCommit");
    async function w1(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), type: i, object: n, format: o = "parsed", oid: s, encoding: l = void 0 } = param;
        try {
            let f = new M(t);
            if (o === "parsed") {
                switch(i){
                    case "commit":
                        n = tt.from(n).toObject();
                        break;
                    case "tree":
                        n = et.from(n).toObject();
                        break;
                    case "blob":
                        n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(n, l);
                        break;
                    case "tag":
                        n = ft.from(n).toObject();
                        break;
                    default:
                        throw new Ze(s || "", i, "blob|commit|tag|tree");
                }
                o = "content";
            }
            return s = await rt({
                fs: f,
                gitdir: r,
                type: i,
                object: n,
                oid: s,
                format: o
            }), s;
        } catch (f) {
            throw f.caller = "git.writeObject", f;
        }
    }
    a(w1, "writeObject");
    async function g1(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), ref: i, value: n, force: o = !1, symbolic: s = !1 } = param;
        try {
            E("fs", t), E("gitdir", r), E("ref", i), E("value", n);
            let l = new M(t);
            if (!ps(i, !0)) throw new Nt(i, ds.clean(i));
            if (!o && await B.exists({
                fs: l,
                gitdir: r,
                ref: i
            })) throw new Ct("ref", i);
            s ? await B.writeSymbolicRef({
                fs: l,
                gitdir: r,
                ref: i,
                value: n
            }) : (n = await B.resolve({
                fs: l,
                gitdir: r,
                ref: n
            }), await B.writeRef({
                fs: l,
                gitdir: r,
                ref: i,
                value: n
            }));
        } catch (l) {
            throw l.caller = "git.writeRef", l;
        }
    }
    a(g1, "writeRef");
    async function H$(param) {
        let { fs: t, gitdir: e, tag: r } = param;
        let i = ft.from(r).toObject();
        return await rt({
            fs: t,
            gitdir: e,
            type: "tag",
            object: i,
            format: "content"
        });
    }
    a(H$, "_writeTag");
    async function b1(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), tag: i } = param;
        try {
            return E("fs", t), E("gitdir", r), E("tag", i), await H$({
                fs: new M(t),
                gitdir: r,
                tag: i
            });
        } catch (n) {
            throw n.caller = "git.writeTag", n;
        }
    }
    a(b1, "writeTag");
    async function v1(param) {
        let { fs: t, dir: e, gitdir: r = D.join(e, ".git"), tree: i } = param;
        try {
            return E("fs", t), E("gitdir", r), E("tree", i), await Ds({
                fs: new M(t),
                gitdir: r,
                tree: i
            });
        } catch (n) {
            throw n.caller = "git.writeTree", n;
        }
    }
    a(v1, "writeTree");
    var z$ = {
        Errors: NE,
        STAGE: Ai,
        TREE: ct,
        WORKDIR: Yn,
        add: jE,
        abortMerge: LE,
        addNote: WE,
        addRemote: GE,
        annotatedTag: KE,
        branch: ZE,
        checkout: Ip,
        clone: tS,
        commit: rS,
        getConfig: wS,
        getConfigAll: gS,
        setConfig: r1,
        currentBranch: iS,
        deleteBranch: nS,
        deleteRef: oS,
        deleteRemote: sS,
        deleteTag: aS,
        expandOid: lS,
        expandRef: cS,
        fastForward: hS,
        fetch: dS,
        findMergeBase: pS,
        findRoot: yS,
        getRemoteInfo: bS,
        getRemoteInfo2: _S,
        hashBlob: FS,
        indexPack: ES,
        init: SS,
        isDescendent: TS,
        isIgnored: OS,
        listBranches: RS,
        listFiles: PS,
        listNotes: AS,
        listRefs: IS,
        listRemotes: DS,
        listServerRefs: CS,
        listTags: NS,
        log: LS,
        merge: $S,
        packObjects: jS,
        pull: US,
        push: qS,
        readBlob: WS,
        readCommit: Np,
        readNote: VS,
        readObject: GS,
        readTag: KS,
        readTree: ZS,
        remove: XS,
        removeNote: YS,
        renameBranch: JS,
        resetIndex: e1,
        updateIndex: h1,
        resolveRef: t1,
        status: l1,
        statusMatrix: f1,
        tag: u1,
        version: d1,
        walk: p1,
        writeBlob: m1,
        writeCommit: y1,
        writeObject: w1,
        writeRef: g1,
        writeTag: b1,
        writeTree: v1,
        stash: a1
    };
    L.Errors = NE;
    L.STAGE = Ai;
    L.TREE = ct;
    L.WORKDIR = Yn;
    L.abortMerge = LE;
    L.add = jE;
    L.addNote = WE;
    L.addRemote = GE;
    L.annotatedTag = KE;
    L.branch = ZE;
    L.checkout = Ip;
    L.clone = tS;
    L.commit = rS;
    L.currentBranch = iS;
    L.default = z$;
    L.deleteBranch = nS;
    L.deleteRef = oS;
    L.deleteRemote = sS;
    L.deleteTag = aS;
    L.expandOid = lS;
    L.expandRef = cS;
    L.fastForward = hS;
    L.fetch = dS;
    L.findMergeBase = pS;
    L.findRoot = yS;
    L.getConfig = wS;
    L.getConfigAll = gS;
    L.getRemoteInfo = bS;
    L.getRemoteInfo2 = _S;
    L.hashBlob = FS;
    L.indexPack = ES;
    L.init = SS;
    L.isDescendent = TS;
    L.isIgnored = OS;
    L.listBranches = RS;
    L.listFiles = PS;
    L.listNotes = AS;
    L.listRefs = IS;
    L.listRemotes = DS;
    L.listServerRefs = CS;
    L.listTags = NS;
    L.log = LS;
    L.merge = $S;
    L.packObjects = jS;
    L.pull = US;
    L.push = qS;
    L.readBlob = WS;
    L.readCommit = Np;
    L.readNote = VS;
    L.readObject = GS;
    L.readTag = KS;
    L.readTree = ZS;
    L.remove = XS;
    L.removeNote = YS;
    L.renameBranch = JS;
    L.resetIndex = e1;
    L.resolveRef = t1;
    L.setConfig = r1;
    L.stash = a1;
    L.status = l1;
    L.statusMatrix = f1;
    L.tag = u1;
    L.updateIndex = h1;
    L.version = d1;
    L.walk = p1;
    L.writeBlob = m1;
    L.writeCommit = y1;
    L.writeObject = w1;
    L.writeRef = g1;
    L.writeTag = b1;
    L.writeTree = v1;
});
var N1 = T(_c178 = (UH, C1)=>{
    C1.exports = function(t, e) {
        var r = [];
        t.on("data", function(i) {
            r.push(i);
        }), t.once("end", function() {
            e && e(null, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(r)), e = null;
        }), t.once("error", function(i) {
            e && e(i), e = null;
        });
    };
});
_c179 = N1;
var B1 = T(_c180 = ()=>{});
_c181 = B1;
var sm = T((St)=>{
    St.fetch = Bs(globalThis.fetch) && Bs(globalThis.ReadableStream);
    St.writableStream = Bs(globalThis.WritableStream);
    St.abortController = Bs(globalThis.AbortController);
    var Qr;
    function nm() {
        if (Qr !== void 0) return Qr;
        if (globalThis.XMLHttpRequest) {
            Qr = new globalThis.XMLHttpRequest;
            try {
                Qr.open("GET", globalThis.XDomainRequest ? "/" : "https://example.com");
            } catch (e) {
                Qr = null;
            }
        } else Qr = null;
        return Qr;
    }
    a(nm, "getXHR");
    function om(t) {
        var e = nm();
        if (!e) return !1;
        try {
            return e.responseType = t, e.responseType === t;
        } catch (e) {}
        return !1;
    }
    a(om, "checkTypeSupport");
    St.arraybuffer = St.fetch || om("arraybuffer");
    St.msstream = !St.fetch && om("ms-stream");
    St.mozchunkedarraybuffer = !St.fetch && om("moz-chunked-arraybuffer");
    St.overrideMimeType = St.fetch || (nm() ? Bs(nm().overrideMimeType) : !1);
    function Bs(t) {
        return typeof t == "function";
    }
    a(Bs, "isFunction");
    Qr = null;
});
var mf = T((xt, L1)=>{
    xt = L1.exports = Ga();
    xt.Stream = xt;
    xt.Readable = xt;
    xt.Writable = za();
    xt.Duplex = Dr();
    xt.Transform = rl();
    xt.PassThrough = gh();
    xt.finished = No();
    xt.pipeline = vh();
});
var cm = T((lm)=>{
    var $1 = sm(), Z$ = Gt(), M1 = mf(), yf = lm.readyStates = {
        UNSENT: 0,
        OPENED: 1,
        HEADERS_RECEIVED: 2,
        LOADING: 3,
        DONE: 4
    }, am = lm.IncomingMessage = function(t, e, r, i) {
        var n = this;
        if (M1.Readable.call(n), n._mode = r, n.headers = {}, n.rawHeaders = [], n.trailers = {}, n.rawTrailers = [], n.on("end", function() {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
                n.emit("close");
            });
        }), r === "fetch") {
            let h = function() {
                s.read().then(function(d) {
                    if (!n._destroyed) {
                        if (i(d.done), d.done) {
                            n.push(null);
                            return;
                        }
                        n.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(d.value)), h();
                    }
                }).catch(function(d) {
                    i(!0), n._destroyed || n.emit("error", d);
                });
            };
            var u = h;
            if (a(h, "read"), n._fetchResponse = e, n.url = e.url, n.statusCode = e.status, n.statusMessage = e.statusText, e.headers.forEach(function(d, p) {
                n.headers[p.toLowerCase()] = d, n.rawHeaders.push(p, d);
            }), $1.writableStream) {
                var o = new WritableStream({
                    write: a(function(d) {
                        return i(!1), new Promise(function(p, m) {
                            n._destroyed ? m() : n.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(d)) ? p() : n._resumeFetch = p;
                        });
                    }, "write"),
                    close: a(function() {
                        i(!0), n._destroyed || n.push(null);
                    }, "close"),
                    abort: a(function(d) {
                        i(!0), n._destroyed || n.emit("error", d);
                    }, "abort")
                });
                try {
                    e.body.pipeTo(o).catch(function(d) {
                        i(!0), n._destroyed || n.emit("error", d);
                    });
                    return;
                } catch (e) {}
            }
            var s = e.body.getReader();
            h();
        } else {
            n._xhr = t, n._pos = 0, n.url = t.responseURL, n.statusCode = t.status, n.statusMessage = t.statusText;
            var l = t.getAllResponseHeaders().split(/\r?\n/);
            if (l.forEach(function(h) {
                var d = h.match(/^([^:]+):\s*(.*)/);
                if (d) {
                    var p = d[1].toLowerCase();
                    p === "set-cookie" ? (n.headers[p] === void 0 && (n.headers[p] = []), n.headers[p].push(d[2])) : n.headers[p] !== void 0 ? n.headers[p] += ", " + d[2] : n.headers[p] = d[2], n.rawHeaders.push(d[1], d[2]);
                }
            }), n._charset = "x-user-defined", !$1.overrideMimeType) {
                var f = n.rawHeaders["mime-type"];
                if (f) {
                    var c = f.match(/;\s*charset=([^;])(;|$)/);
                    c && (n._charset = c[1].toLowerCase());
                }
                n._charset || (n._charset = "utf-8");
            }
        }
    };
    Z$(am, M1.Readable);
    am.prototype._read = function() {
        var t = this, e = t._resumeFetch;
        e && (t._resumeFetch = null, e());
    };
    am.prototype._onXHRProgress = function(t) {
        var e = this, r = e._xhr, i = null;
        switch(e._mode){
            case "text":
                if (i = r.responseText, i.length > e._pos) {
                    var n = i.substr(e._pos);
                    if (e._charset === "x-user-defined") {
                        for(var o = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(n.length), s = 0; s < n.length; s++)o[s] = n.charCodeAt(s) & 255;
                        e.push(o);
                    } else e.push(n, e._charset);
                    e._pos = i.length;
                }
                break;
            case "arraybuffer":
                if (r.readyState !== yf.DONE || !r.response) break;
                i = r.response, e.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(new Uint8Array(i)));
                break;
            case "moz-chunked-arraybuffer":
                if (i = r.response, r.readyState !== yf.LOADING || !i) break;
                e.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(new Uint8Array(i)));
                break;
            case "ms-stream":
                if (i = r.response, r.readyState !== yf.LOADING) break;
                var l = new globalThis.MSStreamReader;
                l.onprogress = function() {
                    l.result.byteLength > e._pos && (e.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(new Uint8Array(l.result.slice(e._pos)))), e._pos = l.result.byteLength);
                }, l.onload = function() {
                    t(!0), e.push(null);
                }, l.readAsArrayBuffer(i);
                break;
        }
        e._xhr.readyState === yf.DONE && e._mode !== "ms-stream" && (t(!0), e.push(null));
    };
});
var H1 = T(_c182 = (KH, q1)=>{
    var Ni = sm(), X$ = Gt(), U1 = cm(), fm = mf(), Y$ = U1.IncomingMessage, j1 = U1.readyStates;
    function J$(t, e) {
        return Ni.fetch && e ? "fetch" : Ni.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : Ni.msstream ? "ms-stream" : Ni.arraybuffer && t ? "arraybuffer" : "text";
    }
    a(J$, "decideMode");
    var We = q1.exports = function(t) {
        var e = this;
        fm.Writable.call(e), e._opts = t, e._body = [], e._headers = {}, t.auth && e.setHeader("Authorization", "Basic " + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(t.auth).toString("base64")), Object.keys(t.headers).forEach(function(n) {
            e.setHeader(n, t.headers[n]);
        });
        var r, i = !0;
        if (t.mode === "disable-fetch" || "requestTimeout" in t && !Ni.abortController) i = !1, r = !0;
        else if (t.mode === "prefer-streaming") r = !1;
        else if (t.mode === "allow-wrong-content-type") r = !Ni.overrideMimeType;
        else if (!t.mode || t.mode === "default" || t.mode === "prefer-fast") r = !0;
        else throw new Error("Invalid value for opts.mode");
        e._mode = J$(r, i), e._fetchTimer = null, e._socketTimeout = null, e._socketTimer = null, e.on("finish", function() {
            e._onFinish();
        });
    };
    X$(We, fm.Writable);
    We.prototype.setHeader = function(t, e) {
        var r = this, i = t.toLowerCase();
        eM.indexOf(i) === -1 && (r._headers[i] = {
            name: t,
            value: e
        });
    };
    We.prototype.getHeader = function(t) {
        var e = this._headers[t.toLowerCase()];
        return e ? e.value : null;
    };
    We.prototype.removeHeader = function(t) {
        var e = this;
        delete e._headers[t.toLowerCase()];
    };
    We.prototype._onFinish = function() {
        var t = this;
        if (!t._destroyed) {
            var e = t._opts;
            "timeout" in e && e.timeout !== 0 && t.setTimeout(e.timeout);
            var r = t._headers, i = null;
            e.method !== "GET" && e.method !== "HEAD" && (i = new Blob(t._body, {
                type: (r["content-type"] || {}).value || ""
            }));
            var n = [];
            if (Object.keys(r).forEach(function(f) {
                var c = r[f].name, u = r[f].value;
                Array.isArray(u) ? u.forEach(function(h) {
                    n.push([
                        c,
                        h
                    ]);
                }) : n.push([
                    c,
                    u
                ]);
            }), t._mode === "fetch") {
                var o = null;
                if (Ni.abortController) {
                    var s = new AbortController;
                    o = s.signal, t._fetchAbortController = s, "requestTimeout" in e && e.requestTimeout !== 0 && (t._fetchTimer = globalThis.setTimeout(function() {
                        t.emit("requestTimeout"), t._fetchAbortController && t._fetchAbortController.abort();
                    }, e.requestTimeout));
                }
                globalThis.fetch(t._opts.url, {
                    method: t._opts.method,
                    headers: n,
                    body: i || void 0,
                    mode: "cors",
                    credentials: e.withCredentials ? "include" : "same-origin",
                    signal: o
                }).then(function(f) {
                    t._fetchResponse = f, t._resetTimers(!1), t._connect();
                }, function(f) {
                    t._resetTimers(!0), t._destroyed || t.emit("error", f);
                });
            } else {
                var l = t._xhr = new globalThis.XMLHttpRequest;
                try {
                    l.open(t._opts.method, t._opts.url, !0);
                } catch (f) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
                        t.emit("error", f);
                    });
                    return;
                }
                "responseType" in l && (l.responseType = t._mode), "withCredentials" in l && (l.withCredentials = !!e.withCredentials), t._mode === "text" && "overrideMimeType" in l && l.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in e && (l.timeout = e.requestTimeout, l.ontimeout = function() {
                    t.emit("requestTimeout");
                }), n.forEach(function(f) {
                    l.setRequestHeader(f[0], f[1]);
                }), t._response = null, l.onreadystatechange = function() {
                    switch(l.readyState){
                        case j1.LOADING:
                        case j1.DONE:
                            t._onXHRProgress();
                            break;
                    }
                }, t._mode === "moz-chunked-arraybuffer" && (l.onprogress = function() {
                    t._onXHRProgress();
                }), l.onerror = function() {
                    t._destroyed || (t._resetTimers(!0), t.emit("error", new Error("XHR error")));
                };
                try {
                    l.send(i);
                } catch (f) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
                        t.emit("error", f);
                    });
                    return;
                }
            }
        }
    };
    function Q$(t) {
        try {
            var e = t.status;
            return e !== null && e !== 0;
        } catch (e) {
            return !1;
        }
    }
    a(Q$, "statusValid");
    We.prototype._onXHRProgress = function() {
        var t = this;
        t._resetTimers(!1), !(!Q$(t._xhr) || t._destroyed) && (t._response || t._connect(), t._response._onXHRProgress(t._resetTimers.bind(t)));
    };
    We.prototype._connect = function() {
        var t = this;
        t._destroyed || (t._response = new Y$(t._xhr, t._fetchResponse, t._mode, t._resetTimers.bind(t)), t._response.on("error", function(e) {
            t.emit("error", e);
        }), t.emit("response", t._response));
    };
    We.prototype._write = function(t, e, r) {
        var i = this;
        i._body.push(t), r();
    };
    We.prototype._resetTimers = function(t) {
        var e = this;
        globalThis.clearTimeout(e._socketTimer), e._socketTimer = null, t ? (globalThis.clearTimeout(e._fetchTimer), e._fetchTimer = null) : e._socketTimeout && (e._socketTimer = globalThis.setTimeout(function() {
            e.emit("timeout");
        }, e._socketTimeout));
    };
    We.prototype.abort = We.prototype.destroy = function(t) {
        var e = this;
        e._destroyed = !0, e._resetTimers(!0), e._response && (e._response._destroyed = !0), e._xhr ? e._xhr.abort() : e._fetchAbortController && e._fetchAbortController.abort(), t && e.emit("error", t);
    };
    We.prototype.end = function(t, e, r) {
        var i = this;
        typeof t == "function" && (r = t, t = void 0), fm.Writable.prototype.end.call(i, t, e, r);
    };
    We.prototype.setTimeout = function(t, e) {
        var r = this;
        e && r.once("timeout", e), r._socketTimeout = t, r._resetTimers(!1);
    };
    We.prototype.flushHeaders = function() {};
    We.prototype.setNoDelay = function() {};
    We.prototype.setSocketKeepAlive = function() {};
    var eM = [
        "accept-charset",
        "accept-encoding",
        "access-control-request-headers",
        "access-control-request-method",
        "connection",
        "content-length",
        "cookie",
        "cookie2",
        "date",
        "dnt",
        "expect",
        "host",
        "keep-alive",
        "origin",
        "referer",
        "te",
        "trailer",
        "transfer-encoding",
        "upgrade",
        "via"
    ];
});
_c183 = H1;
var W1 = T(_c184 = (XH, z1)=>{
    z1.exports = rM;
    var tM = Object.prototype.hasOwnProperty;
    function rM() {
        for(var t = {}, e = 0; e < arguments.length; e++){
            var r = arguments[e];
            for(var i in r)tM.call(r, i) && (t[i] = r[i]);
        }
        return t;
    }
    a(rM, "extend");
});
_c185 = W1;
var G1 = T(_c186 = (JH, V1)=>{
    V1.exports = {
        100: "Continue",
        101: "Switching Protocols",
        102: "Processing",
        200: "OK",
        201: "Created",
        202: "Accepted",
        203: "Non-Authoritative Information",
        204: "No Content",
        205: "Reset Content",
        206: "Partial Content",
        207: "Multi-Status",
        208: "Already Reported",
        226: "IM Used",
        300: "Multiple Choices",
        301: "Moved Permanently",
        302: "Found",
        303: "See Other",
        304: "Not Modified",
        305: "Use Proxy",
        307: "Temporary Redirect",
        308: "Permanent Redirect",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Timeout",
        409: "Conflict",
        410: "Gone",
        411: "Length Required",
        412: "Precondition Failed",
        413: "Payload Too Large",
        414: "URI Too Long",
        415: "Unsupported Media Type",
        416: "Range Not Satisfiable",
        417: "Expectation Failed",
        418: "I'm a teapot",
        421: "Misdirected Request",
        422: "Unprocessable Entity",
        423: "Locked",
        424: "Failed Dependency",
        425: "Unordered Collection",
        426: "Upgrade Required",
        428: "Precondition Required",
        429: "Too Many Requests",
        431: "Request Header Fields Too Large",
        451: "Unavailable For Legal Reasons",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Gateway Timeout",
        505: "HTTP Version Not Supported",
        506: "Variant Also Negotiates",
        507: "Insufficient Storage",
        508: "Loop Detected",
        509: "Bandwidth Limit Exceeded",
        510: "Not Extended",
        511: "Network Authentication Required"
    };
});
_c187 = G1;
var um = T((Z1)=>{
    var K1 = H1(), iM = cm(), nM = W1(), oM = G1(), sM = Oo(), Lt = Z1;
    Lt.request = function(t, e) {
        typeof t == "string" ? t = sM.parse(t) : t = nM(t);
        var r = globalThis.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", i = t.protocol || r, n = t.hostname || t.host, o = t.port, s = t.path || "/";
        n && n.indexOf(":") !== -1 && (n = "[" + n + "]"), t.url = (n ? i + "//" + n : "") + (o ? ":" + o : "") + s, t.method = (t.method || "GET").toUpperCase(), t.headers = t.headers || {};
        var l = new K1(t);
        return e && l.on("response", e), l;
    };
    Lt.get = a(function(e, r) {
        var i = Lt.request(e, r);
        return i.end(), i;
    }, "get");
    Lt.ClientRequest = K1;
    Lt.IncomingMessage = iM.IncomingMessage;
    Lt.Agent = function() {};
    Lt.Agent.defaultMaxSockets = 4;
    Lt.globalAgent = new Lt.Agent;
    Lt.STATUS_CODES = oM;
    Lt.METHODS = [
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "DELETE",
        "GET",
        "HEAD",
        "LOCK",
        "M-SEARCH",
        "MERGE",
        "MKACTIVITY",
        "MKCOL",
        "MOVE",
        "NOTIFY",
        "OPTIONS",
        "PATCH",
        "POST",
        "PROPFIND",
        "PROPPATCH",
        "PURGE",
        "PUT",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNLOCK",
        "UNSUBSCRIBE"
    ];
});
var J1 = T(_c188 = (t3, Y1)=>{
    var Ls = um(), aM = Oo(), hm = Y1.exports;
    for(wf in Ls)Ls.hasOwnProperty(wf) && (hm[wf] = Ls[wf]);
    var wf;
    hm.request = function(t, e) {
        return t = X1(t), Ls.request.call(this, t, e);
    };
    hm.get = function(t, e) {
        return t = X1(t), Ls.get.call(this, t, e);
    };
    function X1(t) {
        if (typeof t == "string" && (t = aM.parse(t)), t.protocol || (t.protocol = "https:"), t.protocol !== "https:") throw new Error('Protocol "' + t.protocol + '" not supported. Expected "https:"');
        return t;
    }
    a(X1, "validateParams");
});
_c189 = J1;
var tx = T((i3, ex)=>{
    ex.exports = Q1;
    function Q1(t, e) {
        if (t && e) return Q1(t)(e);
        if (typeof t != "function") throw new TypeError("need wrapper function");
        return Object.keys(t).forEach(function(i) {
            r[i] = t[i];
        }), r;
        //TURBOPACK unreachable
        ;
        function r() {
            for(var i = new Array(arguments.length), n = 0; n < i.length; n++)i[n] = arguments[n];
            var o = t.apply(this, i), s = i[i.length - 1];
            return typeof o == "function" && o !== s && Object.keys(s).forEach(function(l) {
                o[l] = s[l];
            }), o;
        }
    }
    a(Q1, "wrappy");
});
var nx = T((o3, dm)=>{
    var rx = tx();
    dm.exports = rx(gf);
    dm.exports.strict = rx(ix);
    gf.proto = gf(function() {
        Object.defineProperty(Function.prototype, "once", {
            value: a(function() {
                return gf(this);
            }, "value"),
            configurable: !0
        }), Object.defineProperty(Function.prototype, "onceStrict", {
            value: a(function() {
                return ix(this);
            }, "value"),
            configurable: !0
        });
    });
    function gf(t) {
        var e = a(function() {
            return e.called ? e.value : (e.called = !0, e.value = t.apply(this, arguments));
        }, "f");
        return e.called = !1, e;
    }
    a(gf, "once");
    function ix(t) {
        var e = a(function() {
            if (e.called) throw new Error(e.onceError);
            return e.called = !0, e.value = t.apply(this, arguments);
        }, "f"), r = t.name || "Function wrapped with `once`";
        return e.onceError = r + " shouldn't be called more than once", e.called = !1, e;
    }
    a(ix, "onceStrict");
});
var sx = T((a3, ox)=>{
    "use strict";
    function lM(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e);
    }
    a(lM, "hasOwnProperty");
    ox.exports = function(t, e, r, i) {
        e = e || "&", r = r || "=";
        var n = {};
        if (typeof t != "string" || t.length === 0) return n;
        var o = /\+/g;
        t = t.split(e);
        var s = 1e3;
        i && typeof i.maxKeys == "number" && (s = i.maxKeys);
        var l = t.length;
        s > 0 && l > s && (l = s);
        for(var f = 0; f < l; ++f){
            var c = t[f].replace(o, "%20"), u = c.indexOf(r), h, d, p, m;
            u >= 0 ? (h = c.substr(0, u), d = c.substr(u + 1)) : (h = c, d = ""), p = decodeURIComponent(h), m = decodeURIComponent(d), lM(n, p) ? cM(n[p]) ? n[p].push(m) : n[p] = [
                n[p],
                m
            ] : n[p] = m;
        }
        return n;
    };
    var cM = Array.isArray || function(t) {
        return Object.prototype.toString.call(t) === "[object Array]";
    };
});
var cx = T((c3, lx)=>{
    "use strict";
    var $s = a(function(t) {
        switch(typeof t){
            case "string":
                return t;
            case "boolean":
                return t ? "true" : "false";
            case "number":
                return isFinite(t) ? t : "";
            default:
                return "";
        }
    }, "stringifyPrimitive");
    lx.exports = function(t, e, r, i) {
        return e = e || "&", r = r || "=", t === null && (t = void 0), typeof t == "object" ? ax(uM(t), function(n) {
            var o = encodeURIComponent($s(n)) + r;
            return fM(t[n]) ? ax(t[n], function(s) {
                return o + encodeURIComponent($s(s));
            }).join(e) : o + encodeURIComponent($s(t[n]));
        }).join(e) : i ? encodeURIComponent($s(i)) + r + encodeURIComponent($s(t)) : "";
    };
    var fM = Array.isArray || function(t) {
        return Object.prototype.toString.call(t) === "[object Array]";
    };
    function ax(t, e) {
        if (t.map) return t.map(e);
        for(var r = [], i = 0; i < t.length; i++)r.push(e(t[i], i));
        return r;
    }
    a(ax, "map");
    var uM = Object.keys || function(t) {
        var e = [];
        for(var r in t)Object.prototype.hasOwnProperty.call(t, r) && e.push(r);
        return e;
    };
});
var fx = T((Ms)=>{
    "use strict";
    Ms.decode = Ms.parse = sx();
    Ms.encode = Ms.stringify = cx();
});
var px = T((h3, dx)=>{
    dx.exports = no;
    var hM = N1(), ux = B1(), dM = um(), pM = J1(), mM = nx(), yM = fx(), hx = Oo(), pm = a((t)=>t !== null && typeof t == "object" && typeof t.pipe == "function", "isStream");
    function no(t, e) {
        if (t = Object.assign({
            maxRedirects: 10
        }, typeof t == "string" ? {
            url: t
        } : t), e = mM(e), t.url) {
            let { hostname: l, port: f, protocol: c, auth: u, path: h } = hx.parse(t.url);
            delete t.url, !l && !f && !c && !u ? t.path = h : Object.assign(t, {
                hostname: l,
                port: f,
                protocol: c,
                auth: u,
                path: h
            });
        }
        let r = {
            "accept-encoding": "gzip, deflate"
        };
        t.headers && Object.keys(t.headers).forEach((l)=>r[l.toLowerCase()] = t.headers[l]), t.headers = r;
        let i;
        t.body ? i = t.json && !pm(t.body) ? JSON.stringify(t.body) : t.body : t.form && (i = typeof t.form == "string" ? t.form : yM.stringify(t.form), t.headers["content-type"] = "application/x-www-form-urlencoded"), i && (t.method || (t.method = "POST"), pm(i) || (t.headers["content-length"] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].byteLength(i)), t.json && !t.form && (t.headers["content-type"] = "application/json")), delete t.body, delete t.form, t.json && (t.headers.accept = "application/json"), t.method && (t.method = t.method.toUpperCase());
        let n = t.hostname, s = (t.protocol === "https:" ? pM : dM).request(t, (l)=>{
            if (t.followRedirects !== !1 && l.statusCode >= 300 && l.statusCode < 400 && l.headers.location) {
                t.url = l.headers.location, delete t.headers.host, l.resume();
                let c = hx.parse(t.url).hostname;
                return c !== null && c !== n && (delete t.headers.cookie, delete t.headers.authorization), t.method === "POST" && [
                    301,
                    302
                ].includes(l.statusCode) && (t.method = "GET", delete t.headers["content-length"], delete t.headers["content-type"]), t.maxRedirects-- === 0 ? e(new Error("too many redirects")) : no(t, e);
            }
            let f = typeof ux == "function" && t.method !== "HEAD";
            e(null, f ? ux(l) : l);
        });
        return s.on("timeout", ()=>{
            s.abort(), e(new Error("Request timed out"));
        }), s.on("error", e), pm(i) ? i.on("error", e).pipe(s) : s.end(i), s;
    }
    a(no, "simpleGet");
    no.concat = (t, e)=>no(t, (r, i)=>{
            if (r) return e(r);
            hM(i, (n, o)=>{
                if (n) return e(n);
                if (t.json) try {
                    o = JSON.parse(o.toString());
                } catch (s) {
                    return e(s, i, o);
                }
                e(null, i, o);
            });
        });
    [
        "get",
        "post",
        "put",
        "patch",
        "head",
        "delete"
    ].forEach((t)=>{
        no[t] = (e, r)=>(typeof e == "string" && (e = {
                url: e
            }), no(Object.assign({
                method: t.toUpperCase()
            }, e), r));
    });
});
var Vh = ae(Er(), 1);
var Ff = class Ff {
    async initialize() {
        if (this.initialized) return;
        let e = new Set;
        for (let r of [
            ...this.compositFs.subFilesystems
        ].reverse()){
            let i = await r.readdir(this.dirPath);
            for (let n of i)e.add(n);
        }
        for (let r of Array.from(e)){
            var _this_compositFs_hiddenFilesFileSystem;
            let i = this.dirPath + "/" + r;
            await ((_this_compositFs_hiddenFilesFileSystem = this.compositFs.hiddenFilesFileSystem) === null || _this_compositFs_hiddenFilesFileSystem === void 0 ? void 0 : _this_compositFs_hiddenFilesFileSystem.responsible(i)) || this.entries.push({
                name: r,
                path: i
            });
        }
        this.initialized = !0;
    }
    async *[Symbol.asyncIterator]() {
        for(await this.initialize(); this.currentIndex < this.entries.length && !this.closed;){
            let e = this.entries[this.currentIndex++];
            try {
                let r = await this.compositFs.stat(e.path);
                yield {
                    name: e.name,
                    isFile: a(()=>r.isFile(), "isFile"),
                    isDirectory: a(()=>r.isDirectory(), "isDirectory"),
                    isBlockDevice: a(()=>r.isBlockDevice(), "isBlockDevice"),
                    isCharacterDevice: a(()=>r.isCharacterDevice(), "isCharacterDevice"),
                    isSymbolicLink: a(()=>r.isSymbolicLink(), "isSymbolicLink"),
                    isFIFO: a(()=>r.isFIFO(), "isFIFO"),
                    isSocket: a(()=>r.isSocket(), "isSocket")
                };
            } catch (r) {
                console.debug("Failed to stat ".concat(e.path, ":"), r);
            }
        }
    }
    async read() {
        if (this.closed) throw new Error("Directory handle is closed");
        if (await this.initialize(), this.currentIndex >= this.entries.length) return null;
        let e = this.entries[this.currentIndex++];
        try {
            let r = await this.compositFs.stat(e.path);
            return {
                name: e.name,
                isFile: a(()=>r.isFile(), "isFile"),
                isDirectory: a(()=>r.isDirectory(), "isDirectory"),
                isBlockDevice: a(()=>r.isBlockDevice(), "isBlockDevice"),
                isCharacterDevice: a(()=>r.isCharacterDevice(), "isCharacterDevice"),
                isSymbolicLink: a(()=>r.isSymbolicLink(), "isSymbolicLink"),
                isFIFO: a(()=>r.isFIFO(), "isFIFO"),
                isSocket: a(()=>r.isSocket(), "isSocket")
            };
        } catch (e) {
            return this.read();
        }
    }
    async close() {
        this.closed = !0, this.entries = [];
    }
    get path() {
        return this.dirPath;
    }
    constructor(e, r){
        q(this, "entries", []);
        q(this, "currentIndex", 0);
        q(this, "closed", !1);
        q(this, "compositFs");
        q(this, "dirPath");
        q(this, "initialized", !1);
        this.compositFs = e, this.dirPath = r;
    }
};
a(Ff, "CompositeFsDir");
var $i = Ff;
var Ef = class Ef {
    get fsType() {
        return this.delegate.fileType();
    }
    get subFsFileDescriptor() {
        return this._subFsFileDescriptor;
    }
    get fd() {
        return this._compositFsFileDescriptor;
    }
    realize(e) {
        if (this._compositFsFileDescriptor !== -1) throw new Error("was already realized");
        this._compositFsFileDescriptor = e;
    }
    readableWebStream(e) {
        throw new Error("Method not implemented.");
    }
    async appendFile(e, r) {
        return await this.delegate.appendFile(this, e, r);
    }
    async chmod(e) {
        return this.delegate.fchmod(this, e);
    }
    async chown(e, r) {
        return this.delegate.fchown(this, e, r);
    }
    async close() {
        return this.delegate.close(this);
    }
    async datasync() {
        return this.delegate.dataSync(this);
    }
    async read(e, r, i, n) {
        return await this.delegate.read(this, e, r, i, n);
    }
    readv(e, r) {
        return this.delegate.readv(this, e, r);
    }
    async stat(e) {
        return this.delegate.fstat(this, e);
    }
    async truncate(e) {
        return this.delegate.ftruncate(this, e);
    }
    async utimes(e, r) {
        return this.delegate.futimes(this, e, r);
    }
    async write(e, r, i, n) {
        return this.delegate.write(this, e, r, i, n);
    }
    async writev(e, r) {
        return this.delegate.writev(this, e, r);
    }
    async sync() {
        return this.delegate.dataSync(this);
    }
    constructor(e){
        q(this, "delegate");
        q(this, "_subFsFileDescriptor");
        q(this, "handleType", "file");
        q(this, "_compositFsFileDescriptor", -1);
        this.delegate = e.fs, this._subFsFileDescriptor = e.subFsFileDescriptor, this._compositFsFileDescriptor = -1;
        let r = e.fs.fileType(), i = this._subFsFileDescriptor;
    }
};
a(Ef, "CompositFsFileHandle");
var Rt = Ef;
var Lb = ae(Er(), 1), Fl = ae(qo(), 1);
var Hh = class Hh {
    toStr(e) {
        return typeof e == "string" ? e : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(e) ? e.toString() : e && typeof e == "object" && "fd" in e ? "FileHandle(fd=".concat(e.fd, ")") : String(e);
    }
    async open(e, r, i) {
        throw new Error("open not implemented for: ".concat(this.toStr(e)));
    }
    async access(e, r) {
        throw new Error("access not implemented for: ".concat(this.toStr(e)));
    }
    async stat(e, r) {
        throw new Error("lstat not implemented for: ".concat(this.toStr(e)));
    }
    async lstat(e, r) {
        throw new Error("lstat not implemented for: ".concat(this.toStr(e)));
    }
    async opendir(e, r) {
        throw new Error("opendir not implemented for: ".concat(this.toStr(e)));
    }
    async link(e, r) {
        throw new Error("link not implemented for: ".concat(this.toStr(e)));
    }
    async mkdir(e, r) {
        throw new Error("mkdir not implemented for: ".concat(this.toStr(e)));
    }
    async readdir(e, r) {
        throw new Error("readdir not implemented for: ".concat(this.toStr(e)));
    }
    async readlink(e) {
        for(var _len = arguments.length, r = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            r[_key - 1] = arguments[_key];
        }
        throw new Error("readlink not implemented for: ".concat(this.toStr(e)));
    }
    async unlink(e) {
        throw new Error("unlink not implemented for: ".concat(this.toStr(e)));
    }
    async rename(e, r) {
        throw new Error("rename not implemented for: ".concat(this.toStr(e)));
    }
    async rmdir(e) {
        for(var _len = arguments.length, r = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            r[_key - 1] = arguments[_key];
        }
        throw new Error("rmdir not implemented for: ".concat(this.toStr(e)));
    }
    async symlink(e, r, i) {
        throw new Error("symlink not implemented for: ".concat(this.toStr(r)));
    }
    async lookup(e) {
        throw new Error("lookup not implemented for: ".concat(this.toStr(e)));
    }
    resolvePath(e) {
        throw new Error("resolvePath not implemented for fd: ".concat(e));
    }
    async close(e) {
        this.compositFs.close(e);
    }
    async dataSync(e) {
        throw new Error("dataSync not implemented for: ".concat(e.subFsFileDescriptor));
    }
    async read(e, r, i, n, o) {
        throw new Error("read not implemented for: ".concat(e.subFsFileDescriptor));
    }
    async appendFile(e, r, i) {
        throw new Error("appendFile not implemented for: ".concat(e.subFsFileDescriptor));
    }
    async fchmod(e, r) {
        throw new Error("fchmod not implemented for: ".concat(e.subFsFileDescriptor));
    }
    async fchown(e, r, i) {
        throw new Error("fchown not implemented for: ".concat(e.subFsFileDescriptor));
    }
    async ftruncate(e, r) {
        throw new Error("ftruncate not implemented for: ".concat(e.subFsFileDescriptor));
    }
    async fstat(e, r) {
        throw new Error("fstat not implemented for: ".concat(e.subFsFileDescriptor));
    }
    async futimes(e, r, i) {
        throw new Error("futimes not implemented for: ".concat(e.subFsFileDescriptor));
    }
    async write(e, r, i, n, o) {
        throw new Error("write not implemented for: ".concat(e.subFsFileDescriptor));
    }
    async writev(e, r, i) {
        throw new Error("writev not implemented for: ".concat(e.subFsFileDescriptor));
    }
    async readv(e, r, i) {
        throw new Error("readv not implemented for: ".concat(e.subFsFileDescriptor));
    }
    async readFile(e, r) {
        throw new Error("readFile not implemented for: ".concat(this.toStr(e)));
    }
    async writeFile(e, r, i) {
        throw new Error("writeFile not implemented for: ".concat(this.toStr(e)));
    }
    constructor({ parentFs: e, gitRoot: r }){
        q(this, "compositFs");
        q(this, "gitRoot");
        this.compositFs = e, this.gitRoot = r;
    }
};
a(Hh, "BaseCompositeSubFs");
var bt = Hh;
var zh = class zh extends bt {
    async responsible(r) {
        return !0;
    }
    fileType() {
        return 4;
    }
    async open(r, i, n) {
        let o = Lb.dirname(r), s = await this.targetFs.promises.open(r, i, n);
        return this.openFh.set(s.fd, s), new Rt({
            fs: this,
            subFsFileDescriptor: s.fd,
            parentFsFileDescriptors: [
                s.fd
            ]
        });
    }
    async access(r, i) {
        return await this.targetFs.promises.access(r, i);
    }
    async stat(r, i) {
        return this.targetFs.promises.stat(r, {
            bigint: !1
        });
    }
    async lstat(r, i) {
        return this.targetFs.promises.lstat(r, {
            bigint: !1
        });
    }
    async opendir(r, i) {
        return await this.targetFs.promises.opendir(r, i);
    }
    async link(r, i) {
        return await this.targetFs.promises.link(r, i);
    }
    async mkdir(r, i) {
        let n = typeof r == "string" ? r : r.toString();
        return await this.targetFs.promises.mkdir(n, i);
    }
    async readdir(r) {
        for(var _len = arguments.length, i = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            i[_key - 1] = arguments[_key];
        }
        return this.targetFs.promises.readdir(r, ...i);
    }
    async readlink(r) {
        for(var _len = arguments.length, i = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            i[_key - 1] = arguments[_key];
        }
        throw new Error("not implemented");
    }
    async unlink(r) {
        return await this.targetFs.promises.unlink(r);
    }
    async rename(r, i) {
        return await this.targetFs.promises.rename(r, i);
    }
    async rmdir(r, i) {
        return await this.targetFs.promises.rmdir(r, i);
    }
    async symlink(r, i, n) {
        return await this.targetFs.promises.symlink(r, i, n);
    }
    async lookup(r) {
        throw new Error("lookup is not implemented for: ".concat(this.toStr(r)));
    }
    async close(r) {
        let i = this.openFh.get(r.subFsFileDescriptor);
        i && (await i.close(), this.openFh.delete(r.subFsFileDescriptor)), this.compositFs.close(r);
    }
    async dataSync(r) {
        let i = this.openFh.get(r.subFsFileDescriptor);
        if (i) return await i.sync();
    }
    async read(r, i, n, o, s) {
        let l = this.openFh.get(r.subFsFileDescriptor);
        if (l) return await l.read(i, n, o, s);
        throw new Error("File handle not found: ".concat(r.subFsFileDescriptor));
    }
    async fchmod(r, i) {
        let n = this.openFh.get(r.subFsFileDescriptor);
        if (n) return await n.chmod(i);
    }
    async fchown(r, i, n) {
        let o = this.openFh.get(r.subFsFileDescriptor);
        if (o) return await o.chown(i, n);
    }
    async write(r, i, n, o, s) {
        let l = this.openFh.get(r.subFsFileDescriptor);
        if (l) return await l.write(i, n, o, s);
        throw new Error("File handle not found: ".concat(r.subFsFileDescriptor));
    }
    async ftruncate(r, i) {
        let n = this.openFh.get(r.subFsFileDescriptor);
        if (n) return await n.truncate(i);
    }
    resolvePath(r) {
        throw new Error("resolvePath is not implemented: resolvePath(".concat(r, ")"));
    }
    async fstat(r, i) {
        let n = this.openFh.get(r.subFsFileDescriptor);
        if (n) return await n.stat(i);
        throw new Error("File handle not found: ".concat(r.subFsFileDescriptor));
    }
    async futimes(r, i, n) {
        let o = this.openFh.get(r.subFsFileDescriptor);
        if (o) return await o.utimes(i, n);
    }
    async writev(r, i, n) {
        let o = this.openFh.get(r.subFsFileDescriptor);
        if (o) return await o.writev(i, n !== null && n !== void 0 ? n : void 0);
        throw new Error("File handle not found: ".concat(r.subFsFileDescriptor));
    }
    async readv(r, i, n) {
        let o = this.openFh.get(r.subFsFileDescriptor);
        if (o) return await o.readv(i, n !== null && n !== void 0 ? n : void 0);
        throw new Error("File handle not found: ".concat(r.subFsFileDescriptor));
    }
    async readFile(r, i) {
        return typeof r == "string" || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(r) ? this.targetFs.readFile(r.toString(), i) : super.readFile(r, i);
    }
    async writeFile(r, i, n) {
        let o = typeof n == "object" && n.flag ? n.flag : "w", s = await this.targetFs.open(r, o);
        try {
            let l;
            if (typeof i == "string") {
                let f = typeof n == "object" && n.encoding ? n.encoding : "utf8";
                l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(i, f);
            } else __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(i) ? l = i : l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(i);
            await s.write(l, 0, l.length, 0);
        } finally{
            await this.targetFs.close(s);
        }
    }
    constructor({ parentFs: r, gitRoot: i }){
        super({
            parentFs: r,
            gitRoot: i
        });
        q(this, "openFh", new Map);
        q(this, "memFs", (0, Fl.createFsFromVolume)(new Fl.Volume));
        q(this, "targetFs");
        if (this.compositFs = r, this.gitRoot = i, this.compositFs.parentFs === void 0) throw new Error("PassThroughSubFs not allowed in root fs");
        this.targetFs = this.compositFs.parentFs;
    }
};
a(zh, "PassThroughSubFs");
var _l = zh;
var $b = ae(Er(), 1), Sl = ae(qo(), 1);
var Wh = class Wh extends bt {
    async responsible(r) {
        return !0;
    }
    fileType() {
        return 4;
    }
    async open(r, i, n) {
        let o = $b.dirname(r), s = await this.targetFs.promises.open(r, i, n);
        return this.openFh.set(s.fd, s), new Rt({
            fs: this,
            subFsFileDescriptor: s.fd,
            parentFsFileDescriptors: []
        });
    }
    async access(r, i) {
        return await this.targetFs.promises.access(r, i);
    }
    async stat(r) {
        for(var _len = arguments.length, i = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            i[_key - 1] = arguments[_key];
        }
        return this.targetFs.promises.stat(r, {
            bigint: !1
        });
    }
    async lstat(r) {
        for(var _len = arguments.length, i = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            i[_key - 1] = arguments[_key];
        }
        return this.targetFs.promises.lstat(r, {
            bigint: !1
        });
    }
    async opendir(r, i) {
        let n = await this.targetFs.promises.opendir(r, i);
        return new $i(this.compositFs, r.toString());
    }
    async link(r, i) {
        return await this.targetFs.promises.link(r, i);
    }
    async mkdir(r, i) {
        await this.targetFs.promises.mkdir(r, i);
    }
    async readdir(r) {
        for(var _len = arguments.length, i = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            i[_key - 1] = arguments[_key];
        }
        return this.targetFs.promises.readdir(r, ...i);
    }
    async readlink(r) {
        for(var _len = arguments.length, i = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            i[_key - 1] = arguments[_key];
        }
        throw new Error("not implemented");
    }
    async unlink(r) {
        return await this.targetFs.promises.unlink(r);
    }
    async rename(r, i) {
        return await this.targetFs.promises.rename(r, i);
    }
    async rmdir(r, i) {
        return await this.targetFs.promises.rmdir(r, i);
    }
    async symlink(r, i, n) {
        return await this.targetFs.promises.symlink(r, i, n);
    }
    async lookup(r) {
        throw new Error("lookup is not implemented for: ".concat(this.toStr(r)));
    }
    async close(r) {
        let i = this.openFh.get(r.subFsFileDescriptor);
        i && (await i.close(), this.openFh.delete(r.subFsFileDescriptor)), this.compositFs.close(r);
    }
    async dataSync(r) {
        let i = this.openFh.get(r.subFsFileDescriptor);
        if (i) return await i.sync();
    }
    async read(r, i, n, o, s) {
        let l = this.openFh.get(r.subFsFileDescriptor);
        if (l) return await l.read(i, n, o, s);
        throw new Error("File handle not found: ".concat(r.subFsFileDescriptor));
    }
    async fchmod(r, i) {
        let n = this.openFh.get(r.subFsFileDescriptor);
        if (n) return await n.chmod(i);
    }
    async fchown(r, i, n) {
        let o = this.openFh.get(r.subFsFileDescriptor);
        if (o) return await o.chown(i, n);
    }
    async write(r, i, n, o, s) {
        let l = this.openFh.get(r.subFsFileDescriptor);
        if (l) return await l.write(i, n, o, s);
        throw new Error("File handle not found: ".concat(r.subFsFileDescriptor));
    }
    async ftruncate(r, i) {
        let n = this.openFh.get(r.subFsFileDescriptor);
        if (n) return await n.truncate(i);
    }
    resolvePath(r) {
        throw new Error("resolvePath is not implemented: resolvePath(".concat(r, ")"));
    }
    async fstat(r, i) {
        let n = this.openFh.get(r.subFsFileDescriptor);
        if (n) return await n.stat(i);
        throw new Error("File handle not found: ".concat(r.subFsFileDescriptor));
    }
    async futimes(r, i, n) {
        let o = this.openFh.get(r.subFsFileDescriptor);
        if (o) return await o.utimes(i, n);
    }
    async writev(r, i, n) {
        let o = this.openFh.get(r.subFsFileDescriptor);
        if (o) return await o.writev(i, n !== null && n !== void 0 ? n : void 0);
        throw new Error("File handle not found: ".concat(r.subFsFileDescriptor));
    }
    async readv(r, i, n) {
        let o = this.openFh.get(r.subFsFileDescriptor);
        if (o) return await o.readv(i, n !== null && n !== void 0 ? n : void 0);
        throw new Error("File handle not found: ".concat(r.subFsFileDescriptor));
    }
    async readFile(r, i) {
        return this.targetFs.promises.readFile(r, i);
    }
    async writeFile(r, i, n) {
        return this.targetFs.promises.writeFile(r, i, n);
    }
    constructor({ parentFs: r, gitRoot: i, passThroughFs: n }){
        super({
            parentFs: r,
            gitRoot: i
        });
        q(this, "openFh", new Map);
        q(this, "memFs", (0, Sl.createFsFromVolume)(new Sl.Volume));
        q(this, "targetFs");
        this.compositFs = r, this.gitRoot = i, this.targetFs = n;
    }
};
a(Wh, "PassThroughToAsyncFsSubFs");
var El = Wh;
var Gh = class Gh {
    getNextFileDescriptor() {
        let e = Array.from(this.openFileHandles.keys());
        return e.length === 0 ? 1 : Math.max(...e) + 1;
    }
    getFilehandle(e) {
        return this.openFileHandles.get(e);
    }
    setEphemeralFilesSubFs(e) {
        this.ephemeralFilesFileSystem = e;
    }
    setHiddenFilesSubFs(e) {
        this.hiddenFilesFileSystem = e;
    }
    addSubFs(e) {
        this.subFilesystems.push(e);
    }
    async getResponsibleFs(e) {
        if (!e.toString().startsWith(this.gitRoot) && this.gitRoot !== "./") throw new Error("tried to access a file (" + e + ") outside of the legit folder: " + this.gitRoot);
        if (!this.hiddenFilesFileSystem) throw new Error(this.name + " intialize hidden fs first!");
        if (!this.ephemeralFilesFileSystem) throw new Error(this.name + " intialize ephemeral fs first!");
        if (await this.hiddenFilesFileSystem.responsible(e.toString())) return this.hiddenFilesFileSystem;
        if (await this.ephemeralFilesFileSystem.responsible(e.toString())) return this.ephemeralFilesFileSystem;
        for (let r of this.subFilesystems)if (await r.responsible(e.toString())) return r;
        return this.passThroughFileSystem;
    }
    async access(e, r) {
        return (await this.getResponsibleFs(e)).access(e, r);
    }
    async opendir(e, r) {
        let i = e.toString();
        if (!i.startsWith(this.gitRoot)) throw new Error("tried to access a directory (" + i + ") outside of the legit folder: " + this.gitRoot);
        return new $i(this, i);
    }
    async mkdir(e, r) {
        return (await this.getResponsibleFs(e)).mkdir(e, r);
    }
    async readdir(e, r) {
        var _this_ephemeralFilesFileSystem;
        let i = await this.getResponsibleFs(e);
        if (i !== this.passThroughFileSystem) return i.readdir(e, r);
        let n = new Set;
        for (let s of [
            ...this.subFilesystems
        ].reverse()){
            var _this_ephemeralFilesFileSystem1;
            let l = await s.readdir(e, r);
            for (let f of l)await ((_this_ephemeralFilesFileSystem1 = this.ephemeralFilesFileSystem) === null || _this_ephemeralFilesFileSystem1 === void 0 ? void 0 : _this_ephemeralFilesFileSystem1.responsible((e == "/" ? "" : e) + "/" + f)) || n.add(f);
        }
        let o = await this.passThroughFileSystem.readdir(e, r);
        for (let s of o)await ((_this_ephemeralFilesFileSystem = this.ephemeralFilesFileSystem) === null || _this_ephemeralFilesFileSystem === void 0 ? void 0 : _this_ephemeralFilesFileSystem.responsible((e == "/" ? "" : e) + "/" + s)) || n.add(s);
        try {
            let s = await this.ephemeralFilesFileSystem.readdir(e, r);
            for (let l of s)n.add(l);
        } catch (s) {
            console.log(s.code);
        }
        for (let s of n){
            let l = (e == "/" ? "" : e) + "/" + s;
            await this.hiddenFilesFileSystem.responsible(l) && n.delete(s);
        }
        return Array.from(n);
    }
    async open(e, r, i) {
        let o = await (await this.getResponsibleFs(e)).open(e, r, i), s = this.getNextFileDescriptor();
        return o.realize(s), this.openFileHandles.set(s, o), this.pathToFileDescriptors.get(e) || this.pathToFileDescriptors.set(e, []), this.pathToFileDescriptors.get(e).push(s), o;
    }
    async close(e) {
        for (let [r, i] of this.pathToFileDescriptors.entries()){
            let n = i.indexOf(e.fd);
            if (n !== -1) {
                i.splice(n, 1), i.length === 0 && this.pathToFileDescriptors.delete(r);
                break;
            }
        }
    }
    async stat(e, r) {
        let i = e.toString();
        return (await this.getResponsibleFs(e)).stat(e);
    }
    async lstat(e, r) {
        return (await this.getResponsibleFs(e)).lstat(e, r);
    }
    async link(e, r) {
        throw new Error("not implemented");
    }
    async readlink(e, r) {
        throw new Error("not implemented");
    }
    async unlink(e) {
        return (await this.getResponsibleFs(e)).unlink(e);
    }
    async rename(e, r) {
        if (this.hiddenFilesFileSystem) {
            if (await this.hiddenFilesFileSystem.responsible(Vh.basename(e.toString()))) throw new Error("Renaming of hidden Files is not allowed " + e);
            if (await this.hiddenFilesFileSystem.responsible(Vh.basename(r.toString()))) throw new Error("Renaming to hidden Files is not allowed " + r);
        }
        let i = await this.getResponsibleFs(e), n = await this.getResponsibleFs(r);
        if (i === n) return i.rename(e, r);
        let o = await i.open(e.toString(), "r");
        try {
            let s = await i.fstat(o), l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(s.size);
            await i.read(o, l, 0, s.size, 0), await i.close(o), await n.writeFile(r.toString(), l, "utf8"), await i.unlink(e);
        } catch (s) {
            try {
                await i.close(o);
            } catch (e) {}
            throw s;
        }
    }
    async rmdir(e, r) {
        return (await this.getResponsibleFs(e)).rmdir(e, r);
    }
    async symlink(e, r, i) {
        throw new Error("not implemented");
    }
    async readFile(e, r) {
        let i = !0, n;
        if (typeof e == "number") {
            i = !1;
            let o = this.getFilehandle(e);
            if (!o) throw new Error("Invalid file descriptor");
            n = o;
        } else if (typeof e == "string") n = await this.open(e, "r");
        else throw new Error("only filehandle and path are supported atm");
        try {
            let s = (await n.stat()).size;
            if (typeof s == "bigint") {
                if (s > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error("File too large to read into buffer");
                s = Number(s);
            }
            let l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(s), { bytesRead: f } = await n.read(l, 0, s, 0);
            if (r && typeof r.encoding == "string") return l.slice(0, f).toString(r.encoding);
            if (typeof r == "string") {
                if (r === "utf8" || r === "utf-8") return l.slice(0, f).toString(r);
                throw new Error("Unsupported encoding: " + r);
            }
            return l.slice(0, f);
        } finally{
            n && i && await n.close();
        }
    }
    async writeFile(e, r, i) {
        let n = typeof e != "number", o, s, l, f = "w";
        if (typeof i == "string" ? s = i : i && typeof i == "object" && (s = i.encoding, l = i.mode, f = i.flag || "w"), typeof e == "number") {
            let c = this.getFilehandle(e);
            if (!c) throw new Error("Invalid file descriptor");
            o = c;
        } else if (typeof e == "string") o = await this.open(e, f, l);
        else throw new Error("only filehandle and path are supported atm");
        try {
            let c;
            if (typeof r == "string") c = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(r, s || "utf8");
            else if (r instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"]) c = r;
            else if (r instanceof Uint8Array) c = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(r);
            else throw new Error("Invalid data type for writeFile");
            let u = 0;
            for(; u < c.length;){
                let { bytesWritten: h } = await o.write(c, u, c.length - u, u);
                u += h;
            }
        } finally{
            o && n && await o.close();
        }
    }
    constructor({ name: e, parentFs: r, storageFs: i, gitRoot: n }){
        q(this, "promises");
        q(this, "gitRoot");
        q(this, "ephemeralFilesFileSystem");
        q(this, "hiddenFilesFileSystem");
        q(this, "passThroughFileSystem");
        q(this, "subFilesystems", []);
        q(this, "parentFs");
        q(this, "name");
        q(this, "pathToFileDescriptors", new Map);
        q(this, "openFileHandles", new Map);
        if (this.name = e, this.parentFs = r, this.gitRoot = n, this.promises = {
            access: this.access.bind(this),
            opendir: this.opendir.bind(this),
            mkdir: this.mkdir.bind(this),
            readdir: this.readdir.bind(this),
            open: this.open.bind(this),
            stat: this.stat.bind(this),
            lstat: this.lstat.bind(this),
            link: this.link.bind(this),
            readlink: this.readlink.bind(this),
            unlink: this.unlink.bind(this),
            rename: this.rename.bind(this),
            rmdir: this.rmdir.bind(this),
            symlink: this.symlink.bind(this),
            readFile: this.readFile.bind(this),
            writeFile: this.writeFile.bind(this),
            getFilehandle: this.getFilehandle.bind(this)
        }, !r && i) {
            this.passThroughFileSystem = new El({
                passThroughFs: i,
                gitRoot: n,
                parentFs: this
            });
            return;
        }
        if (!i && r) {
            this.passThroughFileSystem = new _l({
                parentFs: this,
                gitRoot: n
            });
            return;
        }
        throw new Error("invalid configuration");
    }
};
a(Gh, "CompositeFs");
var Ho = Gh;
var Gb = ae(id(), 1);
var nd = class nd extends bt {
    async responsible(r) {
        let i = r.replace(/\\/g, "/"), n = i.startsWith("./") ? i.slice(2) : i;
        return n = n.startsWith("/") ? n.slice(1) : n, n === "" || n === "." ? !1 : this.ig.ignores(n);
    }
    fileType() {
        return 255;
    }
    error(r) {
        return new Error("Access to hidden file is not allowed: ".concat(this.toStr(r)));
    }
    async open(r, i, n) {
        throw this.error(r);
    }
    async access(r) {
        throw this.error(r);
    }
    async stat(r) {
        throw this.error(r);
    }
    async lstat(r) {
        throw this.error(r);
    }
    async opendir(r) {
        throw this.error(r);
    }
    async link(r) {
        throw this.error(r);
    }
    async mkdir(r) {
        throw this.error(r);
    }
    async readdir(r) {
        throw this.error(r);
    }
    async readlink(r) {
        throw this.error(r);
    }
    async unlink(r) {
        throw this.error(r);
    }
    async rename(r) {
        throw this.error(r);
    }
    async rmdir(r) {
        throw this.error(r);
    }
    async symlink(r, i) {
        throw this.error(i);
    }
    async lookup(r) {
        throw this.error(r);
    }
    resolvePath(r) {
        throw new Error("Access to hidden file is not allowed: resolvePath(".concat(r, ")"));
    }
    async close(r) {
        throw new Error("Access to hidden file is not allowed: close: " + r.subFsFileDescriptor);
    }
    async dataSync(r) {
        throw new Error("Access to hidden file is not allowed: dataSync: " + r.subFsFileDescriptor);
    }
    async read(r, i, n, o, s) {
        throw new Error("Access to hidden file is not allowed: readFileHandle: " + r.subFsFileDescriptor);
    }
    constructor({ parentFs: r, gitRoot: i, hiddenFiles: n }){
        super({
            parentFs: r,
            gitRoot: i
        });
        q(this, "ig");
        this.ig = (0, Gb.default)(), this.ig.add(n);
    }
};
a(nd, "HiddenFileSubFs");
var Wo = nd;
var Rl = ae(Er(), 1), kl = ae(qo(), 1);
var Kb = ae(id(), 1);
var od = class od extends bt {
    normalizePath(r) {
        let i = typeof r == "string" ? r : r.toString();
        return i.startsWith("/") ? i : "/" + i;
    }
    async responsible(r) {
        let i = r.replace(/\\/g, "/"), n = i.startsWith("./") ? i.slice(2) : i;
        return n = n.startsWith("/") ? n.slice(1) : n, n === "" || n === "." ? !1 : this.ig.ignores(n);
    }
    fileType() {
        return 5;
    }
    async open(r, i, n) {
        let o = this.normalizePath(r), s = Rl.dirname(o);
        s && s !== "/" && s !== "." && await this.memFs.promises.mkdir(s, {
            recursive: !0
        });
        let l = await this.memFs.promises.open(o, i, n);
        return this.openFh.set(l.fd, l), new Rt({
            fs: this,
            subFsFileDescriptor: l.fd,
            parentFsFileDescriptors: [
                l.fd
            ]
        });
    }
    async access(r, i) {
        let n = this.normalizePath(r);
        return await this.memFs.promises.access(n, i);
    }
    async stat(r, i) {
        let n = this.normalizePath(r);
        return this.memFs.promises.stat(n, {
            bigint: !1
        });
    }
    async lstat(r, i) {
        let n = this.normalizePath(r);
        return this.memFs.promises.lstat(n, {
            bigint: !1
        });
    }
    async opendir(r, i) {
        let n = this.normalizePath(r);
        return await this.memFs.promises.opendir(n, i);
    }
    async link(r, i) {
        let n = this.normalizePath(r), o = this.normalizePath(i);
        return await this.memFs.promises.link(n, o);
    }
    async mkdir(r, i) {
        let n = this.normalizePath(r);
        if (!(typeof i == "object" && i && "recursive" in i && i.recursive)) {
            let s = Rl.dirname(n);
            if (s && s !== "/" && s !== ".") try {
                await this.memFs.promises.stat(s);
            } catch (e) {
                await this.memFs.promises.mkdir(s, {
                    recursive: !0
                });
            }
        }
        await this.memFs.promises.mkdir(n, i);
    }
    async readdir(r) {
        for(var _len = arguments.length, i = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            i[_key - 1] = arguments[_key];
        }
        let n = this.normalizePath(r), o = await this.memFs.promises.readdir(n, ...i);
        return console.log("EPHEMERAL: READDIR: ", o), o;
    }
    async readlink(r) {
        throw new Error("readlink is not implemented for EphemeralFileSubFs");
    }
    async unlink(r) {
        let i = this.normalizePath(r);
        return await this.memFs.promises.unlink(i);
    }
    async rename(r, i) {
        let n = this.normalizePath(r), o = this.normalizePath(i);
        return await this.memFs.promises.rename(n, o);
    }
    async rmdir(r, i) {
        let n = this.normalizePath(r);
        return await this.memFs.promises.rmdir(n, i);
    }
    async symlink(r, i, n) {
        let o = this.normalizePath(r), s = this.normalizePath(i);
        return await this.memFs.promises.symlink(o, s, n);
    }
    async lookup(r) {
        throw new Error("lookup is not implemented for: ".concat(this.toStr(r)));
    }
    async close(r) {
        let i = this.openFh.get(r.subFsFileDescriptor);
        i && (await i.close(), this.openFh.delete(r.subFsFileDescriptor));
    }
    async dataSync(r) {
        let i = this.openFh.get(r.subFsFileDescriptor);
        if (i) return await i.datasync();
    }
    async read(r, i, n, o, s) {
        let l = this.openFh.get(r.subFsFileDescriptor);
        if (l) return await l.read(i, n, o, s);
        throw new Error("File handle not found: ".concat(r.subFsFileDescriptor));
    }
    async fchmod(r, i) {
        let n = this.openFh.get(r.subFsFileDescriptor);
        if (n) return await n.chmod(i);
    }
    async fchown(r, i, n) {
        let o = this.openFh.get(r.subFsFileDescriptor);
        if (o) return await o.chown(i, n);
    }
    async write(r, i, n, o, s) {
        let l = this.openFh.get(r.subFsFileDescriptor);
        if (l) return await l.write(i, n, o, s);
        throw new Error("File handle not found: ".concat(r.subFsFileDescriptor));
    }
    async ftruncate(r, i) {
        let n = this.openFh.get(r.subFsFileDescriptor);
        if (n) return await n.truncate(i);
    }
    resolvePath(r) {
        throw new Error("resolvePath is not implemented: resolvePath(".concat(r, ")"));
    }
    async fstat(r, i) {
        let n = this.openFh.get(r.subFsFileDescriptor);
        if (n) return await n.stat(i);
        throw new Error("File handle not found: ".concat(r.subFsFileDescriptor));
    }
    async futimes(r, i, n) {
        let o = this.openFh.get(r.subFsFileDescriptor);
        if (o) return await o.utimes(i, n);
    }
    async writev(r, i, n) {
        let o = this.openFh.get(r.subFsFileDescriptor);
        if (o) return await o.writev(i, n !== null && n !== void 0 ? n : void 0);
        throw new Error("File handle not found: ".concat(r.subFsFileDescriptor));
    }
    async readv(r, i, n) {
        let o = this.openFh.get(r.subFsFileDescriptor);
        if (o) return await o.readv(i, n !== null && n !== void 0 ? n : void 0);
        throw new Error("File handle not found: ".concat(r.subFsFileDescriptor));
    }
    async readFile(r, i) {
        if (typeof r == "string" || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(r)) {
            let n = this.normalizePath(r);
            return this.memFs.promises.readFile(n, i);
        }
        return super.readFile(r, i);
    }
    async writeFile(r, i, n) {
        let o = this.normalizePath(r), s = Rl.dirname(o);
        return s && s !== "/" && s !== "." && await this.memFs.promises.mkdir(s, {
            recursive: !0
        }), this.memFs.promises.writeFile(o, i, n);
    }
    constructor({ parentFs: r, gitRoot: i, ephemeralPatterns: n }){
        super({
            parentFs: r,
            gitRoot: i
        });
        q(this, "openFh", new Map);
        q(this, "memFs", (0, kl.createFsFromVolume)(new kl.Volume));
        q(this, "ig");
        q(this, "patterns");
        this.compositFs = r, this.gitRoot = i, this.ig = (0, Kb.default)(), this.ig.add(n), this.patterns = n;
    }
};
a(od, "EphemeralSubFs");
var Vo = od;
var im = ae(Er(), 1), df = ae(qo(), 1);
var rf = ae(ze(), 1);
var nf = {
    type: "gitBranchesListVirtualFile",
    getStats: a(async (param)=>{
        let { gitRoot: t, nodeFs: e } = param;
        let r = t + "/.git";
        try {
            return await e.stat(r);
        } catch (e) {
            throw new Error("ENOENT: no such file or directory, stat '".concat(r, "'"));
        }
    }, "getStats"),
    getFile: a(async (param)=>{
        let { gitRoot: t, nodeFs: e } = param;
        try {
            let r = await rf.default.listBranches({
                fs: e,
                dir: t
            }), i = await rf.default.currentBranch({
                fs: e,
                dir: t
            }), n = await Promise.all(r.map(async (o)=>{
                let s = await rf.default.resolveRef({
                    fs: e,
                    dir: t,
                    ref: o
                });
                return o;
            }));
            return {
                type: "directory",
                content: n,
                mode: 493,
                size: n
            };
        } catch (r) {
            throw r;
        }
    }, "getFile"),
    rename: a(async (t)=>{
        throw new Error("not implemented");
    }, "rename"),
    mkdir: a(async function(t) {
        throw new Error("not implemented");
    }, "mkdir")
};
var ue = ae(ze(), 1);
var vr = ae(ze(), 1);
async function _r(t, e, r) {
    try {
        return await vr.default.resolveRef({
            fs: t,
            dir: e,
            ref: "refs/heads/".concat(r)
        });
    } catch (e) {
        return;
    }
}
a(_r, "tryResolveRef");
async function Qn(param) {
    let { dir: t, fs: e, treeOid: r, deletePathParts: i, addPathParts: n, addObj: o } = param;
    let [s, ...l] = n !== null && n !== void 0 ? n : [], [f, ...c] = i !== null && i !== void 0 ? i : [], u = [];
    if (r) {
        let { tree: h } = await vr.default.readTree({
            fs: e,
            dir: t,
            oid: r
        });
        u = [
            ...h
        ];
    }
    if (s === f) {
        var _this;
        let h = s;
        if (h === void 0) throw new Error("illegal arguement - called with out a path part");
        if (l.length === 0) throw new Error("can not move into it self");
        if (c.length === 0) throw new Error("can not move from it self");
        let d = u.findIndex((v)=>v.path === h), m = (_this = d !== -1 ? u[d] : void 0) === null || _this === void 0 ? void 0 : _this.oid, y = await Qn({
            dir: t,
            fs: e,
            treeOid: m,
            addPathParts: l,
            deletePathParts: c,
            addObj: o
        });
        if (y === void 0) throw new Error("on the same path we expect an update - respectivly a newly created subTreeOid");
        let w = !1;
        if (y !== m) {
            w = !0;
            let v = {
                mode: "040000",
                path: h,
                oid: y,
                type: "tree"
            };
            d !== -1 ? u[d] = v : u.push(v);
        }
        if (r == null && !w) throw new Error("Illegal state - if the currentOid is undefined - a new tree should have been created (an update should have happened)");
        if (w) return await vr.default.writeTree({
            fs: e,
            dir: t,
            tree: u
        });
        if (r === void 0) throw new Error("currentOid should be set - since the sub tree didn't exist and ");
        return r;
    } else {
        let h = !1, d;
        if (f) {
            let p = u.findIndex((y)=>y.path === f), m = p !== -1 ? u[p] : void 0;
            if (m === void 0) throw new Error("Element doesnt exist in tree");
            if (c.length > 0) {
                if (m && m.type !== "tree") throw new Error("SubPart of the path for the obj to delete is not a tree");
                let y = await Qn({
                    dir: t,
                    fs: e,
                    treeOid: m.oid,
                    addPathParts: void 0,
                    deletePathParts: c,
                    addObj: o
                });
                if (y === m.oid) throw new Error("in case of a delete we expect a different subtree oid");
                h = !0, y === void 0 ? u.splice(p, 1) : u[p] = {
                    mode: "040000",
                    path: f,
                    oid: y,
                    type: "tree"
                };
            } else h = !0, u.splice(p, 1);
            d = m;
        }
        if (s) {
            let p = u.findIndex((y)=>y.path === s), m = p !== -1 ? u[p] : void 0;
            if (l.length > 0) {
                if (m && m.type !== "tree") throw new Error("SubPart of the path for the obj to add is not a tree");
                let y = await Qn({
                    dir: t,
                    fs: e,
                    treeOid: m === null || m === void 0 ? void 0 : m.oid,
                    addPathParts: l,
                    deletePathParts: void 0,
                    addObj: o
                });
                if (y === void 0) throw new Error("in case we add, we expect an update - respectivly a newly created subTreeOid");
                if (y !== (m === null || m === void 0 ? void 0 : m.oid)) {
                    h = !0;
                    let w = {
                        mode: "040000",
                        path: s,
                        oid: y,
                        type: "tree"
                    };
                    p !== -1 ? u[p] = w : u.push(w);
                }
            } else {
                h = !0;
                let y = {
                    mode: o.type === "tree" ? "040000" : "100644",
                    path: s,
                    oid: o.oid,
                    type: o.type
                };
                p !== -1 ? u[p] = y : u.push(y);
            }
        }
        if (u.length === 0) return;
        if (h) return await vr.default.writeTree({
            fs: e,
            dir: t,
            tree: u
        });
        if (r === void 0) throw new Error("currentOid should be set - since the sub tree didn't exist and ");
        return r;
    }
}
_c190 = Qn;
a(Qn, "buildUpdatedTree");
async function Ii(param) {
    let { filePath: t, gitRoot: e, nodeFs: r, commitSha: i, pathParams: n } = param;
    if (!n.filePath) {
        let l = await vr.default.readTree({
            fs: r,
            dir: e,
            oid: i
        });
        return {
            type: "tree",
            entries: l.tree.map((c)=>c.path),
            oid: l.oid
        };
    }
    return (await vr.default.walk({
        fs: r,
        dir: e,
        trees: [
            vr.default.TREE({
                ref: i
            })
        ],
        map: a(async (l, param)=>{
            let [f] = param;
            if (l === n.filePath && f) {
                let c = await f.type();
                if (c === "blob") return {
                    type: "blob",
                    oid: await f.oid()
                };
                if (c == "tree") {
                    let u = await vr.default.readTree({
                        fs: r,
                        dir: e,
                        oid: await f.oid()
                    });
                    return {
                        type: "tree",
                        entries: u.tree.map((d)=>d.path),
                        oid: u.oid
                    };
                }
            }
        }, "map")
    })).find((l)=>l !== void 0);
}
_c191 = Ii;
a(Ii, "resolveGitObjAtPath");
var of = class of extends Error {
    constructor(r, i){
        super(r);
        q(this, "code", "ENOENT");
        q(this, "path");
        this.name = "ENOENTError", this.path = i, Object.setPrototypeOf(this, of.prototype);
    }
};
a(of, "ENOENTError");
var Di = of;
async function _1(t, e, r, i) {
    let [n, ...o] = i;
    if (!n) return r;
    let { tree: s } = await ue.default.readTree({
        fs: t,
        dir: e,
        oid: r
    }), l = [
        ...s
    ], f = l.findIndex((c)=>c.path === n);
    if (f === -1) return r;
    if (o.length === 0) l.splice(f, 1);
    else {
        let c = l[f];
        if (c && c.type === "tree") {
            let u = await _1(t, e, c.oid, o);
            if (u !== c.oid) l[f] = {
                mode: c.mode,
                path: c.path,
                type: c.type,
                oid: u
            };
            else return r;
        } else return r;
    }
    return await ue.default.writeTree({
        fs: t,
        dir: e,
        tree: l
    });
}
a(_1, "buildTreeWithoutFile");
var eo = {
    type: "gitBranchFileVirtualFile",
    getStats: a(async (param)=>{
        let { gitRoot: t, nodeFs: e, filePath: r, cacheFs: i, pathParams: n } = param;
        if (n.branchName === void 0) throw new Error("branchName should be in pathParams");
        let o = await _r(e, t, n.branchName);
        if (!o) throw new Di("ENOENT: no such file or directory, stat '".concat(r, "'"), r);
        let s = await Ii({
            filePath: r,
            gitRoot: t,
            nodeFs: e,
            commitSha: o,
            pathParams: n
        });
        if (!s) throw new Di("ENOENT: no such file or directory, stat '".concat(r, "'"), r);
        let l = await ue.default.readCommit({
            fs: e,
            dir: t,
            oid: o
        }), { commit: f } = l, c = f.committer.timestamp * 1e3;
        if (s.type === "tree") return {
            mode: 420,
            size: 0,
            isFile: a(()=>!0, "isFile"),
            isDirectory: a(()=>!0, "isDirectory"),
            isSymbolicLink: a(()=>!1, "isSymbolicLink"),
            isBlockDevice: a(()=>!1, "isBlockDevice"),
            isCharacterDevice: a(()=>!1, "isCharacterDevice"),
            isSocket: a(()=>!1, "isSocket"),
            isFIFO: a(()=>!1, "isFIFO"),
            isFileSync: a(()=>!0, "isFileSync"),
            isDirectorySync: a(()=>!1, "isDirectorySync"),
            dev: 0,
            ino: 0,
            nlink: 1,
            uid: 0,
            gid: 0,
            rdev: 0,
            blksize: 4096,
            blocks: 0,
            atimeMs: c,
            mtimeMs: c,
            ctimeMs: c,
            birthtimeMs: c,
            atime: new Date(c),
            mtime: new Date(c),
            ctime: new Date(c),
            birthtime: new Date(c)
        };
        {
            let { blob: u } = await ue.default.readBlob({
                fs: e,
                dir: t,
                oid: s.oid
            });
            return {
                mode: 420,
                size: u.length,
                isFile: a(()=>!0, "isFile"),
                isDirectory: a(()=>!1, "isDirectory"),
                isSymbolicLink: a(()=>!1, "isSymbolicLink"),
                isBlockDevice: a(()=>!1, "isBlockDevice"),
                isCharacterDevice: a(()=>!1, "isCharacterDevice"),
                isSocket: a(()=>!1, "isSocket"),
                isFIFO: a(()=>!1, "isFIFO"),
                isFileSync: a(()=>!0, "isFileSync"),
                isDirectorySync: a(()=>!1, "isDirectorySync"),
                dev: 0,
                ino: 0,
                nlink: 1,
                uid: 0,
                gid: 0,
                rdev: 0,
                blksize: 4096,
                blocks: Math.ceil(u.length / 4096),
                atimeMs: c,
                mtimeMs: c,
                ctimeMs: c,
                birthtimeMs: c,
                atime: new Date(c),
                mtime: new Date(c),
                ctime: new Date(c),
                birthtime: new Date(c)
            };
        }
    }, "getStats"),
    getFile: a(async (param)=>{
        let { filePath: t, gitRoot: e, nodeFs: r, cacheFs: i, pathParams: n } = param;
        if (n.branchName === void 0) throw new Error("branchName should be in pathParams");
        let o = [];
        try {
            let s = await _r(r, e, n.branchName), l = await _r(r, e, "refs/heads/" + n.branchName);
            if (!s) {
                let c = await ue.default.resolveRef({
                    fs: r,
                    dir: e,
                    ref: "HEAD"
                });
                await ue.default.branch({
                    fs: r,
                    dir: e,
                    ref: n.branchName,
                    object: c
                }), s = await ue.default.resolveRef({
                    fs: r,
                    ref: "refs/heads/".concat(n.branchName),
                    dir: e
                });
            }
            let f = await Ii({
                filePath: t,
                gitRoot: e,
                nodeFs: r,
                commitSha: s,
                pathParams: n
            });
            if (!f) return;
            if (f.type === "blob") {
                let { blob: c } = await ue.default.readBlob({
                    fs: r,
                    dir: e,
                    oid: f.oid
                });
                return {
                    type: "file",
                    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(c),
                    mode: 420,
                    size: c.length,
                    oid: f.oid
                };
            } else {
                let c = [];
                try {
                    let h = await i.promises.stat(t);
                    if (h && h.isDirectory()) {
                        let d = await i.promises.readdir(t, {
                            withFileTypes: !1,
                            encoding: "utf-8"
                        });
                        c.push(...d.filter((p)=>p !== ".keep"));
                    }
                } catch (e) {}
                return {
                    type: "directory",
                    content: Array.from(new Set([
                        ...f.entries.filter((h)=>h !== ".keep"),
                        ...c
                    ])),
                    mode: 493
                };
            }
        } catch (e) {
            return;
        }
    }, "getFile"),
    unlink: a(async (param)=>{
        let { filePath: t, gitRoot: e, nodeFs: r, cacheFs: i, pathParams: n } = param;
        if (!n.branchName) throw new Error("branchName should be in pathParams");
        if (!n.filePath) throw new Error("filePath should be in pathParams");
        let o = await ue.default.resolveRef({
            fs: r,
            dir: e,
            ref: n.branchName
        }), s = await ue.default.readTree({
            fs: r,
            dir: e,
            oid: o
        }), l = await _1(r, e, s.oid, n.filePath.split("/"));
        if (l !== s.oid) {
            let f = await ue.default.commit({
                fs: r,
                dir: e,
                message: "Delete ".concat(n.filePath),
                tree: l,
                noUpdateBranch: !0,
                parent: [
                    o
                ],
                author: {
                    name: "GitLegitFs",
                    email: "gitlegit@example.com",
                    timestamp: Math.floor(Date.now() / 1e3),
                    timezoneOffset: 0
                }
            });
            await ue.default.writeRef({
                fs: r,
                dir: e,
                ref: "refs/heads/".concat(n.branchName),
                value: f,
                force: !0
            });
        }
    }, "unlink"),
    writeFile: a(async (param)=>{
        let { filePath: t, gitRoot: e, nodeFs: r, content: i, cacheFs: n, pathParams: o } = param;
        if (o.branchName === void 0) throw new Error("branchName should be in pathParams");
        if (o.filePath === void 0) throw new Error("filePath should be in pathParams");
        let s;
        typeof i == "string" ? s = new TextEncoder().encode(i) : s = new Uint8Array(i);
        let l = await ue.default.writeBlob({
            fs: r,
            dir: e,
            blob: s
        }), f = await _r(r, e, o.branchName);
        if (!f) {
            let h = await ue.default.resolveRef({
                fs: r,
                dir: e,
                ref: "HEAD"
            });
            await ue.default.branch({
                fs: r,
                dir: e,
                ref: o.branchName,
                object: h
            }), f = await ue.default.resolveRef({
                fs: r,
                dir: e,
                ref: "refs/heads/".concat(o.branchName)
            });
        }
        let c = await ue.default.readTree({
            fs: r,
            dir: e,
            oid: f
        }), u = await Qn({
            dir: e,
            fs: r,
            treeOid: c.oid,
            addPathParts: o.filePath.split("/"),
            deletePathParts: void 0,
            addObj: {
                type: "blob",
                oid: l
            }
        });
        if (u !== c.oid) {
            let h = await ue.default.commit({
                fs: r,
                dir: e,
                message: " Change '".concat(o.filePath, "'"),
                tree: u,
                noUpdateBranch: !0,
                parent: [
                    f
                ],
                author: {
                    name: "GitLegitFs",
                    email: "gitlegit@example.com",
                    timestamp: Math.floor(Date.now() / 1e3),
                    timezoneOffset: 0
                }
            });
            await ue.default.writeRef({
                fs: r,
                dir: e,
                ref: "refs/heads/".concat(o.branchName),
                value: h,
                force: !0
            });
        }
    }, "writeFile"),
    rename: a(async function(param) {
        let { filePath: t, newPath: e, gitRoot: r, nodeFs: i, pathParams: n, newPathParams: o } = param;
        if (n.branchName === void 0) throw new Error("branchName should be in pathParams");
        if (n.filePath === void 0) throw new Error("filePath should be in pathParams");
        if (o.branchName === void 0) throw new Error("branchName should be in newPathParams");
        if (o.filePath === void 0) throw new Error("filePath should be in newPathParams");
        let s = await _r(i, r, n.branchName);
        if (!s) throw new Error("Invalid branch file path - source branch must exist");
        let l = await _r(i, r, o.branchName);
        if (!l) {
            let h = await ue.default.resolveRef({
                fs: i,
                dir: r,
                ref: "HEAD"
            });
            await ue.default.branch({
                fs: i,
                dir: r,
                ref: o.branchName,
                object: h
            }), l = await ue.default.resolveRef({
                fs: i,
                dir: r,
                ref: "refs/heads/".concat(o.branchName)
            });
        }
        if (o.branchName !== n.branchName) throw new Error("cross branch move not implemented yet");
        let f = await Ii({
            gitRoot: r,
            nodeFs: i,
            commitSha: s,
            filePath: t,
            pathParams: n
        });
        if (f === void 0) throw new Error("no obj at path exists");
        let c = await Qn({
            dir: r,
            fs: i,
            deletePathParts: n.filePath.split("/"),
            addPathParts: o.filePath.split("/"),
            addObj: f,
            treeOid: l
        }), u = await ue.default.readTree({
            fs: i,
            dir: r,
            oid: s
        });
        if (c !== u.oid) {
            let h = await ue.default.commit({
                fs: i,
                dir: r,
                message: " Rename '".concat(n.filePath, "' to '").concat(o.filePath, "'"),
                tree: c,
                noUpdateBranch: !0,
                parent: [
                    l
                ],
                author: {
                    name: "GitLegitFs",
                    email: "gitlegit@example.com",
                    timestamp: Math.floor(Date.now() / 1e3),
                    timezoneOffset: 0
                }
            });
            await ue.default.writeRef({
                fs: i,
                dir: r,
                ref: "refs/heads/".concat(o.branchName),
                value: h,
                force: !0
            });
        }
    }, "rename"),
    mkdir: a(async function(t) {
        try {
            throw await eo.getStats(t), new Error("Folder exists");
        } catch (e) {}
        t.filePath.endsWith("/") && (t.filePath = t.filePath.replace(/\/+$/, "")), t.pathParams && typeof t.pathParams.filePath == "string" && (t.pathParams.filePath = t.pathParams.filePath.replace(/\/+$/, ""));
        let e = {
            ...t,
            filePath: t.filePath += ".keep",
            content: ""
        };
        e.pathParams.filePath += "/.keep", await eo.writeFile(e);
    }, "mkdir")
};
var to = ae(ze(), 1);
var sf = {
    type: "gitBranchHeadVirtualFile",
    getStats: a(async (param)=>{
        let { gitRoot: t, nodeFs: e, pathParams: r } = param;
        if (r.branchName === void 0) throw new Error("branchName should be in pathParams");
        let i;
        try {
            i = await to.default.resolveRef({
                fs: e,
                dir: t,
                ref: r.branchName
            });
        } catch (e1) {
            i = await to.default.resolveRef({
                fs: e,
                dir: t,
                ref: "refs/heads/".concat(r.branchName)
            });
        }
        let n = await to.default.readCommit({
            fs: e,
            dir: t,
            oid: i
        }), { commit: o } = n, s = o.committer.timestamp * 1e3;
        return {
            mode: 420,
            size: 40,
            isFile: a(()=>!0, "isFile"),
            isDirectory: a(()=>!1, "isDirectory"),
            isSymbolicLink: a(()=>!1, "isSymbolicLink"),
            isBlockDevice: a(()=>!1, "isBlockDevice"),
            isCharacterDevice: a(()=>!1, "isCharacterDevice"),
            isSocket: a(()=>!1, "isSocket"),
            isFIFO: a(()=>!1, "isFIFO"),
            isFileSync: a(()=>!0, "isFileSync"),
            isDirectorySync: a(()=>!1, "isDirectorySync"),
            dev: 0,
            ino: 0,
            nlink: 1,
            uid: 0,
            gid: 0,
            rdev: 0,
            blksize: 4096,
            blocks: Math.ceil(40 / 4096),
            atimeMs: s,
            mtimeMs: s,
            ctimeMs: s,
            birthtimeMs: s,
            atime: new Date(s),
            mtime: new Date(s),
            ctime: new Date(s),
            birthtime: new Date(s)
        };
    }, "getStats"),
    getFile: a(async (param)=>{
        let { gitRoot: t, nodeFs: e, pathParams: r } = param;
        if (r.branchName === void 0) throw new Error("branchName should be in pathParams");
        try {
            let i;
            try {
                i = await to.default.resolveRef({
                    fs: e,
                    dir: t,
                    ref: r.branchName
                });
            } catch (e1) {
                i = await to.default.resolveRef({
                    fs: e,
                    dir: t,
                    ref: "refs/heads/".concat(r.branchName)
                });
            }
            return {
                type: "file",
                content: i + "\n",
                mode: 420,
                size: i.length
            };
        } catch (e) {
            return;
        }
    }, "getFile"),
    rename (t) {
        throw new Error("not implementsd");
    },
    mkdir: a(async function(t) {
        throw new Error("not implemented");
    }, "mkdir")
};
var F1 = ae(ze(), 1);
var E1 = {
    type: "gitBranchTipVirtualFile",
    getStats: a(async (t)=>{
        let e = t.gitRoot + "/.git";
        try {
            return await t.fs.stat(e);
        } catch (e1) {
            throw new Error("ENOENT: no such file or directory, stat '".concat(e, "'"));
        }
    }, "getStats"),
    getFile: a(async (param)=>{
        let { filePath: t, gitRoot: e, nodeFs: r, pathParams: i } = param;
        if (!i.branchName) throw new Error("branchName should be in pathParams");
        try {
            let n = await F1.default.resolveRef({
                fs: r,
                dir: e,
                ref: "refs/heads/".concat(i.branchName)
            });
            return {
                type: "file",
                content: n + "\n",
                mode: 420,
                size: n.length + 1
            };
        } catch (e) {
            return;
        }
    }, "getFile"),
    rename (t) {
        throw new Error("not implementsd");
    },
    mkdir: a(async function(t) {
        throw new Error("not implemented");
    }, "mkdir")
};
var af = ae(ze(), 1);
var lf = {
    type: "gitCommitFileVirtualFile",
    getStats: a(async (param)=>{
        let { filePath: t, gitRoot: e, nodeFs: r, pathParams: i } = param;
        if (!i.sha_1_1_2) throw new Error("sha_1_1_2 should be in pathParams");
        if (!i.sha1_3__40) throw new Error("sha1_3__40 should be in pathParams");
        let n = i.sha_1_1_2 + i.sha1_3__40, o = await Ii({
            filePath: t,
            gitRoot: e,
            nodeFs: r,
            commitSha: n,
            pathParams: i
        });
        if (!o) throw new Di("ENOENT: no such file or directory, stat '".concat(t, "'"), t);
        let s = await af.default.readCommit({
            fs: r,
            dir: e,
            oid: n
        }), { commit: l } = s, f = l.committer.timestamp * 1e3;
        if (o.type === "tree") return {
            mode: 420,
            size: 0,
            isFile: a(()=>!0, "isFile"),
            isDirectory: a(()=>!0, "isDirectory"),
            isSymbolicLink: a(()=>!1, "isSymbolicLink"),
            isBlockDevice: a(()=>!1, "isBlockDevice"),
            isCharacterDevice: a(()=>!1, "isCharacterDevice"),
            isSocket: a(()=>!1, "isSocket"),
            isFIFO: a(()=>!1, "isFIFO"),
            isFileSync: a(()=>!0, "isFileSync"),
            isDirectorySync: a(()=>!1, "isDirectorySync"),
            dev: 0,
            ino: 0,
            nlink: 1,
            uid: 0,
            gid: 0,
            rdev: 0,
            blksize: 4096,
            blocks: 0,
            atimeMs: f,
            mtimeMs: f,
            ctimeMs: f,
            birthtimeMs: f,
            atime: new Date(f),
            mtime: new Date(f),
            ctime: new Date(f),
            birthtime: new Date(f)
        };
        {
            let { blob: c } = await af.default.readBlob({
                fs: r,
                dir: e,
                oid: o.oid
            });
            return {
                mode: 420,
                size: c.length,
                isFile: a(()=>!0, "isFile"),
                isDirectory: a(()=>!1, "isDirectory"),
                isSymbolicLink: a(()=>!1, "isSymbolicLink"),
                isBlockDevice: a(()=>!1, "isBlockDevice"),
                isCharacterDevice: a(()=>!1, "isCharacterDevice"),
                isSocket: a(()=>!1, "isSocket"),
                isFIFO: a(()=>!1, "isFIFO"),
                isFileSync: a(()=>!0, "isFileSync"),
                isDirectorySync: a(()=>!1, "isDirectorySync"),
                dev: 0,
                ino: 0,
                nlink: 1,
                uid: 0,
                gid: 0,
                rdev: 0,
                blksize: 4096,
                blocks: Math.ceil(c.length / 4096),
                atimeMs: f,
                mtimeMs: f,
                ctimeMs: f,
                birthtimeMs: f,
                atime: new Date(f),
                mtime: new Date(f),
                ctime: new Date(f),
                birthtime: new Date(f)
            };
        }
    }, "getStats"),
    getFile: a(async (param)=>{
        let { filePath: t, gitRoot: e, nodeFs: r, pathParams: i } = param;
        if (!i.sha_1_1_2) throw new Error("sha_1_1_2 should be in pathParams");
        if (!i.sha1_3__40) throw new Error("sha1_3__40 should be in pathParams");
        let n = i.sha_1_1_2 + i.sha1_3__40;
        try {
            let o = await Ii({
                filePath: t,
                gitRoot: e,
                nodeFs: r,
                commitSha: n,
                pathParams: i
            });
            if (!o) return;
            if (o.type === "blob") {
                let { blob: s } = await af.default.readBlob({
                    fs: r,
                    dir: e,
                    oid: o.oid
                });
                return {
                    type: "file",
                    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(s),
                    mode: 420,
                    size: s.length,
                    oid: o.oid
                };
            } else return {
                type: "directory",
                content: Array.from(new Set([
                    ...o.entries.filter((l)=>l !== ".keep")
                ])),
                mode: 493
            };
        } catch (e) {
            return;
        }
    }, "getFile"),
    rename (t) {
        throw new Error("not implementsd");
    },
    mkdir: a(async function(t) {
        throw new Error("not implemented");
    }, "mkdir")
};
var cf = ae(ze(), 1);
function W$(t, e, r) {
    return t === 0 && e === 2 && r === 0 ? "untracked" : t === 1 && e === 0 && r === 0 ? "deleted" : t === 1 && e === 2 && r !== 0 ? "modified" : t === 0 && e === 2 && r === 2 ? "added" : "unknown";
}
_c192 = W$;
a(W$, "getFileStatus");
var S1 = {
    type: "gitStatusVirtualFile",
    getStats: a(async (t)=>{
        let e = t.gitRoot + "/.git";
        try {
            return await t.fs.stat(e);
        } catch (e1) {
            throw new Error("ENOENT: no such file or directory, stat '".concat(e, "'"));
        }
    }, "getStats"),
    getFile: a(async (param)=>{
        let { gitRoot: t, nodeFs: e } = param;
        try {
            let r = await cf.default.currentBranch({
                fs: e,
                dir: t
            }) || "HEAD", i = await cf.default.resolveRef({
                fs: e,
                dir: t,
                ref: "HEAD"
            }), o = (await cf.default.statusMatrix({
                fs: e,
                dir: t
            })).filter((param)=>{
                let [, l, f, c] = param;
                return l !== f || f !== c;
            }).map((param)=>{
                let [l, f, c, u] = param;
                return {
                    path: l,
                    status: W$(f, c, u)
                };
            }), s = JSON.stringify({
                branch: r,
                commit: i,
                clean: o.length === 0,
                files: o
            }, null, 2);
            return {
                type: "file",
                content: s,
                mode: 33188,
                size: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].byteLength(s)
            };
        } catch (r) {
            throw console.error(r), r;
        }
    }, "getFile"),
    rename (t) {
        throw new Error("not implementsd");
    },
    mkdir: a(async function(t) {
        throw new Error("not implemented");
    }, "mkdir")
};
var Ns = {
    type: "legitVirtualFile",
    getStats: a(async (param)=>{
        let { gitRoot: t, nodeFs: e } = param;
        let r = t + "/.git";
        try {
            return await e.stat(r);
        } catch (e) {
            throw new Error("ENOENT: no such file or directory, stat '".concat(r, "'"));
        }
    }, "getStats"),
    getFile: a(async (param)=>{
        let { gitRoot: t, nodeFs: e } = param;
        return {
            type: "directory",
            content: [],
            mode: 493,
            size: 0
        };
    }, "getFile"),
    rename (t) {
        throw new Error("not implementsd");
    },
    mkdir: a(async function(t) {
        throw new Error("not implemented");
    }, "mkdir")
};
var x1 = [
    Ns,
    S1,
    lf,
    nf,
    eo,
    sf,
    E1
];
var Qp = class Qp {
    match(e) {
        e.length > 1 && e.endsWith("/") && (e = e.replace(/\/+$/, ""));
        for (let { regex: r, paramNames: i, handler: n, staticSiblings: o } of this.compiledRoutes){
            let s = e.match(r);
            if (!s) continue;
            let l = {};
            for(let f = 0; f < i.length; f++)l[i[f]] = decodeURIComponent(s[f + 1] || "");
            return {
                handler: n,
                params: l,
                staticSiblings: o
            };
        }
    }
    constructor(e){
        this.routes = e;
        q(this, "compiledRoutes");
        let r = {}, i = a((n, o)=>{
            if (typeof n.type == "string") {
                r[o] = {
                    handler: n,
                    siblings: []
                };
                let s = n;
            } else {
                let s = [];
                for (let [l, f] of Object.entries(n))if (l === ".") {
                    if (r[o]) throw new Error("Conflict: multiple handlers for path '".concat(o, "', '.' and optional '[[parameter_name]]' defined?"));
                    r[o] = {
                        handler: f,
                        siblings: s
                    };
                } else if (l.startsWith("[[") && l.endsWith("]]")) {
                    if (r[o]) throw new Error("Conflict: multiple handlers for path '".concat(o, "', '.' and optional '[[parameter_name]]' defined?"));
                    r[o] = {
                        handler: f,
                        siblings: s
                    }, l.startsWith("[[...") ? r[o ? "".concat(o, "/").concat(l) : l] = {
                        handler: f,
                        siblings: []
                    } : i(f, o ? "".concat(o, "/").concat(l) : l);
                } else l.startsWith("[") && l.endsWith("]") ? l.startsWith("[...") ? r[o ? "".concat(o, "/").concat(l) : l] = {
                    handler: f,
                    siblings: []
                } : i(f, o ? "".concat(o, "/").concat(l) : l) : (s.push(l), i(f, o ? "".concat(o, "/").concat(l) : l));
            }
        }, "walk");
        for (let [n, o] of Object.entries(e))i(o, n);
        this.compiledRoutes = Object.entries(r).map((param)=>{
            let [n, o] = param;
            let s = [], l = n.split("/").map((c)=>{
                if (c.startsWith("[[") && c.endsWith("]]")) {
                    let u = c.slice(2, -2).replace(/^\.\.\./, "");
                    return s.push(u), "(.*)";
                }
                if (c.startsWith("[") && c.endsWith("]")) {
                    let u = c.slice(1, -1);
                    return s.push(u), "([^/]+)";
                }
                return c.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            }).join("/");
            return {
                regex: new RegExp("^".concat(l, "$")),
                paramNames: s,
                staticSiblings: o.siblings,
                handler: o.handler
            };
        });
    }
};
a(Qp, "LegitPathRouter");
var ff = Qp;
var uf = ae(ze(), 1);
var em = {
    type: "gitCommitVirtualFolder",
    getStats: a(async (t)=>{
        let e = t.gitRoot + "/.git";
        try {
            return await t.fs.stat(e);
        } catch (e1) {
            throw new Error("ENOENT: no such file or directory, stat '".concat(e, "'"));
        }
    }, "getStats"),
    getFile: a(async (param)=>{
        let { filePath: t, gitRoot: e, nodeFs: r, pathParams: i } = param;
        let n = await uf.default.listBranches({
            fs: r,
            dir: e
        }), o = new Set, s = new Set;
        for (let c of n){
            let u = "refs/heads/".concat(c);
            try {
                let h = await uf.default.resolveRef({
                    fs: r,
                    dir: e,
                    ref: u
                });
                o.add(h);
            } catch (e) {}
        }
        for (let c of o){
            let u = await uf.default.log({
                fs: r,
                dir: e,
                ref: c
            });
            for (let h of u)s.add(h.oid);
        }
        if (!i.sha_1_1_2) {
            let c = new Set;
            for (let h of s)if (c.add(h.slice(0, 2)), c.size >= 256) break;
            let u = Array.from(c).sort();
            return {
                type: "directory",
                content: u,
                mode: 493,
                size: u
            };
        }
        let l = new Set;
        for (let c of s)c.startsWith(i.sha_1_1_2) && l.add(c.slice(2, 40));
        let f = Array.from(l).sort();
        return {
            type: "directory",
            content: f,
            mode: 493,
            size: f.length
        };
    }, "getFile"),
    rename (t) {
        throw new Error("not implementsd");
    },
    mkdir: a(async function(t) {
        throw new Error("not implemented");
    }, "mkdir")
};
var it = ae(ze(), 1);
var T1 = ae(ze(), 1);
var tm = "-operation";
async function Bt(t, e, r) {
    return (await T1.default.listBranches({
        fs: t,
        dir: e
    })).filter((n)=>n.endsWith("__" + r + tm))[0];
}
_c193 = Bt;
a(Bt, "resolveOperationBranchName");
var O1 = {
    type: "gitBranchOperationVirtualFile",
    getStats: a(async (t)=>{
        let { gitRoot: e, nodeFs: r, pathParams: i } = t, n;
        try {
            n = await it.default.resolveRef({
                fs: r,
                dir: e,
                ref: "refs/heads/".concat(i.branchName)
            });
        } catch (e) {
            throw new Error("Base Branch ".concat(i.branchName, " for operations does not exis"));
        }
        let o = await Bt(r, e, i.branchName), s = !1;
        if (o) try {
            n = await it.default.resolveRef({
                fs: r,
                dir: e,
                ref: o
            }), s = !0;
        } catch (e1) {
            try {
                n = await it.default.resolveRef({
                    fs: r,
                    dir: e,
                    ref: "refs/heads/".concat(o)
                }), s = !0;
            } catch (e) {}
        }
        let l = await it.default.readCommit({
            fs: r,
            dir: e,
            oid: n
        }), { commit: f } = l, c = f.committer.timestamp * 1e3;
        try {
            return {
                mode: 420,
                size: 40,
                atimeMs: c,
                mtimeMs: c,
                ctimeMs: c,
                birthtimeMs: c,
                atime: new Date(c),
                mtime: new Date(c),
                ctime: new Date(c),
                birthtime: new Date(c),
                isFile: a(()=>!0, "isFile"),
                isDirectory: a(()=>!1, "isDirectory"),
                isSymbolicLink: a(()=>!1, "isSymbolicLink"),
                isBlockDevice: a(()=>!1, "isBlockDevice"),
                isCharacterDevice: a(()=>!1, "isCharacterDevice"),
                isSocket: a(()=>!1, "isSocket"),
                isFIFO: a(()=>!1, "isFIFO"),
                isFileSync: a(()=>!0, "isFileSync"),
                isDirectorySync: a(()=>!1, "isDirectorySync"),
                dev: 0,
                ino: 0,
                nlink: 1,
                uid: 0,
                gid: 0,
                rdev: 0,
                blksize: 4096,
                blocks: 0
            };
        } catch (e) {
            throw new Error("ENOENT: no such file or directory, stat operationHistory");
        }
    }, "getStats"),
    getFile: a(async (t)=>{
        let { gitRoot: e, nodeFs: r, pathParams: i } = t, n = await Bt(r, e, i.branchName), o, s = !1;
        return n ? (o = await it.default.resolveRef({
            fs: r,
            dir: e,
            ref: n
        }), s = !0) : o = await it.default.resolveRef({
            fs: r,
            dir: e,
            ref: "refs/heads/".concat(i.branchName)
        }), {
            type: "file",
            content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(o),
            mode: 420,
            size: o.length
        };
    }, "getFile"),
    writeFile: a(async (param)=>{
        let { filePath: t, gitRoot: e, nodeFs: r, content: i, cacheFs: n, pathParams: o } = param;
        if (o.branchName === void 0) throw new Error("branchName should be in pathParams");
        let s;
        typeof i == "string" ? s = new TextEncoder().encode(i) : s = new Uint8Array(i);
        let l = await it.default.writeBlob({
            fs: r,
            dir: e,
            blob: s
        }), f = await _r(r, e, o.branchName);
        if (!f) throw new Error("Invalid branch file path - branch doesn't exist");
        let c = await Bt(r, e, o.branchName), u = !1;
        c || (c = "legit/__" + o.branchName + tm, await it.default.branch({
            fs: r,
            dir: e,
            ref: c,
            object: f
        }), u = !0);
        let h = await it.default.resolveRef({
            fs: r,
            dir: e,
            ref: "refs/heads/".concat(c)
        }), d = await it.default.readTree({
            fs: r,
            dir: e,
            oid: f
        }), p;
        i instanceof ArrayBuffer ? p = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(i).toString("utf-8") : typeof i == "string" ? p = i : i instanceof Uint8Array ? p = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(i).toString("utf-8") : p = String(i);
        let m = !1;
        if (!u) {
            let w = await it.default.findMergeBase({
                fs: r,
                dir: e,
                oids: m ? [
                    h
                ] : [
                    h,
                    f
                ]
            });
            w.length === 1 && w[0] === f && (m = !0);
        }
        let y = await it.default.commit({
            fs: r,
            dir: e,
            message: p,
            tree: d.oid,
            noUpdateBranch: !0,
            parent: m ? u ? [
                f,
                f
            ] : [
                h
            ] : [
                h,
                f
            ],
            author: {
                name: "GitLegitFs",
                email: "gitlegit@example.com",
                timestamp: Math.floor(Date.now() / 1e3),
                timezoneOffset: 0
            }
        });
        await it.default.writeRef({
            fs: r,
            dir: e,
            ref: "refs/heads/".concat(c),
            value: y,
            force: !0
        });
    }, "writeFile"),
    rename: a(async function(param) {
        let { filePath: t, newPath: e, gitRoot: r, nodeFs: i, pathParams: n, newPathParams: o } = param;
        throw new Error("not implemented");
    }, "rename"),
    mkdir: a(async function(t) {
        throw new Error("not implemented");
    }, "mkdir")
};
var Ci = ae(ze(), 1);
var rm = {
    type: "gitBranchOperationsVirtualFile",
    getStats: a(async (t)=>{
        let { gitRoot: e, nodeFs: r, pathParams: i } = t;
        if (i.branchName === void 0) throw new Error("branchName should be in pathParams");
        let n = await Bt(r, e, i.branchName), o, s = !1;
        if (n) try {
            o = await Ci.default.resolveRef({
                fs: r,
                dir: e,
                ref: n
            }), s = !0;
        } catch (e1) {
            try {
                o = await Ci.default.resolveRef({
                    fs: r,
                    dir: e,
                    ref: "refs/heads/".concat(n)
                }), s = !0;
            } catch (e) {
                throw new Error("Base Branch ".concat(i.branchName, " for operations does not exis"));
            }
        }
        else try {
            o = await Ci.default.resolveRef({
                fs: r,
                dir: e,
                ref: "refs/heads/".concat(i.branchName)
            });
        } catch (e) {
            throw new Error("Base Branch ".concat(i.branchName, " for operations does not exis"));
        }
        let l = await Ci.default.readCommit({
            fs: r,
            dir: e,
            oid: o
        }), { commit: f } = l, c = f.committer.timestamp * 1e3;
        try {
            var _content, _this;
            var _content_length;
            return {
                mode: 420,
                size: (_content_length = (_this = s ? await rm.getFile(t) : void 0) === null || _this === void 0 ? void 0 : (_content = _this.content) === null || _content === void 0 ? void 0 : _content.length) !== null && _content_length !== void 0 ? _content_length : 0,
                atimeMs: c,
                mtimeMs: c,
                ctimeMs: c,
                birthtimeMs: c,
                atime: new Date(c),
                mtime: new Date(c),
                ctime: new Date(c),
                birthtime: new Date(c),
                isFile: a(()=>!0, "isFile"),
                isDirectory: a(()=>!1, "isDirectory"),
                isSymbolicLink: a(()=>!1, "isSymbolicLink"),
                isBlockDevice: a(()=>!1, "isBlockDevice"),
                isCharacterDevice: a(()=>!1, "isCharacterDevice"),
                isSocket: a(()=>!1, "isSocket"),
                isFIFO: a(()=>!1, "isFIFO"),
                isFileSync: a(()=>!0, "isFileSync"),
                isDirectorySync: a(()=>!1, "isDirectorySync"),
                dev: 0,
                ino: 0,
                nlink: 1,
                uid: 0,
                gid: 0,
                rdev: 0,
                blksize: 4096,
                blocks: 0
            };
        } catch (e) {
            throw new Error("ENOENT: no such file or directory, stat operationHistory");
        }
    }, "getStats"),
    getFile: a(async (t)=>{
        let { gitRoot: e, nodeFs: r, pathParams: i } = t, n = await Bt(r, e, i.branchName), o = [];
        if (n) {
            let l = await Ci.default.resolveRef({
                fs: r,
                dir: e,
                ref: "refs/heads/".concat(n)
            }), f = !1, c = l;
            for(; c && !f;){
                let u = await Ci.default.readCommit({
                    fs: r,
                    dir: e,
                    oid: c
                });
                o.push({
                    oid: u.oid,
                    parentOids: u.commit.parent,
                    message: u.commit.message
                }), c = u.commit.parent && u.commit.parent.length > 0 ? u.commit.parent[0] : null, u.commit.parent.length === 2 && u.commit.parent[0] === u.commit.parent[1] && (f = !0);
            }
        }
        let s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(JSON.stringify(o, null, 2), "utf-8");
        return {
            type: "file",
            content: s,
            mode: 420,
            size: s.length
        };
    }, "getFile"),
    rename: a(async function(t) {
        throw new Error("not implemented");
    }, "rename"),
    mkdir: a(async function(t) {
        throw new Error("not implemented");
    }, "mkdir")
};
var ro = ae(ze(), 1);
var V$ = new Set([
    " ",
    "~",
    "^",
    ":",
    "?",
    "*",
    "[",
    "\\"
]), G$ = [
    /^\/|\/$/,
    /\/\//,
    /\.$/,
    /\.lock$/,
    /^@$/,
    /@\{/
], k1 = "\u2002";
function R1(t) {
    let e = t.codePointAt(0);
    return !(e >= 0 && e <= 31 || e === 127 || V$.has(t));
}
_c194 = R1;
a(R1, "isValidChar");
function P1(t) {
    let e = "";
    for (let r of t)r === " " ? e += k1 : R1(r) ? e += r : e += "%" + r.codePointAt(0);
    for (let r of G$)if (r.test(e)) return Array.from(e).map((i)=>R1(i) ? i : "%" + i.codePointAt(0)).join("");
    return e;
}
_c195 = P1;
a(P1, "encodeName");
function A1(t) {
    return t.replace(/%(\d+)/g, (e, r)=>String.fromCodePoint(parseInt(r, 10))).replace(new RegExp(k1, "g"), " ");
}
_c196 = A1;
a(A1, "decodeName");
var I1 = {
    type: "getThreadName",
    getStats: a(async (t)=>{
        let { gitRoot: e, nodeFs: r, pathParams: i } = t, n;
        try {
            n = await ro.default.resolveRef({
                fs: r,
                dir: e,
                ref: "refs/heads/".concat(i.branchName)
            });
        } catch (e) {
            throw new Error("Base Branch ".concat(i.branchName, " for operations does not exis"));
        }
        let o = await Bt(r, e, i.branchName), s = !1;
        if (o) try {
            n = await ro.default.resolveRef({
                fs: r,
                dir: e,
                ref: o
            }), s = !0;
        } catch (e1) {
            try {
                n = await ro.default.resolveRef({
                    fs: r,
                    dir: e,
                    ref: "refs/heads/".concat(o)
                }), s = !0;
            } catch (e) {}
        }
        let l = await ro.default.readCommit({
            fs: r,
            dir: e,
            oid: n
        }), { commit: f } = l, c = f.committer.timestamp * 1e3;
        try {
            return {
                mode: 420,
                size: 40,
                atimeMs: c,
                mtimeMs: c,
                ctimeMs: c,
                birthtimeMs: c,
                atime: new Date(c),
                mtime: new Date(c),
                ctime: new Date(c),
                birthtime: new Date(c),
                isFile: a(()=>!0, "isFile"),
                isDirectory: a(()=>!1, "isDirectory"),
                isSymbolicLink: a(()=>!1, "isSymbolicLink"),
                isBlockDevice: a(()=>!1, "isBlockDevice"),
                isCharacterDevice: a(()=>!1, "isCharacterDevice"),
                isSocket: a(()=>!1, "isSocket"),
                isFIFO: a(()=>!1, "isFIFO"),
                isFileSync: a(()=>!0, "isFileSync"),
                isDirectorySync: a(()=>!1, "isDirectorySync"),
                dev: 0,
                ino: 0,
                nlink: 1,
                uid: 0,
                gid: 0,
                rdev: 0,
                blksize: 4096,
                blocks: 0
            };
        } catch (e) {
            throw new Error("ENOENT: no such file or directory, stat operationHistory");
        }
    }, "getStats"),
    getFile: a(async (t)=>{
        let { gitRoot: e, nodeFs: r, pathParams: i } = t, n = await Bt(r, e, i.branchName), o;
        if (n) {
            let s = "legit/", l = "__".concat(i.branchName, "-operation");
            return n.startsWith(s) && n.endsWith(l) ? o = n.slice(s.length, n.length - l.length) : o = n, {
                type: "file",
                content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(A1(o)),
                mode: 420,
                size: o.length
            };
        }
        return {
            type: "file",
            content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(""),
            mode: 420,
            size: 0
        };
    }, "getFile"),
    writeFile: a(async (param)=>{
        let { filePath: t, gitRoot: e, nodeFs: r, content: i, cacheFs: n, pathParams: o } = param;
        if (o.branchName === void 0) throw new Error("branchName should be in pathParams");
        let s = await Bt(r, e, o.branchName);
        if (s) {
            let l = "legit/".concat(P1(i.toString()), "__").concat(o.branchName, "-operation");
            await ro.default.renameBranch({
                fs: r,
                dir: e,
                oldref: s,
                ref: l
            }), s = l;
        }
    }, "writeFile"),
    rename: a(async function(param) {
        let { filePath: t, newPath: e, gitRoot: r, nodeFs: i, pathParams: n, newPathParams: o } = param;
        throw new Error("not implemented");
    }, "rename"),
    mkdir: a(async function(t) {
        throw new Error("not implemented");
    }, "mkdir")
};
var io = ae(ze(), 1);
var D1 = {
    type: "gitBranchHistory",
    getStats: a(async (param)=>{
        let { gitRoot: t, nodeFs: e, pathParams: r } = param;
        if (r.branchName === void 0) throw new Error("branchName should be in pathParams");
        let i;
        try {
            i = await io.default.resolveRef({
                fs: e,
                dir: t,
                ref: r.branchName
            });
        } catch (e1) {
            i = await io.default.resolveRef({
                fs: e,
                dir: t,
                ref: "refs/heads/".concat(r.branchName)
            });
        }
        let n = await io.default.readCommit({
            fs: e,
            dir: t,
            oid: i
        }), { commit: o } = n, s = o.committer.timestamp * 1e3;
        return {
            mode: 420,
            size: 1e4,
            isFile: a(()=>!0, "isFile"),
            isDirectory: a(()=>!1, "isDirectory"),
            isSymbolicLink: a(()=>!1, "isSymbolicLink"),
            isBlockDevice: a(()=>!1, "isBlockDevice"),
            isCharacterDevice: a(()=>!1, "isCharacterDevice"),
            isSocket: a(()=>!1, "isSocket"),
            isFIFO: a(()=>!1, "isFIFO"),
            isFileSync: a(()=>!0, "isFileSync"),
            isDirectorySync: a(()=>!1, "isDirectorySync"),
            dev: 0,
            ino: 0,
            nlink: 1,
            uid: 0,
            gid: 0,
            rdev: 0,
            blksize: 4096,
            blocks: Math.ceil(40 / 4096),
            atimeMs: s,
            mtimeMs: s,
            ctimeMs: s,
            birthtimeMs: s,
            atime: new Date(s),
            mtime: new Date(s),
            ctime: new Date(s),
            birthtime: new Date(s)
        };
    }, "getStats"),
    getFile: a(async (t)=>{
        let { gitRoot: e, nodeFs: r, pathParams: i } = t, n = i.branchName, o = [];
        if (n) {
            let l = await io.default.resolveRef({
                fs: r,
                dir: e,
                ref: "refs/heads/".concat(n)
            }), f = !1, c = l;
            for(; c && !f;){
                let u = await io.default.readCommit({
                    fs: r,
                    dir: e,
                    oid: c
                });
                o.push({
                    oid: u.oid,
                    ...u.commit
                }), c = u.commit.parent[0];
            }
        }
        let s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(JSON.stringify(o, null, 2), "utf-8");
        return {
            type: "file",
            content: s,
            mode: 420,
            size: s.length
        };
    }, "getFile"),
    rename: a(async (t)=>{
        throw new Error("not implemented");
    }, "rename"),
    mkdir: a(async function(t) {
        throw new Error("not implemented");
    }, "mkdir")
};
var Fr = class Fr extends bt {
    async responsible(r) {
        return this.isLegitPath(r);
    }
    isLegitPath(r) {
        return r.includes("/".concat(Fr.LEGIT_DIR, "/")) || r.includes("/".concat(Fr.LEGIT_DIR));
    }
    getRouteHandler(r) {
        let i = r.indexOf("/".concat(Fr.LEGIT_DIR));
        if (i === -1) throw new Error("Not a legit path");
        let n = r.slice(i + 1);
        return Fr.pathRouter.match(n);
    }
    async open(r, i, n) {
        let o = this.getRouteHandler(r);
        if (!o) throw new Error("Not a virtual legit file");
        if (!((o === null || o === void 0 ? void 0 : o.handler.writeFile) !== void 0) && (i.includes("w") || i.includes("a"))) throw new Error("Write operations not allowed for ".concat(o === null || o === void 0 ? void 0 : o.handler.type));
        if (i.includes("x") && (o === null || o === void 0 ? void 0 : o.handler.type) !== "gitBranchFileVirtualFile") throw new Error("Exclusive operations not allowed for ".concat(o === null || o === void 0 ? void 0 : o.handler.type));
        let l = await o.handler.getFile({
            cacheFs: this.memFs,
            filePath: r,
            fs: this.compositFs,
            gitRoot: this.gitRoot,
            nodeFs: this.compositFs,
            pathParams: o.params
        });
        if (i.includes("x")) {
            for (let d of Object.values(this.openFh))if (d.path === r) throw Object.assign(new Error("EEXIST: file already exists, open '".concat(r, "'")), {
                code: "EEXIST",
                errno: -17,
                syscall: "open",
                path: r
            });
            if (l !== void 0) throw Object.assign(new Error("EEXIST: file already exists, open '".concat(r, "'")), {
                code: "EEXIST",
                errno: -17,
                syscall: "open",
                path: r
            });
        }
        if (l && i.includes("x")) throw new Error("file existed - openend with x flag");
        if (!l && !(i.includes("w") || i.includes("a"))) throw new Error("ENOENT: no such file or directory, open '".concat(r, "'"));
        let f = im.dirname(r);
        if (await this.memFs.promises.mkdir(f, {
            recursive: !0
        }), l === void 0 && !i.includes("x") || l && l.type === "file") try {
            let d = await this.memFs.promises.access(r);
        } catch (e) {
            await this.memFs.promises.writeFile(r, "");
        }
        let c = await this.memFs.promises.open(r, i, n), u = c.fd, h = new Rt({
            fs: this,
            subFsFileDescriptor: u,
            parentFsFileDescriptors: []
        });
        return this.openFh[u] = {
            path: r,
            mode: i,
            fh: c,
            openSha: l === null || l === void 0 ? void 0 : l.oid,
            readSha: void 0,
            unflushed: []
        }, (i.includes("x") || i.includes("w")) && this.openFh[u].unflushed.push({
            length: 0,
            start: 0
        }), h;
    }
    async mkdir(r, i) {
        let n = r.toString(), o = this.getRouteHandler(n), s = i ? {
            options: i
        } : {};
        try {
            await (o === null || o === void 0 ? void 0 : o.handler.mkdir({
                cacheFs: this.memFs,
                filePath: r.toString(),
                fs: this.compositFs,
                nodeFs: this.compositFs,
                gitRoot: this.gitRoot,
                pathParams: o.params,
                ...s
            }));
            let l = typeof i == "object" ? {
                ...i,
                recursive: !0
            } : {
                recursive: !0
            };
            await this.memFs.promises.mkdir(r, l);
            let f = n.split("/"), c = "";
            for(let u = 1; u <= f.length; u++){
                c = "/" + f.slice(0, u).join("/");
                try {
                    if ((await this.memFs.promises.stat(c)).isDirectory()) {
                        let d = await this.memFs.promises.open(c, "r");
                        this.openFh[d.fd] = {
                            path: c,
                            mode: "r",
                            fh: d,
                            openSha: void 0,
                            readSha: void 0,
                            unflushed: []
                        };
                    }
                } catch (e) {}
            }
        } catch (l) {
            throw l;
        }
    }
    async access(r, i) {
        await this.stat(r);
    }
    async futimes(r, i, n) {
        let o = this.openFh[r.subFsFileDescriptor];
        if (!o) throw new Error("Invalid file handle");
        return await o.fh.utimes(i, n);
    }
    async fstat(r, i) {
        let n = this.openFh[r.subFsFileDescriptor];
        if (!n) throw new Error("Invalid file handle");
        return this.stat(n.path, i);
    }
    async ftruncate(r, i) {
        let n = this.openFh[r.subFsFileDescriptor];
        if (!n) throw new Error("Invalid file handle");
        return await n.fh.truncate(i);
    }
    async stat(r, i) {
        let n = r.toString(), o = Object.values(this.openFh).find((f)=>f.path === n);
        if (o && o.unflushed.length > 0) return await o.fh.stat(i);
        let s = this.getRouteHandler(n);
        if (!s) throw new Error("ENOENT: no such file or directory, stat '".concat(n, "'"));
        return await s.handler.getStats({
            cacheFs: this.memFs,
            filePath: n,
            fs: this.compositFs,
            gitRoot: this.gitRoot,
            nodeFs: this.compositFs,
            pathParams: s.params
        });
    }
    async lstat(r, i) {
        return this.stat(r, i);
    }
    async readdir(r, i) {
        let n = r.toString();
        if (!this.isLegitPath(n)) return [
            ".legit"
        ];
        let o = this.getRouteHandler(n);
        if (!o) throw new Error("ENOENT: no such file or directory, scandir '".concat(n, "'"));
        let s = await (o === null || o === void 0 ? void 0 : o.handler.getFile({
            cacheFs: this.memFs,
            filePath: n,
            fs: this.compositFs,
            gitRoot: this.gitRoot,
            nodeFs: this.compositFs,
            pathParams: o.params
        }));
        if (s) {
            if (s.type !== "directory") throw new Error("not a folder");
            var _o_staticSiblings;
            let l = (_o_staticSiblings = o === null || o === void 0 ? void 0 : o.staticSiblings) !== null && _o_staticSiblings !== void 0 ? _o_staticSiblings : [], f = s.content;
            return f && !Array.isArray(s.content) && (f = JSON.parse(s.content)), Array.from(new Set([
                ...f,
                ...l
            ])).sort((u, h)=>u.localeCompare(h, void 0, {
                    numeric: !0,
                    sensitivity: "base"
                }));
        }
        return [];
    }
    async read(r, i, n, o, s) {
        let l = r.subFsFileDescriptor, f = this.openFh[l];
        if (!f) throw new Error("Invalid file handle");
        if (f.unflushed.length === 0) {
            let c = this.getRouteHandler(f.path), u = await c.handler.getFile({
                cacheFs: this.memFs,
                filePath: f.path,
                fs: this.compositFs,
                gitRoot: this.gitRoot,
                nodeFs: this.compositFs,
                pathParams: c === null || c === void 0 ? void 0 : c.params
            });
            if (!(u === null || u === void 0 ? void 0 : u.content)) throw new Error("couldnt access content");
            if (u.type !== "file") throw new Error("not a file");
            let h = typeof u.content == "string" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(u.content) : u.content, d = typeof s == "number" ? s : 0, p = Math.min(d + o, h.length), m = Math.max(0, p - d);
            return h.copy(i, n, d, d + m), {
                bytesRead: m,
                buffer: i
            };
        }
        return await f.fh.read(i, n, o, s);
    }
    async write(r, i, n, o, s) {
        let l = this.openFh[r.subFsFileDescriptor];
        if (!l) throw new Error("Invalid file handle");
        let f = l.mode;
        if (!f.includes("w") && !f.includes("a") && !f.includes("+")) throw Object.assign(new Error("EBADF: bad file descriptor, write"), {
            code: "EBADF",
            errno: -9,
            syscall: "write"
        });
        if (l.unflushed.length === 0) {
            let d = this.getRouteHandler(l.path), p = await d.handler.getFile({
                cacheFs: this.memFs,
                filePath: l.path,
                fs: this.compositFs,
                gitRoot: this.gitRoot,
                nodeFs: this.compositFs,
                pathParams: d.params
            });
            p && p.oid && (await this.memFs.promises.writeFile(l.path, p.content), l.readSha = p.oid);
        }
        let c = await l.fh.write(i, n, o, s), u = n !== null && n !== void 0 ? n : 0, h = s !== null && s !== void 0 ? s : 0;
        return l.unflushed.push({
            start: h,
            length: o || i.byteLength - u + h
        }), c;
    }
    async close(r) {
        let i = r.subFsFileDescriptor;
        if (!this.openFh[i]) throw new Error("Invalid file handle");
        await this.dataSync(r), delete this.openFh[i];
    }
    async dataSync(r) {
        let i = r.subFsFileDescriptor, n = this.openFh[i];
        if (!n) throw new Error("Invalid file handle");
        if (n.unflushed.length > 0) {
            let o = this.getRouteHandler(n.path);
            if (o && o.handler.writeFile) {
                let s = await this.memFs.promises.readFile(n.path);
                await o.handler.writeFile({
                    cacheFs: this.memFs,
                    filePath: n.path,
                    fs: this.compositFs,
                    gitRoot: this.gitRoot,
                    nodeFs: this.compositFs,
                    content: s,
                    pathParams: o.params
                });
            }
            n.unflushed = [], await this.memFs.promises.writeFile(n.path, "");
        }
    }
    async readFile(r, i) {
        let n = typeof r == "string" ? r : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(r) ? r.toString() : r.fd ? "FileHandle(".concat(r.fd, ")") : r.toString(), o = null;
        typeof i == "string" ? o = i : i && typeof i == "object" && i.encoding && (o = i.encoding);
        let s = await this.open(n, "r");
        try {
            let f = (await this.fstat(s)).size, c = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(f);
            return await this.read(s, c, 0, f, 0), await this.close(s), o ? c.toString(o) : c;
        } catch (l) {
            try {
                await this.close(s);
            } catch (e) {}
            throw l;
        }
    }
    async writeFile(r, i, n) {
        let o = "w", s = "utf8", l;
        typeof n == "string" ? s = n : n && typeof n == "object" && (n.flag && (o = String(n.flag)), n.encoding && (s = n.encoding), n.mode && (l = typeof n.mode == "string" ? parseInt(n.mode, 8) : n.mode));
        let f = await this.open(r, o, l);
        try {
            let c;
            typeof i == "string" ? c = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(i, s) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(i) ? c = i : i instanceof Uint8Array ? c = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(i) : ArrayBuffer.isView(i) ? c = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(i.buffer, i.byteOffset, i.byteLength) : c = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(i), await this.write(f, c, 0, c.length, 0);
        } finally{
            await this.close(f);
        }
    }
    async rename(r, i) {
        let n = r.toString(), o = i.toString(), s = this.getRouteHandler(n), l = this.getRouteHandler(o);
        if ((s === null || s === void 0 ? void 0 : s.handler.type) === "gitBranchFileVirtualFile" && (l === null || l === void 0 ? void 0 : l.handler.type) === "gitBranchFileVirtualFile") {
            let f = !0;
            try {
                await this.memFs.promises.access(o);
            } catch (e) {
                f = !1;
            }
            let c = !0;
            try {
                await this.stat(o);
            } catch (e) {
                c = !1;
            }
            let u = !0;
            try {
                await this.stat(n);
            } catch (e) {
                u = !1;
            }
            let h = !0;
            try {
                await this.memFs.promises.access(n);
            } catch (e) {
                h = !1;
            }
            if (h) {
                let m = im.dirname(o);
                try {
                    await this.memFs.promises.access(m);
                } catch (e) {
                    await this.memFs.promises.mkdir(m, {
                        recursive: !0
                    });
                }
                await this.memFs.promises.rename(r, i);
            }
            let d = this.getRouteHandler(n);
            if (!d) throw new Error("VF not found");
            var _d_params, _l_params;
            let p = await d.handler.rename({
                cacheFs: this.memFs,
                filePath: n,
                fs: this.compositFs,
                gitRoot: this.gitRoot,
                nodeFs: this.compositFs,
                newPath: o,
                pathParams: (_d_params = d === null || d === void 0 ? void 0 : d.params) !== null && _d_params !== void 0 ? _d_params : {},
                newPathParams: (_l_params = l === null || l === void 0 ? void 0 : l.params) !== null && _l_params !== void 0 ? _l_params : {}
            });
        } else throw new Error("Unsupported rename operation from ".concat(s === null || s === void 0 ? void 0 : s.handler.type, " to ").concat(l === null || l === void 0 ? void 0 : l.handler.type));
    }
    async fchmod(r, i) {}
    async unlink(r) {
        let i = r.toString(), n = this.getRouteHandler(i);
        if ((n === null || n === void 0 ? void 0 : n.handler.unlink) !== void 0) {
            await n.handler.unlink({
                cacheFs: this.memFs,
                filePath: i,
                fs: this.compositFs,
                nodeFs: this.compositFs,
                gitRoot: this.gitRoot,
                pathParams: n.params
            });
            for (let [o, s] of Object.entries(this.openFh))s.path === i && (await s.fh.close(), await this.memFs.promises.unlink(i), delete this.openFh[Number(o)]);
        } else throw new Error("Cannot unlink ".concat(n === null || n === void 0 ? void 0 : n.handler.type, " files"));
    }
    fileType() {
        return 10;
    }
    constructor({ parentFs: r, gitRoot: i, virtualFiles: n = x1 }){
        super({
            parentFs: r,
            gitRoot: i
        });
        q(this, "memFs");
        q(this, "openFh", {});
        q(this, "virtualFiles");
        q(this, "legitFileNames");
        this.gitRoot = i, this.memFs = (0, df.createFsFromVolume)(new df.Volume), this.virtualFiles = n, this.legitFileNames = [
            "branches",
            "commits"
        ];
    }
};
a(Fr, "GitSubFs"), q(Fr, "LEGIT_DIR", ".legit"), q(Fr, "pathRouter", new ff({
    ".legit": {
        ".": Ns,
        branches: {
            ".": nf,
            "[branchName]": {
                ".legit": {
                    ".": Ns,
                    operation: O1,
                    head: sf,
                    operationHistory: rm,
                    threadName: I1,
                    history: D1
                },
                "[[...filePath]]": eo
            }
        },
        commits: {
            ".": em,
            "[sha_1_1_2]": {
                ".": em,
                "[sha1_3__40]": {
                    "[[...filePath]]": lf
                }
            }
        }
    }
}));
var hf = Fr;
var pf = ae(ze(), 1);
async function $H(t, e) {
    let r = !1;
    try {
        await t.promises.readdir(e + "/.git"), r = !0;
    } catch (e) {}
    if (r) throw new Error("cant use initLegitFs on a folder with a git repo (".concat(e, "), use openLegitFs instead"));
    return await pf.default.init({
        fs: t,
        dir: "/",
        defaultBranch: "main"
    }), await t.promises.writeFile(e + "/.keep", ""), await pf.default.add({
        fs: t,
        dir: "/",
        filepath: ".keep"
    }), await pf.default.commit({
        fs: t,
        dir: "/",
        message: "Initial commit",
        author: {
            name: "Test",
            email: "test@example.com"
        }
    }), K$(t, e);
}
a($H, "initLegitFs");
function K$(t, e) {
    let r = new Ho({
        name: "root",
        parentFs: void 0,
        storageFs: t,
        gitRoot: e
    }), i = new Vo({
        parentFs: r,
        gitRoot: e,
        ephemeralPatterns: []
    }), n = new Wo({
        parentFs: r,
        gitRoot: e,
        hiddenFiles: []
    });
    r.setHiddenFilesSubFs(n), r.setEphemeralFilesSubFs(i);
    let o = new Ho({
        name: "git",
        parentFs: r,
        storageFs: void 0,
        gitRoot: e
    }), s = new hf({
        parentFs: r,
        gitRoot: e
    }), l = new Wo({
        parentFs: o,
        gitRoot: e,
        hiddenFiles: [
            ".git"
        ]
    }), f = new Vo({
        parentFs: o,
        gitRoot: e,
        ephemeralPatterns: [
            "**/._*",
            "**/.DS_Store",
            "**/.AppleDouble/",
            "**/.AppleDB",
            "**/.AppleDesktop",
            "**/.Spotlight-V100",
            "**/.TemporaryItems",
            "**/.Trashes",
            "**/.fseventsd",
            "**/.VolumeIcon.icns",
            "**/.ql_disablethumbnails",
            "**/.~lock.*",
            "**/lu[0-9a-zA-Z]*.tmp",
            "**/.metaentries.json.tmp"
        ]
    });
    return o.addSubFs(s), o.setHiddenFilesSubFs(l), o.setEphemeralFilesSubFs(f), o;
}
_c197 = K$;
a(K$, "openLegitFs");
var Tt = ae(ze(), 1);
var mx = ae(px(), 1);
function wM(t) {
    let e = [
        t
    ];
    return {
        next () {
            return Promise.resolve({
                done: e.length === 0,
                value: e.pop()
            });
        },
        return () {
            return e = [], {};
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    };
}
a(wM, "fromValue");
function gM(t) {
    return t[Symbol.asyncIterator] ? t[Symbol.asyncIterator]() : t[Symbol.iterator] ? t[Symbol.iterator]() : t.next ? t : wM(t);
}
a(gM, "getIterator");
async function yx(t, e) {
    let r = gM(t);
    for(;;){
        let { value: i, done: n } = await r.next();
        if (i && await e(i), n) break;
    }
    r.return && r.return();
}
a(yx, "forAwait");
function bM(t) {
    let { PassThrough: e } = mf(), r = new e;
    return setTimeout(async ()=>{
        await yx(t, (i)=>r.write(i)), r.end();
    }, 1), r;
}
a(bM, "asyncIteratorToStream");
async function vM(t) {
    let e = 0, r = [];
    await yx(t, (o)=>{
        r.push(o), e += o.byteLength;
    });
    let i = new Uint8Array(e), n = 0;
    for (let o of r)i.set(o, n), n += o.byteLength;
    return i;
}
a(vM, "collect");
function _M(t) {
    let e = Object.getOwnPropertyDescriptor(t, Symbol.asyncIterator);
    if (e && e.enumerable) return t;
    let r = !1, i = [], n = {};
    return t.on("data", (o)=>{
        i.push(o), n.resolve && (n.resolve({
            value: i.shift(),
            done: !1
        }), n = {});
    }), t.on("error", (o)=>{
        n.reject && (n.reject(o), n = {});
    }), t.on("end", ()=>{
        r = !0, n.resolve && (n.resolve({
            done: !0
        }), n = {});
    }), {
        next () {
            return new Promise((o, s)=>{
                if (i.length === 0 && r) return o({
                    done: !0
                });
                if (i.length > 0) return o({
                    value: i.shift(),
                    done: !1
                });
                i.length === 0 && !r && (n = {
                    resolve: o,
                    reject: s
                });
            });
        },
        return () {
            t.removeAllListeners(), t.destroy && t.destroy();
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    };
}
a(_M, "fromNodeStream");
async function FM(param) {
    let { onProgress: t, url: e, method: r = "GET", headers: i = {}, agent: n, body: o } = param;
    return o && Array.isArray(o) ? o = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(await vM(o)) : o && (o = bM(o)), new Promise((s, l)=>{
        (0, mx.default)({
            url: e,
            method: r,
            headers: i,
            agent: n,
            body: o
        }, (f, c)=>{
            if (f) return l(f);
            try {
                let u = _M(c);
                s({
                    url: c.url,
                    method: c.method,
                    statusCode: c.statusCode,
                    statusMessage: c.statusMessage,
                    body: u,
                    headers: c.headers
                });
            } catch (u) {
                l(u);
            }
        });
    });
}
_c198 = FM;
a(FM, "request");
var EM = {
    request: FM
}, bf = EM;
function SM(t) {
    let e = /^git@([^:]+):(.+)$/, r = t.match(e);
    if (r) {
        let i = r[1], n = r[2];
        return "https://".concat(i, "/").concat(n);
    }
    return t;
}
_c199 = SM;
a(SM, "normalizeRemoteUrl");
var g3 = a((param)=>{
    let { fs: t, gitRepoPath: e, originPrefix: r, corsProxy: i, user: n, password: o } = param;
    let s = !1, l, f;
    async function c() {
        let m = await Tt.default.fetch({
            fs: t,
            http: bf,
            dir: e,
            url: f,
            corsProxy: i,
            onAuth: a(()=>({
                    username: n,
                    password: o
                }), "onAuth")
        }), y = "origin", w = await Tt.default.listBranches({
            fs: t,
            dir: e
        }), v = [];
        for (let g of w){
            let F = "".concat(y, "/").concat(g), O, S;
            try {
                O = await Tt.default.resolveRef({
                    fs: t,
                    dir: e,
                    ref: g
                });
            } catch (R) {
                console.log("Could not resolve local ref ".concat(g, ":"), R);
            }
            try {
                S = await Tt.default.resolveRef({
                    fs: t,
                    dir: e,
                    ref: F
                });
            } catch (e) {
                S = void 0;
            }
            if (O && S && O !== S) {
                let R = await Tt.default.findMergeBase({
                    fs: t,
                    dir: e,
                    oids: [
                        O,
                        S
                    ]
                });
                if (R[0] !== O && R[0] !== S) {
                    let b = await Tt.default.merge({
                        fs: t,
                        dir: e,
                        ours: O,
                        theirs: S,
                        fastForwardOnly: !1,
                        abortOnConflict: !1,
                        author: {
                            name: "Your Name",
                            email: "your.email@example.com"
                        },
                        mergeDriver: a(async (param)=>{
                            let { branches: x, contents: _, path: P } = param;
                            let [k, C, N] = _;
                            return console.log("Merging ".concat(x[0], " with ").concat(x[1], "...")), console.log("merged:"), console.log(_), {
                                cleanMerge: !0,
                                mergedText: N === void 0 ? C : N
                            };
                        }, "mergeDriver")
                    });
                    await Tt.default.writeRef({
                        fs: t,
                        dir: e,
                        ref: "refs/heads/".concat(g),
                        value: b.oid,
                        force: !0
                    });
                }
                R[0] === O ? (console.log("branch ".concat(g, " differs - remote ahaed, not behind")), await Tt.default.writeRef({
                    fs: t,
                    dir: e,
                    ref: "refs/heads/".concat(g),
                    value: S,
                    force: !0
                })) : R[0] === S ? (console.log("branch ".concat(g, " differs - local ahead, not behind")), v.push(g)) : (console.log("branch ".concat(g, " differs - both changed")), v.push(g));
            }
        }
        v.length !== 0 && await u(v);
    }
    a(c, "pull");
    async function u(m) {
        for (let y of m)await Tt.default.push({
            fs: t,
            http: bf,
            dir: e,
            corsProxy: i,
            url: f,
            ref: y,
            onAuth: a(()=>({
                    username: n,
                    password: o
                }), "onAuth")
        });
    }
    a(u, "push");
    async function h() {
        let m = await Tt.default.getConfig({
            fs: t,
            dir: e,
            path: "remote.origin.url"
        });
        f = SM(m);
        try {
            await c();
        } catch (y) {
            console.error("Error monitoring changes:", y);
        } finally{
            s && setTimeout(h, 1e3);
        }
    }
    a(h, "monitorChanges");
    function d() {
        s = !0, h();
    }
    a(d, "startPolling");
    function p() {
        s = !1;
    }
    return a(p, "stopPolling"), {
        clone: a(async (m)=>Tt.default.clone({
                fs: t,
                http: bf,
                corsProxy: i,
                dir: e,
                url: m,
                onAuth: a(()=>({
                        username: n,
                        password: o
                    }), "onAuth")
            }), "clone"),
        start: a(()=>{
            s || (d(), s = !0);
        }, "start"),
        stop: a(()=>{
            p();
        }, "stop")
    };
}, "createGitSyncService");
var mm = ae(ri(), 1);
function wx(t) {
    let e = t.name || "untitled";
    return {
        kind: "file",
        name: e,
        async getFile () {
            let i = (await t.stat()).size;
            console.log("reading data into buffer of size" + i);
            let n = mm.Buffer.alloc(i);
            await t.read(n, 0, i, 0);
            let o = new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
            console.log("buffer read", o);
            let s = o;
            return new File([
                s
            ], e || "untitled");
        },
        async createWritable () {
            return {
                async write (r) {
                    console.log("writing data to handle", t);
                    let i;
                    if (typeof r == "string") i = mm.Buffer.from(r, "utf-8");
                    else if (r instanceof Blob) {
                        let n = await r.arrayBuffer();
                        i = new Uint8Array(n);
                    } else if (ArrayBuffer.isView(r)) i = new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
                    else throw console.log("data", r), new Error("Unsupported data type for write");
                    await t.write(i), await t.sync(), console.log("write completed");
                },
                async close () {
                    await t.close();
                }
            };
        }
    };
}
a(wx, "fileHandleToFileSystemFileHandle");
async function xM(t) {
    let e = await t.getFile();
    return e.handle = t, e;
}
a(xM, "fileSystemFileHandleToFileWithHandle");
async function _3(t) {
    return {
        openFile: a(async (e)=>{
            let r = await t.promises.open(e, "w");
            return r.name = e, await xM(wx(r));
        }, "openFile"),
        fileSave: a(async (e, r, i, n, o)=>{
            if (i) console.log("using existing handle", i);
            else {
                var _r_fileName;
                let f = window.prompt("Save as", (_r_fileName = r === null || r === void 0 ? void 0 : r.fileName) !== null && _r_fileName !== void 0 ? _r_fileName : "untitled");
                if (console.log("result of prompt", f), !f) throw new Error("no file choosen");
                try {
                    let c = await t.promises.open("".concat(f), "w");
                    i = wx(c);
                } catch (c) {
                    throw console.error("Failed to open file in legitFs", c), new Error("Failed to open file in legitFs");
                }
            }
            let s = e instanceof Blob ? e : await e;
            return await (await i.createWritable()).write(s), i;
        }, "fileSave")
    };
}
a(_3, "getLegitFsAccess");
;
var _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13, _c14, _c15, _c16, _c17, _c18, _c19, _c20, _c21, _c22, _c23, _c24, _c25, _c26, _c27, _c28, _c29, _c30, _c31, _c32, _c33, _c34, _c35, _c36, _c37, _c38, _c39, _c40, _c41, _c42, _c43, _c44, _c45, _c46, _c47, _c48, _c49, _c50, _c51, _c52, _c53, _c54, _c55, _c56, _c57, _c58, _c59, _c60, _c61, _c62, _c63, _c64, _c65, _c66, _c67, _c68, _c69, _c70, _c71, _c72, _c73, _c74, _c75, _c76, _c77, _c78, _c79, _c80, _c81, _c82, _c83, _c84, _c85, _c86, _c87, _c88, _c89, _c90, _c91, _c92, _c93, _c94, _c95, _c96, _c97, _c98, _c99, _c100, _c101, _c102, _c103, _c104, _c105, _c106, _c107, _c108, _c109, _c110, _c111, _c112, _c113, _c114, _c115, _c116, _c117, _c118, _c119, _c120, _c121, _c122, _c123, _c124, _c125, _c126, _c127, _c128, _c129, _c130, _c131, _c132, _c133, _c134, _c135, _c136, _c137, _c138, _c139, _c140, _c141, _c142, _c143, _c144, _c145, _c146, _c147, _c148, _c149, _c150, _c151, _c152, _c153, _c154, _c155, _c156, _c157, _c158, _c159, _c160, _c161, _c162, _c163, _c164, _c165, _c166, _c167, _c168, _c169, _c170, _c171, _c172, _c173, _c174, _c175, _c176, _c177, _c178, _c179, _c180, _c181, _c182, _c183, _c184, _c185, _c186, _c187, _c188, _c189, _c190, _c191, _c192, _c193, _c194, _c195, _c196, _c197, _c198, _c199;
__turbopack_context__.k.register(_c, "Ex");
__turbopack_context__.k.register(_c1, "Er$T");
__turbopack_context__.k.register(_c2, "Er");
__turbopack_context__.k.register(_c3, "Sf$T");
__turbopack_context__.k.register(_c4, "Sf");
__turbopack_context__.k.register(_c5, "Fm$T");
__turbopack_context__.k.register(_c6, "Fm");
__turbopack_context__.k.register(_c7, "Em$T");
__turbopack_context__.k.register(_c8, "Em");
__turbopack_context__.k.register(_c9, "Tr$T");
__turbopack_context__.k.register(_c10, "Tr");
__turbopack_context__.k.register(_c11, "Bf$T");
__turbopack_context__.k.register(_c12, "Bf");
__turbopack_context__.k.register(_c13, "Xs$T");
__turbopack_context__.k.register(_c14, "Xs");
__turbopack_context__.k.register(_c15, "Wi$T");
__turbopack_context__.k.register(_c16, "Wi");
__turbopack_context__.k.register(_c17, "Wm");
__turbopack_context__.k.register(_c18, "Vm");
__turbopack_context__.k.register(_c19, "Gm");
__turbopack_context__.k.register(_c20, "Km");
__turbopack_context__.k.register(_c21, "Zm");
__turbopack_context__.k.register(_c22, "Xm");
__turbopack_context__.k.register(_c23, "Ym");
__turbopack_context__.k.register(_c24, "Jm");
__turbopack_context__.k.register(_c25, "Qm");
__turbopack_context__.k.register(_c26, "Js");
__turbopack_context__.k.register(_c27, "Vi");
__turbopack_context__.k.register(_c28, "Kf$T");
__turbopack_context__.k.register(_c29, "Kf");
__turbopack_context__.k.register(_c30, "Yf$T");
__turbopack_context__.k.register(_c31, "Yf");
__turbopack_context__.k.register(_c32, "Zi$T");
__turbopack_context__.k.register(_c33, "Zi");
__turbopack_context__.k.register(_c34, "Ay$T");
__turbopack_context__.k.register(_c35, "Ay");
__turbopack_context__.k.register(_c36, "Qy$T");
__turbopack_context__.k.register(_c37, "Qy");
__turbopack_context__.k.register(_c38, "Ew$T");
__turbopack_context__.k.register(_c39, "Ew");
__turbopack_context__.k.register(_c40, "Ow$T");
__turbopack_context__.k.register(_c41, "Ow");
__turbopack_context__.k.register(_c42, "Qi$T");
__turbopack_context__.k.register(_c43, "Qi");
__turbopack_context__.k.register(_c44, "Fu$T");
__turbopack_context__.k.register(_c45, "Fu");
__turbopack_context__.k.register(_c46, "Nw$T");
__turbopack_context__.k.register(_c47, "Nw");
__turbopack_context__.k.register(_c48, "Eu$T");
__turbopack_context__.k.register(_c49, "Eu");
__turbopack_context__.k.register(_c50, "Su$T");
__turbopack_context__.k.register(_c51, "Su");
__turbopack_context__.k.register(_c52, "Ea$T");
__turbopack_context__.k.register(_c53, "Ea");
__turbopack_context__.k.register(_c54, "Sa$T");
__turbopack_context__.k.register(_c55, "Sa");
__turbopack_context__.k.register(_c56, "Ww$T");
__turbopack_context__.k.register(_c57, "Ww");
__turbopack_context__.k.register(_c58, "Qw$T");
__turbopack_context__.k.register(_c59, "Qw");
__turbopack_context__.k.register(_c60, "Ou$T");
__turbopack_context__.k.register(_c61, "Ou");
__turbopack_context__.k.register(_c62, "Fo$T");
__turbopack_context__.k.register(_c63, "Fo");
__turbopack_context__.k.register(_c64, "Eo$T");
__turbopack_context__.k.register(_c65, "Eo");
__turbopack_context__.k.register(_c66, "Pu$T");
__turbopack_context__.k.register(_c67, "Pu");
__turbopack_context__.k.register(_c68, "Pa$T");
__turbopack_context__.k.register(_c69, "Pa");
__turbopack_context__.k.register(_c70, "Cu$T");
__turbopack_context__.k.register(_c71, "Cu");
__turbopack_context__.k.register(_c72, "D0$T");
__turbopack_context__.k.register(_c73, "D0");
__turbopack_context__.k.register(_c74, "N0$T");
__turbopack_context__.k.register(_c75, "N0");
__turbopack_context__.k.register(_c76, "Oo$T");
__turbopack_context__.k.register(_c77, "Oo");
__turbopack_context__.k.register(_c78, "Ar$T");
__turbopack_context__.k.register(_c79, "Ar");
__turbopack_context__.k.register(_c80, "G0$T");
__turbopack_context__.k.register(_c81, "G0");
__turbopack_context__.k.register(_c82, "Z0$T");
__turbopack_context__.k.register(_c83, "Z0");
__turbopack_context__.k.register(_c84, "X0$T");
__turbopack_context__.k.register(_c85, "X0");
__turbopack_context__.k.register(_c86, "Y0$T");
__turbopack_context__.k.register(_c87, "Y0");
__turbopack_context__.k.register(_c88, "Po$T");
__turbopack_context__.k.register(_c89, "Po");
__turbopack_context__.k.register(_c90, "Gt$T");
__turbopack_context__.k.register(_c91, "Gt");
__turbopack_context__.k.register(_c92, "Gu$T");
__turbopack_context__.k.register(_c93, "Gu");
__turbopack_context__.k.register(_c94, "Ku$T");
__turbopack_context__.k.register(_c95, "Ku");
__turbopack_context__.k.register(_c96, "Yu$T");
__turbopack_context__.k.register(_c97, "Yu");
__turbopack_context__.k.register(_c98, "Ju$T");
__turbopack_context__.k.register(_c99, "Ju");
__turbopack_context__.k.register(_c100, "Fg$T");
__turbopack_context__.k.register(_c101, "Fg");
__turbopack_context__.k.register(_c102, "Dr$T");
__turbopack_context__.k.register(_c103, "Dr");
__turbopack_context__.k.register(_c104, "Do$T");
__turbopack_context__.k.register(_c105, "Do");
__turbopack_context__.k.register(_c106, "No$T");
__turbopack_context__.k.register(_c107, "No");
__turbopack_context__.k.register(_c108, "Mg$T");
__turbopack_context__.k.register(_c109, "Mg");
__turbopack_context__.k.register(_c110, "Ug$T");
__turbopack_context__.k.register(_c111, "Ug");
__turbopack_context__.k.register(_c112, "Ga$T");
__turbopack_context__.k.register(_c113, "Ga");
__turbopack_context__.k.register(_c114, "Fh$T");
__turbopack_context__.k.register(_c115, "Fh");
__turbopack_context__.k.register(_c116, "Fb$T");
__turbopack_context__.k.register(_c117, "Fb");
__turbopack_context__.k.register(_c118, "Eb$T");
__turbopack_context__.k.register(_c119, "Eb");
__turbopack_context__.k.register(_c120, "Tb$T");
__turbopack_context__.k.register(_c121, "Tb");
__turbopack_context__.k.register(_c122, "Db$T");
__turbopack_context__.k.register(_c123, "Db");
__turbopack_context__.k.register(_c124, "Cb$T");
__turbopack_context__.k.register(_c125, "Cb");
__turbopack_context__.k.register(_c126, "Nb$T");
__turbopack_context__.k.register(_c127, "Nb");
__turbopack_context__.k.register(_c128, "Xb$T");
__turbopack_context__.k.register(_c129, "Xb");
__turbopack_context__.k.register(_c130, "Jb$T");
__turbopack_context__.k.register(_c131, "Jb");
__turbopack_context__.k.register(_c132, "Ev$T");
__turbopack_context__.k.register(_c133, "Ev");
__turbopack_context__.k.register(_c134, "Rv$T");
__turbopack_context__.k.register(_c135, "Rv");
__turbopack_context__.k.register(_c136, "Pv$T");
__turbopack_context__.k.register(_c137, "Pv");
__turbopack_context__.k.register(_c138, "Nv$T");
__turbopack_context__.k.register(_c139, "Nv");
__turbopack_context__.k.register(_c140, "Lv$T");
__turbopack_context__.k.register(_c141, "Lv");
__turbopack_context__.k.register(_c142, "Mv$T");
__turbopack_context__.k.register(_c143, "Mv");
__turbopack_context__.k.register(_c144, "Gv$T");
__turbopack_context__.k.register(_c145, "Gv");
__turbopack_context__.k.register(_c146, "Zv$T");
__turbopack_context__.k.register(_c147, "Zv");
__turbopack_context__.k.register(_c148, "Td$T");
__turbopack_context__.k.register(_c149, "Td");
__turbopack_context__.k.register(_c150, "Od$T");
__turbopack_context__.k.register(_c151, "Od");
__turbopack_context__.k.register(_c152, "P_$T");
__turbopack_context__.k.register(_c153, "P_");
__turbopack_context__.k.register(_c154, "Id$T");
__turbopack_context__.k.register(_c155, "Id");
__turbopack_context__.k.register(_c156, "Dd$T");
__turbopack_context__.k.register(_c157, "Dd");
__turbopack_context__.k.register(_c158, "G_$T");
__turbopack_context__.k.register(_c159, "G_");
__turbopack_context__.k.register(_c160, "RF$T");
__turbopack_context__.k.register(_c161, "RF");
__turbopack_context__.k.register(_c162, "Gd$T");
__turbopack_context__.k.register(_c163, "Gd");
__turbopack_context__.k.register(_c164, "AF$T");
__turbopack_context__.k.register(_c165, "AF");
__turbopack_context__.k.register(_c166, "DF$T");
__turbopack_context__.k.register(_c167, "DF");
__turbopack_context__.k.register(_c168, "BF$T");
__turbopack_context__.k.register(_c169, "BF");
__turbopack_context__.k.register(_c170, "MF$T");
__turbopack_context__.k.register(_c171, "MF");
__turbopack_context__.k.register(_c172, "KF$T");
__turbopack_context__.k.register(_c173, "KF");
__turbopack_context__.k.register(_c174, "XF$T");
__turbopack_context__.k.register(_c175, "XF");
__turbopack_context__.k.register(_c176, "JF$T");
__turbopack_context__.k.register(_c177, "JF");
__turbopack_context__.k.register(_c178, "N1$T");
__turbopack_context__.k.register(_c179, "N1");
__turbopack_context__.k.register(_c180, "B1$T");
__turbopack_context__.k.register(_c181, "B1");
__turbopack_context__.k.register(_c182, "H1$T");
__turbopack_context__.k.register(_c183, "H1");
__turbopack_context__.k.register(_c184, "W1$T");
__turbopack_context__.k.register(_c185, "W1");
__turbopack_context__.k.register(_c186, "G1$T");
__turbopack_context__.k.register(_c187, "G1");
__turbopack_context__.k.register(_c188, "J1$T");
__turbopack_context__.k.register(_c189, "J1");
__turbopack_context__.k.register(_c190, "Qn");
__turbopack_context__.k.register(_c191, "Ii");
__turbopack_context__.k.register(_c192, "W$");
__turbopack_context__.k.register(_c193, "Bt");
__turbopack_context__.k.register(_c194, "R1");
__turbopack_context__.k.register(_c195, "P1");
__turbopack_context__.k.register(_c196, "A1");
__turbopack_context__.k.register(_c197, "K$");
__turbopack_context__.k.register(_c198, "FM");
__turbopack_context__.k.register(_c199, "SM");
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
 /*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

punycode/punycode.js:
  (*! https://mths.be/punycode v1.4.1 by @mathias *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

crc-32/crc32.js:
  (*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com *)

simple-concat/index.js:
  (*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

simple-get/index.js:
  (*! simple-get. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/ }),
"[project]/examples/ai-form-example/lib/legit/fs.ts [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getClientLegitFs",
    ()=>getClientLegitFs,
    "resetClientLegitFs",
    ()=>resetClientLegitFs
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$memfs$40$4$2e$49$2e$0$2f$node_modules$2f$memfs$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$sdk$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/packages/sdk/dist/index.js [app-client] (ecmascript)");
'use client';
;
;
const globalLegit = globalThis;
async function createLegitFsContext() {
    const volume = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$memfs$40$4$2e$49$2e$0$2f$node_modules$2f$memfs$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Volume"]();
    const storageFs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$memfs$40$4$2e$49$2e$0$2f$node_modules$2f$memfs$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createFsFromVolume"])(volume);
    const legitFs = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$sdk$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initLegitFs"])(storageFs, '/');
    return {
        volume,
        storageFs,
        legitFs
    };
}
function resetClientLegitFs() {
    delete globalLegit.__legitClientFs;
}
function getClientLegitFs() {
    if (!globalLegit.__legitClientFs) {
        globalLegit.__legitClientFs = createLegitFsContext();
    }
    return globalLegit.__legitClientFs;
}
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/examples/ai-form-example/lib/legit/history.ts [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "computeChanges",
    ()=>computeChanges,
    "loadAuditTrail",
    ()=>loadAuditTrail,
    "loadCommitSnapshot",
    ()=>loadCommitSnapshot
]);
'use client';
function buildCommitPath(oid, relativePath) {
    const dir = oid.slice(0, 2);
    const rest = oid.slice(2);
    return "/.legit/commits/".concat(dir, "/").concat(rest, "/").concat(relativePath);
}
function computeChanges(previous, current) {
    if (!current && !previous) {
        return [];
    }
    const changeList = [];
    const keys = new Set([
        ...previous ? Object.keys(previous) : [],
        ...current ? Object.keys(current) : []
    ]);
    for (const key of keys){
        const prevValue = previous ? previous[key] : undefined;
        const currValue = current ? current[key] : undefined;
        const areEqual = prevValue === currValue || JSON.stringify(prevValue) === JSON.stringify(currValue);
        if (!areEqual) {
            changeList.push({
                field: key,
                from: prevValue !== null && prevValue !== void 0 ? prevValue : null,
                to: currValue !== null && currValue !== void 0 ? currValue : null
            });
        }
    }
    return changeList;
}
function summarizeMessage(message) {
    if (!message || typeof message !== 'object') {
        return {};
    }
    const { id, role, parts, text, content } = message;
    let textValue = null;
    if (typeof text === 'string' && text.length > 0) {
        textValue = text;
    } else if (typeof content === 'string' && content.length > 0) {
        textValue = content;
    } else if (Array.isArray(content) && content.every((item)=>item && typeof item === 'object')) {
        const contentParts = content.filter((item)=>item.type === 'text' && typeof item.text === 'string').map((item)=>item.text);
        if (contentParts.length > 0) {
            textValue = contentParts.join('\n');
        }
    } else if (Array.isArray(parts)) {
        const textParts = parts.filter((part)=>part && typeof part === 'object' && part.type === 'text').map((part)=>{
            var _part_text;
            return (_part_text = part.text) !== null && _part_text !== void 0 ? _part_text : '';
        }).filter(Boolean);
        if (textParts.length > 0) {
            textValue = textParts.join('\n');
        }
    }
    return {
        id,
        role,
        text: textValue
    };
}
function messagesEqual(previous, current) {
    if (!previous && !current) {
        return true;
    }
    if (!previous || !current) {
        return false;
    }
    var _previous_text;
    const previousText = ((_previous_text = previous.text) !== null && _previous_text !== void 0 ? _previous_text : '').trim();
    var _current_text;
    const currentText = ((_current_text = current.text) !== null && _current_text !== void 0 ? _current_text : '').trim();
    var _previous_role;
    const previousRole = (_previous_role = previous.role) !== null && _previous_role !== void 0 ? _previous_role : '';
    var _current_role;
    const currentRole = (_current_role = current.role) !== null && _current_role !== void 0 ? _current_role : '';
    if (previousText === currentText && previousRole === currentRole) {
        return true;
    }
    if (previous.id && current.id && previous.id === current.id && previousRole === currentRole && previousText === currentText) {
        return true;
    }
    return false;
}
function extractNewMessages(previousSummaries, current) {
    if (!Array.isArray(current)) {
        return {
            summaries: [],
            newMessages: []
        };
    }
    const currentSummaries = current.map((item)=>summarizeMessage(item));
    const maxSharedLength = Math.min(previousSummaries.length, currentSummaries.length);
    let firstDifferenceIndex = currentSummaries.length;
    for(let index = 0; index < maxSharedLength; index += 1){
        if (!messagesEqual(previousSummaries[index], currentSummaries[index])) {
            firstDifferenceIndex = index;
            break;
        }
    }
    if (firstDifferenceIndex === currentSummaries.length && currentSummaries.length === previousSummaries.length) {
        return {
            summaries: currentSummaries,
            newMessages: []
        };
    }
    if (firstDifferenceIndex === currentSummaries.length) {
        firstDifferenceIndex = previousSummaries.length;
    }
    const newMessages = currentSummaries.slice(firstDifferenceIndex).filter((message)=>{
        var _message_text;
        const text = ((_message_text = message.text) !== null && _message_text !== void 0 ? _message_text : '').trim();
        return text.length > 0;
    });
    return {
        summaries: currentSummaries,
        newMessages
    };
}
async function readJsonFile(legitFsContext, path) {
    const { legitFs } = legitFsContext;
    try {
        const raw = await legitFs.promises.readFile(path, 'utf8');
        return JSON.parse(raw);
    } catch (error) {
        console.warn("Failed to read ".concat(path), error);
        return null;
    }
}
async function loadAuditTrail(context) {
    const { legitFs } = context;
    let rawHistory;
    try {
        rawHistory = await legitFs.promises.readFile('/.legit/branches/main/.legit/history', 'utf8');
    } catch (e) {
        return [];
    }
    const commits = JSON.parse(rawHistory);
    const auditTrail = [];
    let previousForms = null;
    let previousMessageSummaries = [];
    for(let i = commits.length - 1; i >= 0; i -= 1){
        const entry = commits[i];
        const formsState = await readJsonFile(context, buildCommitPath(entry.oid, 'forms.json'));
        const messagesState = await readJsonFile(context, buildCommitPath(entry.oid, 'messages.json'));
        const formChanges = computeChanges(previousForms, formsState);
        const { summaries, newMessages } = extractNewMessages(previousMessageSummaries, messagesState);
        const committedAt = entry.committer ? new Date(entry.committer.timestamp * 1000).toISOString() : null;
        auditTrail.push({
            oid: entry.oid,
            message: entry.message,
            committedAt,
            formChanges,
            newMessages
        });
        previousForms = formsState;
        previousMessageSummaries = summaries;
    }
    auditTrail.reverse();
    return auditTrail;
}
async function loadCommitSnapshot(context, oid) {
    const forms = await readJsonFile(context, buildCommitPath(oid, 'forms.json'));
    const messages = await readJsonFile(context, buildCommitPath(oid, 'messages.json'));
    return {
        forms,
        messages
    };
}
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/examples/ai-form-example/lib/useLegitRuntime.ts [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useLegitRuntime",
    ()=>useLegitRuntime
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$assistant$2d$ui$2b$react$2d$ai$2d$sdk$40$1$2e$1$2e$9_$40$assistant$2d$ui$2b$react$40$0$2e$11$2e$37_$40$types$2b$react$2d$dom$40$19$2e$2$2e$2_$40$types$2b$r_33hphprhob62dzty3jpsbnolpm$2f$node_modules$2f40$assistant$2d$ui$2f$react$2d$ai$2d$sdk$2f$dist$2f$ui$2f$use$2d$chat$2f$useChatRuntime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@assistant-ui+react-ai-sdk@1.1.9_@assistant-ui+react@0.11.37_@types+react-dom@19.2.2_@types+r_33hphprhob62dzty3jpsbnolpm/node_modules/@assistant-ui/react-ai-sdk/dist/ui/use-chat/useChatRuntime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$examples$2f$ai$2d$form$2d$example$2f$lib$2f$legit$2f$fs$2e$ts__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/examples/ai-form-example/lib/legit/fs.ts [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$examples$2f$ai$2d$form$2d$example$2f$lib$2f$legit$2f$history$2e$ts__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/examples/ai-form-example/lib/legit/history.ts [app-client] (ecmascript)");
var _s = __turbopack_context__.k.signature();
'use client';
;
;
;
;
function stableStringify(value) {
    try {
        return JSON.stringify(value);
    } catch (e) {
        return undefined;
    }
}
function useLegitRuntime() {
    _s();
    const runtime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$assistant$2d$ui$2b$react$2d$ai$2d$sdk$40$1$2e$1$2e$9_$40$assistant$2d$ui$2b$react$40$0$2e$11$2e$37_$40$types$2b$react$2d$dom$40$19$2e$2$2e$2_$40$types$2b$r_33hphprhob62dzty3jpsbnolpm$2f$node_modules$2f40$assistant$2d$ui$2f$react$2d$ai$2d$sdk$2f$dist$2f$ui$2f$use$2d$chat$2f$useChatRuntime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useChatRuntime"])();
    const legitApiRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const lastMessagesHashRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(undefined);
    const lastFormHashRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(undefined);
    const ensureLegitApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useLegitRuntime.useCallback[ensureLegitApi]": ()=>{
            if (legitApiRef.current) {
                return legitApiRef.current;
            }
            const saveMessages = {
                "useLegitRuntime.useCallback[ensureLegitApi].saveMessages": async (messages)=>{
                    const { legitFs } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$examples$2f$ai$2d$form$2d$example$2f$lib$2f$legit$2f$fs$2e$ts__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientLegitFs"])();
                    var _ref;
                    const payload = (_ref = messages !== null && messages !== void 0 ? messages : runtime.thread.getState().messages) !== null && _ref !== void 0 ? _ref : [];
                    const hash = stableStringify(payload);
                    if (hash && hash === lastMessagesHashRef.current) {
                        return;
                    }
                    await legitFs.promises.writeFile('/.legit/branches/main/messages.json', JSON.stringify(payload, null, 2), 'utf8');
                    lastMessagesHashRef.current = hash;
                }
            }["useLegitRuntime.useCallback[ensureLegitApi].saveMessages"];
            const saveForm = {
                "useLegitRuntime.useCallback[ensureLegitApi].saveForm": async (formState)=>{
                    const { legitFs } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$examples$2f$ai$2d$form$2d$example$2f$lib$2f$legit$2f$fs$2e$ts__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientLegitFs"])();
                    const hash = stableStringify(formState);
                    if (hash && hash === lastFormHashRef.current) {
                        return;
                    }
                    await legitFs.promises.writeFile('/.legit/branches/main/forms.json', JSON.stringify(formState, null, 2), 'utf8');
                    lastFormHashRef.current = hash;
                }
            }["useLegitRuntime.useCallback[ensureLegitApi].saveForm"];
            const getHistory = {
                "useLegitRuntime.useCallback[ensureLegitApi].getHistory": async ()=>{
                    const context = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$examples$2f$ai$2d$form$2d$example$2f$lib$2f$legit$2f$fs$2e$ts__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientLegitFs"])();
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$examples$2f$ai$2d$form$2d$example$2f$lib$2f$legit$2f$history$2e$ts__$5b$app$2d$client$5d$__$28$ecmascript$29$__["loadAuditTrail"])(context);
                }
            }["useLegitRuntime.useCallback[ensureLegitApi].getHistory"];
            const rollback = {
                "useLegitRuntime.useCallback[ensureLegitApi].rollback": async (oid)=>{
                    const context = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$examples$2f$ai$2d$form$2d$example$2f$lib$2f$legit$2f$fs$2e$ts__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientLegitFs"])();
                    const snapshot = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$examples$2f$ai$2d$form$2d$example$2f$lib$2f$legit$2f$history$2e$ts__$5b$app$2d$client$5d$__$28$ecmascript$29$__["loadCommitSnapshot"])(context, oid);
                    if (Array.isArray(snapshot.messages)) {
                        runtime.thread.reset(snapshot.messages);
                        lastMessagesHashRef.current = stableStringify(snapshot.messages);
                    }
                    if (snapshot.forms) {
                        lastFormHashRef.current = stableStringify(snapshot.forms);
                    }
                    return snapshot;
                }
            }["useLegitRuntime.useCallback[ensureLegitApi].rollback"];
            legitApiRef.current = {
                saveMessages,
                saveForm,
                getHistory,
                rollback
            };
            return legitApiRef.current;
        }
    }["useLegitRuntime.useCallback[ensureLegitApi]"], [
        runtime
    ]);
    const legitApi = ensureLegitApi();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useLegitRuntime.useEffect": ()=>{
            runtime.__legit = legitApi;
        }
    }["useLegitRuntime.useEffect"], [
        runtime,
        legitApi
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useLegitRuntime.useEffect": ()=>{
            let unsubscribed = false;
            let prevIsRunning = runtime.thread.getState().isRunning;
            const handleUpdate = {
                "useLegitRuntime.useEffect.handleUpdate": ()=>{
                    if (unsubscribed) return;
                    const state = runtime.thread.getState();
                    const messages = state.messages;
                    const messagesHash = stableStringify(messages);
                    if (!state.isRunning && messagesHash !== lastMessagesHashRef.current || prevIsRunning && !state.isRunning) {
                        void legitApi.saveMessages(messages);
                    }
                    prevIsRunning = state.isRunning;
                }
            }["useLegitRuntime.useEffect.handleUpdate"];
            const unsubscribe = runtime.thread.subscribe(handleUpdate);
            handleUpdate();
            return ({
                "useLegitRuntime.useEffect": ()=>{
                    unsubscribed = true;
                    unsubscribe();
                }
            })["useLegitRuntime.useEffect"];
        }
    }["useLegitRuntime.useEffect"], [
        runtime,
        legitApi
    ]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useLegitRuntime.useMemo": ()=>runtime
    }["useLegitRuntime.useMemo"], [
        runtime
    ]);
}
_s(useLegitRuntime, "+tIQZliYEppVhb3bZvXAnRJR+9w=", false, function() {
    return [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$assistant$2d$ui$2b$react$2d$ai$2d$sdk$40$1$2e$1$2e$9_$40$assistant$2d$ui$2b$react$40$0$2e$11$2e$37_$40$types$2b$react$2d$dom$40$19$2e$2$2e$2_$40$types$2b$r_33hphprhob62dzty3jpsbnolpm$2f$node_modules$2f40$assistant$2d$ui$2f$react$2d$ai$2d$sdk$2f$dist$2f$ui$2f$use$2d$chat$2f$useChatRuntime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useChatRuntime"]
    ];
});
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/examples/ai-form-example/app/MyRuntimeProvider.tsx [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MyRuntimeProvider",
    ()=>MyRuntimeProvider
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.5.4_@opentelemetry+api@1.9.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$assistant$2d$ui$2b$react$40$0$2e$11$2e$37_$40$types$2b$react$2d$dom$40$19$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$2_$5f40$types$2b$react$40$19$2e$2$2e$2_$5f$utqnq2rpqwwcg76r2vcd3th5pi$2f$node_modules$2f40$assistant$2d$ui$2f$react$2f$dist$2f$legacy$2d$runtime$2f$AssistantRuntimeProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@assistant-ui+react@0.11.37_@types+react-dom@19.2.2_@types+react@19.2.2__@types+react@19.2.2__utqnq2rpqwwcg76r2vcd3th5pi/node_modules/@assistant-ui/react/dist/legacy-runtime/AssistantRuntimeProvider.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$examples$2f$ai$2d$form$2d$example$2f$lib$2f$useLegitRuntime$2e$ts__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/examples/ai-form-example/lib/useLegitRuntime.ts [app-client] (ecmascript)");
;
var _s = __turbopack_context__.k.signature();
'use client';
;
;
function MyRuntimeProvider(param) {
    let { children } = param;
    _s();
    const runtime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$examples$2f$ai$2d$form$2d$example$2f$lib$2f$useLegitRuntime$2e$ts__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLegitRuntime"])();
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$5$2e$4_$40$opentelemetry$2b$api$40$1$2e$9$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxDEV"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$assistant$2d$ui$2b$react$40$0$2e$11$2e$37_$40$types$2b$react$2d$dom$40$19$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$2_$5f40$types$2b$react$40$19$2e$2$2e$2_$5f$utqnq2rpqwwcg76r2vcd3th5pi$2f$node_modules$2f40$assistant$2d$ui$2f$react$2f$dist$2f$legacy$2d$runtime$2f$AssistantRuntimeProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AssistantRuntimeProvider"], {
        runtime: runtime,
        children: children
    }, void 0, false, {
        fileName: "[project]/examples/ai-form-example/app/MyRuntimeProvider.tsx",
        lineNumber: 15,
        columnNumber: 5
    }, this);
}
_s(MyRuntimeProvider, "N5xyKgCXMPBDPK9iQjqKFgJmvXE=", false, function() {
    return [
        __TURBOPACK__imported__module__$5b$project$5d2f$examples$2f$ai$2d$form$2d$example$2f$lib$2f$useLegitRuntime$2e$ts__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLegitRuntime"]
    ];
});
_c = MyRuntimeProvider;
var _c;
__turbopack_context__.k.register(_c, "MyRuntimeProvider");
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
]);

//# sourceMappingURL=_68165907._.js.map